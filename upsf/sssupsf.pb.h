// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sssupsf.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sssupsf_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sssupsf_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sssupsf_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sssupsf_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[61]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sssupsf_2eproto;
namespace bbf {
namespace sss {
class DeleteNetworkConnectionReq;
struct DeleteNetworkConnectionReqDefaultTypeInternal;
extern DeleteNetworkConnectionReqDefaultTypeInternal _DeleteNetworkConnectionReq_default_instance_;
class DeleteServiceGatewayReq;
struct DeleteServiceGatewayReqDefaultTypeInternal;
extern DeleteServiceGatewayReqDefaultTypeInternal _DeleteServiceGatewayReq_default_instance_;
class DeleteServiceGatewayUserPlaneReq;
struct DeleteServiceGatewayUserPlaneReqDefaultTypeInternal;
extern DeleteServiceGatewayUserPlaneReqDefaultTypeInternal _DeleteServiceGatewayUserPlaneReq_default_instance_;
class DeleteSessionContextReq;
struct DeleteSessionContextReqDefaultTypeInternal;
extern DeleteSessionContextReqDefaultTypeInternal _DeleteSessionContextReq_default_instance_;
class DeleteShardReq;
struct DeleteShardReqDefaultTypeInternal;
extern DeleteShardReqDefaultTypeInternal _DeleteShardReq_default_instance_;
class DeleteTrafficSteeringFunctionReq;
struct DeleteTrafficSteeringFunctionReqDefaultTypeInternal;
extern DeleteTrafficSteeringFunctionReqDefaultTypeInternal _DeleteTrafficSteeringFunctionReq_default_instance_;
class GetNetworkConnectionReq;
struct GetNetworkConnectionReqDefaultTypeInternal;
extern GetNetworkConnectionReqDefaultTypeInternal _GetNetworkConnectionReq_default_instance_;
class GetServiceGatewayReq;
struct GetServiceGatewayReqDefaultTypeInternal;
extern GetServiceGatewayReqDefaultTypeInternal _GetServiceGatewayReq_default_instance_;
class GetServiceGatewayUserPlaneReq;
struct GetServiceGatewayUserPlaneReqDefaultTypeInternal;
extern GetServiceGatewayUserPlaneReqDefaultTypeInternal _GetServiceGatewayUserPlaneReq_default_instance_;
class GetSessionContextReq;
struct GetSessionContextReqDefaultTypeInternal;
extern GetSessionContextReqDefaultTypeInternal _GetSessionContextReq_default_instance_;
class GetShardReq;
struct GetShardReqDefaultTypeInternal;
extern GetShardReqDefaultTypeInternal _GetShardReq_default_instance_;
class GetTrafficSteeringFunctionReq;
struct GetTrafficSteeringFunctionReqDefaultTypeInternal;
extern GetTrafficSteeringFunctionReqDefaultTypeInternal _GetTrafficSteeringFunctionReq_default_instance_;
class ListFilter;
struct ListFilterDefaultTypeInternal;
extern ListFilterDefaultTypeInternal _ListFilter_default_instance_;
class ListNetworkConnectionReq;
struct ListNetworkConnectionReqDefaultTypeInternal;
extern ListNetworkConnectionReqDefaultTypeInternal _ListNetworkConnectionReq_default_instance_;
class ListNetworkConnectionResp;
struct ListNetworkConnectionRespDefaultTypeInternal;
extern ListNetworkConnectionRespDefaultTypeInternal _ListNetworkConnectionResp_default_instance_;
class ListServiceGatewayReq;
struct ListServiceGatewayReqDefaultTypeInternal;
extern ListServiceGatewayReqDefaultTypeInternal _ListServiceGatewayReq_default_instance_;
class ListServiceGatewayResp;
struct ListServiceGatewayRespDefaultTypeInternal;
extern ListServiceGatewayRespDefaultTypeInternal _ListServiceGatewayResp_default_instance_;
class ListServiceGatewayUserPlaneReq;
struct ListServiceGatewayUserPlaneReqDefaultTypeInternal;
extern ListServiceGatewayUserPlaneReqDefaultTypeInternal _ListServiceGatewayUserPlaneReq_default_instance_;
class ListServiceGatewayUserPlaneResp;
struct ListServiceGatewayUserPlaneRespDefaultTypeInternal;
extern ListServiceGatewayUserPlaneRespDefaultTypeInternal _ListServiceGatewayUserPlaneResp_default_instance_;
class ListSessionContextReq;
struct ListSessionContextReqDefaultTypeInternal;
extern ListSessionContextReqDefaultTypeInternal _ListSessionContextReq_default_instance_;
class ListSessionContextResp;
struct ListSessionContextRespDefaultTypeInternal;
extern ListSessionContextRespDefaultTypeInternal _ListSessionContextResp_default_instance_;
class ListShardReq;
struct ListShardReqDefaultTypeInternal;
extern ListShardReqDefaultTypeInternal _ListShardReq_default_instance_;
class ListShardResp;
struct ListShardRespDefaultTypeInternal;
extern ListShardRespDefaultTypeInternal _ListShardResp_default_instance_;
class ListTrafficSteeringFunctionReq;
struct ListTrafficSteeringFunctionReqDefaultTypeInternal;
extern ListTrafficSteeringFunctionReqDefaultTypeInternal _ListTrafficSteeringFunctionReq_default_instance_;
class ListTrafficSteeringFunctionResp;
struct ListTrafficSteeringFunctionRespDefaultTypeInternal;
extern ListTrafficSteeringFunctionRespDefaultTypeInternal _ListTrafficSteeringFunctionResp_default_instance_;
class LookupReq;
struct LookupReqDefaultTypeInternal;
extern LookupReqDefaultTypeInternal _LookupReq_default_instance_;
class LookupResp;
struct LookupRespDefaultTypeInternal;
extern LookupRespDefaultTypeInternal _LookupResp_default_instance_;
class MetaData;
struct MetaDataDefaultTypeInternal;
extern MetaDataDefaultTypeInternal _MetaData_default_instance_;
class NetworkConnection;
struct NetworkConnectionDefaultTypeInternal;
extern NetworkConnectionDefaultTypeInternal _NetworkConnection_default_instance_;
class NetworkConnectionResp;
struct NetworkConnectionRespDefaultTypeInternal;
extern NetworkConnectionRespDefaultTypeInternal _NetworkConnectionResp_default_instance_;
class NetworkConnection_Spec;
struct NetworkConnection_SpecDefaultTypeInternal;
extern NetworkConnection_SpecDefaultTypeInternal _NetworkConnection_Spec_default_instance_;
class NetworkConnection_Status;
struct NetworkConnection_StatusDefaultTypeInternal;
extern NetworkConnection_StatusDefaultTypeInternal _NetworkConnection_Status_default_instance_;
class ServiceGateway;
struct ServiceGatewayDefaultTypeInternal;
extern ServiceGatewayDefaultTypeInternal _ServiceGateway_default_instance_;
class ServiceGatewayResp;
struct ServiceGatewayRespDefaultTypeInternal;
extern ServiceGatewayRespDefaultTypeInternal _ServiceGatewayResp_default_instance_;
class ServiceGatewayUserPlane;
struct ServiceGatewayUserPlaneDefaultTypeInternal;
extern ServiceGatewayUserPlaneDefaultTypeInternal _ServiceGatewayUserPlane_default_instance_;
class ServiceGatewayUserPlaneResp;
struct ServiceGatewayUserPlaneRespDefaultTypeInternal;
extern ServiceGatewayUserPlaneRespDefaultTypeInternal _ServiceGatewayUserPlaneResp_default_instance_;
class ServiceGatewayUserPlane_Spec;
struct ServiceGatewayUserPlane_SpecDefaultTypeInternal;
extern ServiceGatewayUserPlane_SpecDefaultTypeInternal _ServiceGatewayUserPlane_Spec_default_instance_;
class ServiceGatewayUserPlane_Status;
struct ServiceGatewayUserPlane_StatusDefaultTypeInternal;
extern ServiceGatewayUserPlane_StatusDefaultTypeInternal _ServiceGatewayUserPlane_Status_default_instance_;
class SessionContext;
struct SessionContextDefaultTypeInternal;
extern SessionContextDefaultTypeInternal _SessionContext_default_instance_;
class SessionContextResp;
struct SessionContextRespDefaultTypeInternal;
extern SessionContextRespDefaultTypeInternal _SessionContextResp_default_instance_;
class SessionContext_Spec;
struct SessionContext_SpecDefaultTypeInternal;
extern SessionContext_SpecDefaultTypeInternal _SessionContext_Spec_default_instance_;
class SessionContext_Status;
struct SessionContext_StatusDefaultTypeInternal;
extern SessionContext_StatusDefaultTypeInternal _SessionContext_Status_default_instance_;
class SessionFilter;
struct SessionFilterDefaultTypeInternal;
extern SessionFilterDefaultTypeInternal _SessionFilter_default_instance_;
class Shard;
struct ShardDefaultTypeInternal;
extern ShardDefaultTypeInternal _Shard_default_instance_;
class ShardResp;
struct ShardRespDefaultTypeInternal;
extern ShardRespDefaultTypeInternal _ShardResp_default_instance_;
class Shard_Spec;
struct Shard_SpecDefaultTypeInternal;
extern Shard_SpecDefaultTypeInternal _Shard_Spec_default_instance_;
class Shard_Status;
struct Shard_StatusDefaultTypeInternal;
extern Shard_StatusDefaultTypeInternal _Shard_Status_default_instance_;
class Shard_Status_TsfNetworkConnectionEntry_DoNotUse;
struct Shard_Status_TsfNetworkConnectionEntry_DoNotUseDefaultTypeInternal;
extern Shard_Status_TsfNetworkConnectionEntry_DoNotUseDefaultTypeInternal _Shard_Status_TsfNetworkConnectionEntry_DoNotUse_default_instance_;
class SubscribeReq;
struct SubscribeReqDefaultTypeInternal;
extern SubscribeReqDefaultTypeInternal _SubscribeReq_default_instance_;
class TrafficSteeringFunction;
struct TrafficSteeringFunctionDefaultTypeInternal;
extern TrafficSteeringFunctionDefaultTypeInternal _TrafficSteeringFunction_default_instance_;
class TrafficSteeringFunctionResp;
struct TrafficSteeringFunctionRespDefaultTypeInternal;
extern TrafficSteeringFunctionRespDefaultTypeInternal _TrafficSteeringFunctionResp_default_instance_;
class TrafficSteeringFunction_Spec;
struct TrafficSteeringFunction_SpecDefaultTypeInternal;
extern TrafficSteeringFunction_SpecDefaultTypeInternal _TrafficSteeringFunction_Spec_default_instance_;
class Update;
struct UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
class UpdateNetworkConnectionReq;
struct UpdateNetworkConnectionReqDefaultTypeInternal;
extern UpdateNetworkConnectionReqDefaultTypeInternal _UpdateNetworkConnectionReq_default_instance_;
class UpdateServiceGatewayReq;
struct UpdateServiceGatewayReqDefaultTypeInternal;
extern UpdateServiceGatewayReqDefaultTypeInternal _UpdateServiceGatewayReq_default_instance_;
class UpdateServiceGatewayUserPlaneReq;
struct UpdateServiceGatewayUserPlaneReqDefaultTypeInternal;
extern UpdateServiceGatewayUserPlaneReqDefaultTypeInternal _UpdateServiceGatewayUserPlaneReq_default_instance_;
class UpdateSessionContextReq;
struct UpdateSessionContextReqDefaultTypeInternal;
extern UpdateSessionContextReqDefaultTypeInternal _UpdateSessionContextReq_default_instance_;
class UpdateShardReq;
struct UpdateShardReqDefaultTypeInternal;
extern UpdateShardReqDefaultTypeInternal _UpdateShardReq_default_instance_;
class UpdateTrafficSteeringFunctionReq;
struct UpdateTrafficSteeringFunctionReqDefaultTypeInternal;
extern UpdateTrafficSteeringFunctionReqDefaultTypeInternal _UpdateTrafficSteeringFunctionReq_default_instance_;
class VxlanConnection;
struct VxlanConnectionDefaultTypeInternal;
extern VxlanConnectionDefaultTypeInternal _VxlanConnection_default_instance_;
class VxlanConnection_Vtep;
struct VxlanConnection_VtepDefaultTypeInternal;
extern VxlanConnection_VtepDefaultTypeInternal _VxlanConnection_Vtep_default_instance_;
}  // namespace sss
}  // namespace bbf
PROTOBUF_NAMESPACE_OPEN
template<> ::bbf::sss::DeleteNetworkConnectionReq* Arena::CreateMaybeMessage<::bbf::sss::DeleteNetworkConnectionReq>(Arena*);
template<> ::bbf::sss::DeleteServiceGatewayReq* Arena::CreateMaybeMessage<::bbf::sss::DeleteServiceGatewayReq>(Arena*);
template<> ::bbf::sss::DeleteServiceGatewayUserPlaneReq* Arena::CreateMaybeMessage<::bbf::sss::DeleteServiceGatewayUserPlaneReq>(Arena*);
template<> ::bbf::sss::DeleteSessionContextReq* Arena::CreateMaybeMessage<::bbf::sss::DeleteSessionContextReq>(Arena*);
template<> ::bbf::sss::DeleteShardReq* Arena::CreateMaybeMessage<::bbf::sss::DeleteShardReq>(Arena*);
template<> ::bbf::sss::DeleteTrafficSteeringFunctionReq* Arena::CreateMaybeMessage<::bbf::sss::DeleteTrafficSteeringFunctionReq>(Arena*);
template<> ::bbf::sss::GetNetworkConnectionReq* Arena::CreateMaybeMessage<::bbf::sss::GetNetworkConnectionReq>(Arena*);
template<> ::bbf::sss::GetServiceGatewayReq* Arena::CreateMaybeMessage<::bbf::sss::GetServiceGatewayReq>(Arena*);
template<> ::bbf::sss::GetServiceGatewayUserPlaneReq* Arena::CreateMaybeMessage<::bbf::sss::GetServiceGatewayUserPlaneReq>(Arena*);
template<> ::bbf::sss::GetSessionContextReq* Arena::CreateMaybeMessage<::bbf::sss::GetSessionContextReq>(Arena*);
template<> ::bbf::sss::GetShardReq* Arena::CreateMaybeMessage<::bbf::sss::GetShardReq>(Arena*);
template<> ::bbf::sss::GetTrafficSteeringFunctionReq* Arena::CreateMaybeMessage<::bbf::sss::GetTrafficSteeringFunctionReq>(Arena*);
template<> ::bbf::sss::ListFilter* Arena::CreateMaybeMessage<::bbf::sss::ListFilter>(Arena*);
template<> ::bbf::sss::ListNetworkConnectionReq* Arena::CreateMaybeMessage<::bbf::sss::ListNetworkConnectionReq>(Arena*);
template<> ::bbf::sss::ListNetworkConnectionResp* Arena::CreateMaybeMessage<::bbf::sss::ListNetworkConnectionResp>(Arena*);
template<> ::bbf::sss::ListServiceGatewayReq* Arena::CreateMaybeMessage<::bbf::sss::ListServiceGatewayReq>(Arena*);
template<> ::bbf::sss::ListServiceGatewayResp* Arena::CreateMaybeMessage<::bbf::sss::ListServiceGatewayResp>(Arena*);
template<> ::bbf::sss::ListServiceGatewayUserPlaneReq* Arena::CreateMaybeMessage<::bbf::sss::ListServiceGatewayUserPlaneReq>(Arena*);
template<> ::bbf::sss::ListServiceGatewayUserPlaneResp* Arena::CreateMaybeMessage<::bbf::sss::ListServiceGatewayUserPlaneResp>(Arena*);
template<> ::bbf::sss::ListSessionContextReq* Arena::CreateMaybeMessage<::bbf::sss::ListSessionContextReq>(Arena*);
template<> ::bbf::sss::ListSessionContextResp* Arena::CreateMaybeMessage<::bbf::sss::ListSessionContextResp>(Arena*);
template<> ::bbf::sss::ListShardReq* Arena::CreateMaybeMessage<::bbf::sss::ListShardReq>(Arena*);
template<> ::bbf::sss::ListShardResp* Arena::CreateMaybeMessage<::bbf::sss::ListShardResp>(Arena*);
template<> ::bbf::sss::ListTrafficSteeringFunctionReq* Arena::CreateMaybeMessage<::bbf::sss::ListTrafficSteeringFunctionReq>(Arena*);
template<> ::bbf::sss::ListTrafficSteeringFunctionResp* Arena::CreateMaybeMessage<::bbf::sss::ListTrafficSteeringFunctionResp>(Arena*);
template<> ::bbf::sss::LookupReq* Arena::CreateMaybeMessage<::bbf::sss::LookupReq>(Arena*);
template<> ::bbf::sss::LookupResp* Arena::CreateMaybeMessage<::bbf::sss::LookupResp>(Arena*);
template<> ::bbf::sss::MetaData* Arena::CreateMaybeMessage<::bbf::sss::MetaData>(Arena*);
template<> ::bbf::sss::NetworkConnection* Arena::CreateMaybeMessage<::bbf::sss::NetworkConnection>(Arena*);
template<> ::bbf::sss::NetworkConnectionResp* Arena::CreateMaybeMessage<::bbf::sss::NetworkConnectionResp>(Arena*);
template<> ::bbf::sss::NetworkConnection_Spec* Arena::CreateMaybeMessage<::bbf::sss::NetworkConnection_Spec>(Arena*);
template<> ::bbf::sss::NetworkConnection_Status* Arena::CreateMaybeMessage<::bbf::sss::NetworkConnection_Status>(Arena*);
template<> ::bbf::sss::ServiceGateway* Arena::CreateMaybeMessage<::bbf::sss::ServiceGateway>(Arena*);
template<> ::bbf::sss::ServiceGatewayResp* Arena::CreateMaybeMessage<::bbf::sss::ServiceGatewayResp>(Arena*);
template<> ::bbf::sss::ServiceGatewayUserPlane* Arena::CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlane>(Arena*);
template<> ::bbf::sss::ServiceGatewayUserPlaneResp* Arena::CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlaneResp>(Arena*);
template<> ::bbf::sss::ServiceGatewayUserPlane_Spec* Arena::CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlane_Spec>(Arena*);
template<> ::bbf::sss::ServiceGatewayUserPlane_Status* Arena::CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlane_Status>(Arena*);
template<> ::bbf::sss::SessionContext* Arena::CreateMaybeMessage<::bbf::sss::SessionContext>(Arena*);
template<> ::bbf::sss::SessionContextResp* Arena::CreateMaybeMessage<::bbf::sss::SessionContextResp>(Arena*);
template<> ::bbf::sss::SessionContext_Spec* Arena::CreateMaybeMessage<::bbf::sss::SessionContext_Spec>(Arena*);
template<> ::bbf::sss::SessionContext_Status* Arena::CreateMaybeMessage<::bbf::sss::SessionContext_Status>(Arena*);
template<> ::bbf::sss::SessionFilter* Arena::CreateMaybeMessage<::bbf::sss::SessionFilter>(Arena*);
template<> ::bbf::sss::Shard* Arena::CreateMaybeMessage<::bbf::sss::Shard>(Arena*);
template<> ::bbf::sss::ShardResp* Arena::CreateMaybeMessage<::bbf::sss::ShardResp>(Arena*);
template<> ::bbf::sss::Shard_Spec* Arena::CreateMaybeMessage<::bbf::sss::Shard_Spec>(Arena*);
template<> ::bbf::sss::Shard_Status* Arena::CreateMaybeMessage<::bbf::sss::Shard_Status>(Arena*);
template<> ::bbf::sss::Shard_Status_TsfNetworkConnectionEntry_DoNotUse* Arena::CreateMaybeMessage<::bbf::sss::Shard_Status_TsfNetworkConnectionEntry_DoNotUse>(Arena*);
template<> ::bbf::sss::SubscribeReq* Arena::CreateMaybeMessage<::bbf::sss::SubscribeReq>(Arena*);
template<> ::bbf::sss::TrafficSteeringFunction* Arena::CreateMaybeMessage<::bbf::sss::TrafficSteeringFunction>(Arena*);
template<> ::bbf::sss::TrafficSteeringFunctionResp* Arena::CreateMaybeMessage<::bbf::sss::TrafficSteeringFunctionResp>(Arena*);
template<> ::bbf::sss::TrafficSteeringFunction_Spec* Arena::CreateMaybeMessage<::bbf::sss::TrafficSteeringFunction_Spec>(Arena*);
template<> ::bbf::sss::Update* Arena::CreateMaybeMessage<::bbf::sss::Update>(Arena*);
template<> ::bbf::sss::UpdateNetworkConnectionReq* Arena::CreateMaybeMessage<::bbf::sss::UpdateNetworkConnectionReq>(Arena*);
template<> ::bbf::sss::UpdateServiceGatewayReq* Arena::CreateMaybeMessage<::bbf::sss::UpdateServiceGatewayReq>(Arena*);
template<> ::bbf::sss::UpdateServiceGatewayUserPlaneReq* Arena::CreateMaybeMessage<::bbf::sss::UpdateServiceGatewayUserPlaneReq>(Arena*);
template<> ::bbf::sss::UpdateSessionContextReq* Arena::CreateMaybeMessage<::bbf::sss::UpdateSessionContextReq>(Arena*);
template<> ::bbf::sss::UpdateShardReq* Arena::CreateMaybeMessage<::bbf::sss::UpdateShardReq>(Arena*);
template<> ::bbf::sss::UpdateTrafficSteeringFunctionReq* Arena::CreateMaybeMessage<::bbf::sss::UpdateTrafficSteeringFunctionReq>(Arena*);
template<> ::bbf::sss::VxlanConnection* Arena::CreateMaybeMessage<::bbf::sss::VxlanConnection>(Arena*);
template<> ::bbf::sss::VxlanConnection_Vtep* Arena::CreateMaybeMessage<::bbf::sss::VxlanConnection_Vtep>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bbf {
namespace sss {

enum SubscribeReq_SubscriptionType : int {
  SubscribeReq_SubscriptionType_shards = 0,
  SubscribeReq_SubscriptionType_session_contexts = 1,
  SubscribeReq_SubscriptionType_network_connections = 2,
  SubscribeReq_SubscriptionType_service_gateway_user_planes = 3,
  SubscribeReq_SubscriptionType_traffic_steering_functions = 4,
  SubscribeReq_SubscriptionType_service_gateways = 5,
  SubscribeReq_SubscriptionType_SubscribeReq_SubscriptionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SubscribeReq_SubscriptionType_SubscribeReq_SubscriptionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SubscribeReq_SubscriptionType_IsValid(int value);
constexpr SubscribeReq_SubscriptionType SubscribeReq_SubscriptionType_SubscriptionType_MIN = SubscribeReq_SubscriptionType_shards;
constexpr SubscribeReq_SubscriptionType SubscribeReq_SubscriptionType_SubscriptionType_MAX = SubscribeReq_SubscriptionType_service_gateways;
constexpr int SubscribeReq_SubscriptionType_SubscriptionType_ARRAYSIZE = SubscribeReq_SubscriptionType_SubscriptionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SubscribeReq_SubscriptionType_descriptor();
template<typename T>
inline const std::string& SubscribeReq_SubscriptionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SubscribeReq_SubscriptionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SubscribeReq_SubscriptionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SubscribeReq_SubscriptionType_descriptor(), enum_t_value);
}
inline bool SubscribeReq_SubscriptionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SubscribeReq_SubscriptionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SubscribeReq_SubscriptionType>(
    SubscribeReq_SubscriptionType_descriptor(), name, value);
}
enum NetworkConnection_Status_NcEndpointStatus : int {
  NetworkConnection_Status_NcEndpointStatus_UNKNOWN = 0,
  NetworkConnection_Status_NcEndpointStatus_UP = 1,
  NetworkConnection_Status_NcEndpointStatus_DOWN = 2,
  NetworkConnection_Status_NcEndpointStatus_NetworkConnection_Status_NcEndpointStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetworkConnection_Status_NcEndpointStatus_NetworkConnection_Status_NcEndpointStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetworkConnection_Status_NcEndpointStatus_IsValid(int value);
constexpr NetworkConnection_Status_NcEndpointStatus NetworkConnection_Status_NcEndpointStatus_NcEndpointStatus_MIN = NetworkConnection_Status_NcEndpointStatus_UNKNOWN;
constexpr NetworkConnection_Status_NcEndpointStatus NetworkConnection_Status_NcEndpointStatus_NcEndpointStatus_MAX = NetworkConnection_Status_NcEndpointStatus_DOWN;
constexpr int NetworkConnection_Status_NcEndpointStatus_NcEndpointStatus_ARRAYSIZE = NetworkConnection_Status_NcEndpointStatus_NcEndpointStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetworkConnection_Status_NcEndpointStatus_descriptor();
template<typename T>
inline const std::string& NetworkConnection_Status_NcEndpointStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetworkConnection_Status_NcEndpointStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetworkConnection_Status_NcEndpointStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetworkConnection_Status_NcEndpointStatus_descriptor(), enum_t_value);
}
inline bool NetworkConnection_Status_NcEndpointStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetworkConnection_Status_NcEndpointStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetworkConnection_Status_NcEndpointStatus>(
    NetworkConnection_Status_NcEndpointStatus_descriptor(), name, value);
}
enum SessionContext_Spec_ContextType : int {
  SessionContext_Spec_ContextType_DEFAULT = 0,
  SessionContext_Spec_ContextType_PPPOE = 1,
  SessionContext_Spec_ContextType_IPOE = 2,
  SessionContext_Spec_ContextType_SessionContext_Spec_ContextType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SessionContext_Spec_ContextType_SessionContext_Spec_ContextType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SessionContext_Spec_ContextType_IsValid(int value);
constexpr SessionContext_Spec_ContextType SessionContext_Spec_ContextType_ContextType_MIN = SessionContext_Spec_ContextType_DEFAULT;
constexpr SessionContext_Spec_ContextType SessionContext_Spec_ContextType_ContextType_MAX = SessionContext_Spec_ContextType_IPOE;
constexpr int SessionContext_Spec_ContextType_ContextType_ARRAYSIZE = SessionContext_Spec_ContextType_ContextType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SessionContext_Spec_ContextType_descriptor();
template<typename T>
inline const std::string& SessionContext_Spec_ContextType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionContext_Spec_ContextType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionContext_Spec_ContextType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SessionContext_Spec_ContextType_descriptor(), enum_t_value);
}
inline bool SessionContext_Spec_ContextType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionContext_Spec_ContextType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SessionContext_Spec_ContextType>(
    SessionContext_Spec_ContextType_descriptor(), name, value);
}
enum Result : int {
  success = 0,
  fail = 1,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = success;
constexpr Result Result_MAX = fail;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
enum ItemStatus : int {
  unknown = 0,
  active = 1,
  updating = 2,
  deleting = 3,
  deleted = 4,
  inactive = 5,
  ItemStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemStatus_IsValid(int value);
constexpr ItemStatus ItemStatus_MIN = unknown;
constexpr ItemStatus ItemStatus_MAX = inactive;
constexpr int ItemStatus_ARRAYSIZE = ItemStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemStatus_descriptor();
template<typename T>
inline const std::string& ItemStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemStatus_descriptor(), enum_t_value);
}
inline bool ItemStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemStatus>(
    ItemStatus_descriptor(), name, value);
}
// ===================================================================

class MetaData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.MetaData) */ {
 public:
  inline MetaData() : MetaData(nullptr) {}
  ~MetaData() override;
  explicit constexpr MetaData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaData(const MetaData& from);
  MetaData(MetaData&& from) noexcept
    : MetaData() {
    *this = ::std::move(from);
  }

  inline MetaData& operator=(const MetaData& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaData& operator=(MetaData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaData& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaData* internal_default_instance() {
    return reinterpret_cast<const MetaData*>(
               &_MetaData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MetaData& a, MetaData& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetaData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetaData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetaData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.MetaData";
  }
  protected:
  explicit MetaData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 6,
    kLastUpdatedFieldNumber = 1,
    kCreatedFieldNumber = 2,
    kDeleteRequestedFieldNumber = 3,
    kDeletedFieldNumber = 4,
    kItemStatusFieldNumber = 5,
  };
  // string name = 6;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .google.protobuf.Timestamp last_updated = 1;
  bool has_last_updated() const;
  private:
  bool _internal_has_last_updated() const;
  public:
  void clear_last_updated();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& last_updated() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_last_updated();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_last_updated();
  void set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_last_updated() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_last_updated();
  public:
  void unsafe_arena_set_allocated_last_updated(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_last_updated();

  // .google.protobuf.Timestamp created = 2;
  bool has_created() const;
  private:
  bool _internal_has_created() const;
  public:
  void clear_created();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& created() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_created();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_created();
  void set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_created() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_created();
  public:
  void unsafe_arena_set_allocated_created(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* created);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_created();

  // .google.protobuf.Timestamp delete_requested = 3;
  bool has_delete_requested() const;
  private:
  bool _internal_has_delete_requested() const;
  public:
  void clear_delete_requested();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& delete_requested() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_delete_requested();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_delete_requested();
  void set_allocated_delete_requested(::PROTOBUF_NAMESPACE_ID::Timestamp* delete_requested);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_delete_requested() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_delete_requested();
  public:
  void unsafe_arena_set_allocated_delete_requested(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* delete_requested);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_delete_requested();

  // .google.protobuf.Timestamp deleted = 4;
  bool has_deleted() const;
  private:
  bool _internal_has_deleted() const;
  public:
  void clear_deleted();
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& deleted() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Timestamp* release_deleted();
  ::PROTOBUF_NAMESPACE_ID::Timestamp* mutable_deleted();
  void set_allocated_deleted(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Timestamp& _internal_deleted() const;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_deleted();
  public:
  void unsafe_arena_set_allocated_deleted(
      ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted);
  ::PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_deleted();

  // .bbf.sss.ItemStatus item_status = 5;
  void clear_item_status();
  ::bbf::sss::ItemStatus item_status() const;
  void set_item_status(::bbf::sss::ItemStatus value);
  private:
  ::bbf::sss::ItemStatus _internal_item_status() const;
  void _internal_set_item_status(::bbf::sss::ItemStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.MetaData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* created_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* delete_requested_;
  ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted_;
  int item_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListFilter) */ {
 public:
  inline ListFilter() : ListFilter(nullptr) {}
  ~ListFilter() override;
  explicit constexpr ListFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListFilter(const ListFilter& from);
  ListFilter(ListFilter&& from) noexcept
    : ListFilter() {
    *this = ::std::move(from);
  }

  inline ListFilter& operator=(const ListFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListFilter& operator=(ListFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListFilter* internal_default_instance() {
    return reinterpret_cast<const ListFilter*>(
               &_ListFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ListFilter& a, ListFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ListFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListFilter";
  }
  protected:
  explicit ListFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdListFieldNumber = 2,
  };
  // repeated string id_list = 2;
  int id_list_size() const;
  private:
  int _internal_id_list_size() const;
  public:
  void clear_id_list();
  const std::string& id_list(int index) const;
  std::string* mutable_id_list(int index);
  void set_id_list(int index, const std::string& value);
  void set_id_list(int index, std::string&& value);
  void set_id_list(int index, const char* value);
  void set_id_list(int index, const char* value, size_t size);
  std::string* add_id_list();
  void add_id_list(const std::string& value);
  void add_id_list(std::string&& value);
  void add_id_list(const char* value);
  void add_id_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id_list();
  private:
  const std::string& _internal_id_list(int index) const;
  std::string* _internal_add_id_list();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ListFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class SubscribeReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.SubscribeReq) */ {
 public:
  inline SubscribeReq() : SubscribeReq(nullptr) {}
  ~SubscribeReq() override;
  explicit constexpr SubscribeReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribeReq(const SubscribeReq& from);
  SubscribeReq(SubscribeReq&& from) noexcept
    : SubscribeReq() {
    *this = ::std::move(from);
  }

  inline SubscribeReq& operator=(const SubscribeReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribeReq& operator=(SubscribeReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SubscribeReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribeReq* internal_default_instance() {
    return reinterpret_cast<const SubscribeReq*>(
               &_SubscribeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SubscribeReq& a, SubscribeReq& b) {
    a.Swap(&b);
  }
  inline void Swap(SubscribeReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribeReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribeReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribeReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SubscribeReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SubscribeReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.SubscribeReq";
  }
  protected:
  explicit SubscribeReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SubscribeReq_SubscriptionType SubscriptionType;
  static constexpr SubscriptionType shards =
    SubscribeReq_SubscriptionType_shards;
  static constexpr SubscriptionType session_contexts =
    SubscribeReq_SubscriptionType_session_contexts;
  static constexpr SubscriptionType network_connections =
    SubscribeReq_SubscriptionType_network_connections;
  static constexpr SubscriptionType service_gateway_user_planes =
    SubscribeReq_SubscriptionType_service_gateway_user_planes;
  static constexpr SubscriptionType traffic_steering_functions =
    SubscribeReq_SubscriptionType_traffic_steering_functions;
  static constexpr SubscriptionType service_gateways =
    SubscribeReq_SubscriptionType_service_gateways;
  static inline bool SubscriptionType_IsValid(int value) {
    return SubscribeReq_SubscriptionType_IsValid(value);
  }
  static constexpr SubscriptionType SubscriptionType_MIN =
    SubscribeReq_SubscriptionType_SubscriptionType_MIN;
  static constexpr SubscriptionType SubscriptionType_MAX =
    SubscribeReq_SubscriptionType_SubscriptionType_MAX;
  static constexpr int SubscriptionType_ARRAYSIZE =
    SubscribeReq_SubscriptionType_SubscriptionType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SubscriptionType_descriptor() {
    return SubscribeReq_SubscriptionType_descriptor();
  }
  template<typename T>
  static inline const std::string& SubscriptionType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SubscriptionType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SubscriptionType_Name.");
    return SubscribeReq_SubscriptionType_Name(enum_t_value);
  }
  static inline bool SubscriptionType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SubscriptionType* value) {
    return SubscribeReq_SubscriptionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSubscriptionFieldNumber = 1,
    kIdListFieldNumber = 2,
  };
  // repeated .bbf.sss.SubscribeReq.SubscriptionType subscription = 1;
  int subscription_size() const;
  private:
  int _internal_subscription_size() const;
  public:
  void clear_subscription();
  private:
  ::bbf::sss::SubscribeReq_SubscriptionType _internal_subscription(int index) const;
  void _internal_add_subscription(::bbf::sss::SubscribeReq_SubscriptionType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_subscription();
  public:
  ::bbf::sss::SubscribeReq_SubscriptionType subscription(int index) const;
  void set_subscription(int index, ::bbf::sss::SubscribeReq_SubscriptionType value);
  void add_subscription(::bbf::sss::SubscribeReq_SubscriptionType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& subscription() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_subscription();

  // repeated string id_list = 2;
  int id_list_size() const;
  private:
  int _internal_id_list_size() const;
  public:
  void clear_id_list();
  const std::string& id_list(int index) const;
  std::string* mutable_id_list(int index);
  void set_id_list(int index, const std::string& value);
  void set_id_list(int index, std::string&& value);
  void set_id_list(int index, const char* value);
  void set_id_list(int index, const char* value, size_t size);
  std::string* add_id_list();
  void add_id_list(const std::string& value);
  void add_id_list(std::string&& value);
  void add_id_list(const char* value);
  void add_id_list(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id_list();
  private:
  const std::string& _internal_id_list(int index) const;
  std::string* _internal_add_id_list();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.SubscribeReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> subscription_;
  mutable std::atomic<int> _subscription_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_list_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class Update final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.Update) */ {
 public:
  inline Update() : Update(nullptr) {}
  ~Update() override;
  explicit constexpr Update(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Update(const Update& from);
  Update(Update&& from) noexcept
    : Update() {
    *this = ::std::move(from);
  }

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }
  inline Update& operator=(Update&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Update& default_instance() {
    return *internal_default_instance();
  }
  enum ItemCase {
    kShard = 1,
    kSessionContext = 2,
    kNetworkConnection = 3,
    kServiceGatewayUserPlane = 4,
    kTrafficSteeringFunction = 5,
    kServiceGateway = 6,
    ITEM_NOT_SET = 0,
  };

  static inline const Update* internal_default_instance() {
    return reinterpret_cast<const Update*>(
               &_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Update& a, Update& b) {
    a.Swap(&b);
  }
  inline void Swap(Update* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Update* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Update* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Update>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Update& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Update& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Update* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.Update";
  }
  protected:
  explicit Update(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardFieldNumber = 1,
    kSessionContextFieldNumber = 2,
    kNetworkConnectionFieldNumber = 3,
    kServiceGatewayUserPlaneFieldNumber = 4,
    kTrafficSteeringFunctionFieldNumber = 5,
    kServiceGatewayFieldNumber = 6,
  };
  // .bbf.sss.Shard shard = 1;
  bool has_shard() const;
  private:
  bool _internal_has_shard() const;
  public:
  void clear_shard();
  const ::bbf::sss::Shard& shard() const;
  PROTOBUF_NODISCARD ::bbf::sss::Shard* release_shard();
  ::bbf::sss::Shard* mutable_shard();
  void set_allocated_shard(::bbf::sss::Shard* shard);
  private:
  const ::bbf::sss::Shard& _internal_shard() const;
  ::bbf::sss::Shard* _internal_mutable_shard();
  public:
  void unsafe_arena_set_allocated_shard(
      ::bbf::sss::Shard* shard);
  ::bbf::sss::Shard* unsafe_arena_release_shard();

  // .bbf.sss.SessionContext session_context = 2;
  bool has_session_context() const;
  private:
  bool _internal_has_session_context() const;
  public:
  void clear_session_context();
  const ::bbf::sss::SessionContext& session_context() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionContext* release_session_context();
  ::bbf::sss::SessionContext* mutable_session_context();
  void set_allocated_session_context(::bbf::sss::SessionContext* session_context);
  private:
  const ::bbf::sss::SessionContext& _internal_session_context() const;
  ::bbf::sss::SessionContext* _internal_mutable_session_context();
  public:
  void unsafe_arena_set_allocated_session_context(
      ::bbf::sss::SessionContext* session_context);
  ::bbf::sss::SessionContext* unsafe_arena_release_session_context();

  // .bbf.sss.NetworkConnection network_connection = 3;
  bool has_network_connection() const;
  private:
  bool _internal_has_network_connection() const;
  public:
  void clear_network_connection();
  const ::bbf::sss::NetworkConnection& network_connection() const;
  PROTOBUF_NODISCARD ::bbf::sss::NetworkConnection* release_network_connection();
  ::bbf::sss::NetworkConnection* mutable_network_connection();
  void set_allocated_network_connection(::bbf::sss::NetworkConnection* network_connection);
  private:
  const ::bbf::sss::NetworkConnection& _internal_network_connection() const;
  ::bbf::sss::NetworkConnection* _internal_mutable_network_connection();
  public:
  void unsafe_arena_set_allocated_network_connection(
      ::bbf::sss::NetworkConnection* network_connection);
  ::bbf::sss::NetworkConnection* unsafe_arena_release_network_connection();

  // .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 4;
  bool has_service_gateway_user_plane() const;
  private:
  bool _internal_has_service_gateway_user_plane() const;
  public:
  void clear_service_gateway_user_plane();
  const ::bbf::sss::ServiceGatewayUserPlane& service_gateway_user_plane() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGatewayUserPlane* release_service_gateway_user_plane();
  ::bbf::sss::ServiceGatewayUserPlane* mutable_service_gateway_user_plane();
  void set_allocated_service_gateway_user_plane(::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane);
  private:
  const ::bbf::sss::ServiceGatewayUserPlane& _internal_service_gateway_user_plane() const;
  ::bbf::sss::ServiceGatewayUserPlane* _internal_mutable_service_gateway_user_plane();
  public:
  void unsafe_arena_set_allocated_service_gateway_user_plane(
      ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane);
  ::bbf::sss::ServiceGatewayUserPlane* unsafe_arena_release_service_gateway_user_plane();

  // .bbf.sss.TrafficSteeringFunction traffic_steering_function = 5;
  bool has_traffic_steering_function() const;
  private:
  bool _internal_has_traffic_steering_function() const;
  public:
  void clear_traffic_steering_function();
  const ::bbf::sss::TrafficSteeringFunction& traffic_steering_function() const;
  PROTOBUF_NODISCARD ::bbf::sss::TrafficSteeringFunction* release_traffic_steering_function();
  ::bbf::sss::TrafficSteeringFunction* mutable_traffic_steering_function();
  void set_allocated_traffic_steering_function(::bbf::sss::TrafficSteeringFunction* traffic_steering_function);
  private:
  const ::bbf::sss::TrafficSteeringFunction& _internal_traffic_steering_function() const;
  ::bbf::sss::TrafficSteeringFunction* _internal_mutable_traffic_steering_function();
  public:
  void unsafe_arena_set_allocated_traffic_steering_function(
      ::bbf::sss::TrafficSteeringFunction* traffic_steering_function);
  ::bbf::sss::TrafficSteeringFunction* unsafe_arena_release_traffic_steering_function();

  // .bbf.sss.ServiceGateway service_gateway = 6;
  bool has_service_gateway() const;
  private:
  bool _internal_has_service_gateway() const;
  public:
  void clear_service_gateway();
  const ::bbf::sss::ServiceGateway& service_gateway() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGateway* release_service_gateway();
  ::bbf::sss::ServiceGateway* mutable_service_gateway();
  void set_allocated_service_gateway(::bbf::sss::ServiceGateway* service_gateway);
  private:
  const ::bbf::sss::ServiceGateway& _internal_service_gateway() const;
  ::bbf::sss::ServiceGateway* _internal_mutable_service_gateway();
  public:
  void unsafe_arena_set_allocated_service_gateway(
      ::bbf::sss::ServiceGateway* service_gateway);
  ::bbf::sss::ServiceGateway* unsafe_arena_release_service_gateway();

  void clear_item();
  ItemCase item_case() const;
  // @@protoc_insertion_point(class_scope:bbf.sss.Update)
 private:
  class _Internal;
  void set_has_shard();
  void set_has_session_context();
  void set_has_network_connection();
  void set_has_service_gateway_user_plane();
  void set_has_traffic_steering_function();
  void set_has_service_gateway();

  inline bool has_item() const;
  inline void clear_has_item();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ItemUnion {
    constexpr ItemUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::bbf::sss::Shard* shard_;
    ::bbf::sss::SessionContext* session_context_;
    ::bbf::sss::NetworkConnection* network_connection_;
    ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane_;
    ::bbf::sss::TrafficSteeringFunction* traffic_steering_function_;
    ::bbf::sss::ServiceGateway* service_gateway_;
  } item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class LookupReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.LookupReq) */ {
 public:
  inline LookupReq() : LookupReq(nullptr) {}
  ~LookupReq() override;
  explicit constexpr LookupReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupReq(const LookupReq& from);
  LookupReq(LookupReq&& from) noexcept
    : LookupReq() {
    *this = ::std::move(from);
  }

  inline LookupReq& operator=(const LookupReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupReq& operator=(LookupReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupReq* internal_default_instance() {
    return reinterpret_cast<const LookupReq*>(
               &_LookupReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LookupReq& a, LookupReq& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.LookupReq";
  }
  protected:
  explicit LookupReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 2,
  };
  // .bbf.sss.SessionContext.Spec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bbf::sss::SessionContext_Spec& spec() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionContext_Spec* release_spec();
  ::bbf::sss::SessionContext_Spec* mutable_spec();
  void set_allocated_spec(::bbf::sss::SessionContext_Spec* spec);
  private:
  const ::bbf::sss::SessionContext_Spec& _internal_spec() const;
  ::bbf::sss::SessionContext_Spec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bbf::sss::SessionContext_Spec* spec);
  ::bbf::sss::SessionContext_Spec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:bbf.sss.LookupReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::SessionContext_Spec* spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class LookupResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.LookupResp) */ {
 public:
  inline LookupResp() : LookupResp(nullptr) {}
  ~LookupResp() override;
  explicit constexpr LookupResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupResp(const LookupResp& from);
  LookupResp(LookupResp&& from) noexcept
    : LookupResp() {
    *this = ::std::move(from);
  }

  inline LookupResp& operator=(const LookupResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupResp& operator=(LookupResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupResp* internal_default_instance() {
    return reinterpret_cast<const LookupResp*>(
               &_LookupResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LookupResp& a, LookupResp& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LookupResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LookupResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.LookupResp";
  }
  protected:
  explicit LookupResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionContextFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .bbf.sss.SessionContext session_context = 2;
  bool has_session_context() const;
  private:
  bool _internal_has_session_context() const;
  public:
  void clear_session_context();
  const ::bbf::sss::SessionContext& session_context() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionContext* release_session_context();
  ::bbf::sss::SessionContext* mutable_session_context();
  void set_allocated_session_context(::bbf::sss::SessionContext* session_context);
  private:
  const ::bbf::sss::SessionContext& _internal_session_context() const;
  ::bbf::sss::SessionContext* _internal_mutable_session_context();
  public:
  void unsafe_arena_set_allocated_session_context(
      ::bbf::sss::SessionContext* session_context);
  ::bbf::sss::SessionContext* unsafe_arena_release_session_context();

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.LookupResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::SessionContext* session_context_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class UpdateServiceGatewayReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.UpdateServiceGatewayReq) */ {
 public:
  inline UpdateServiceGatewayReq() : UpdateServiceGatewayReq(nullptr) {}
  ~UpdateServiceGatewayReq() override;
  explicit constexpr UpdateServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateServiceGatewayReq(const UpdateServiceGatewayReq& from);
  UpdateServiceGatewayReq(UpdateServiceGatewayReq&& from) noexcept
    : UpdateServiceGatewayReq() {
    *this = ::std::move(from);
  }

  inline UpdateServiceGatewayReq& operator=(const UpdateServiceGatewayReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateServiceGatewayReq& operator=(UpdateServiceGatewayReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateServiceGatewayReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateServiceGatewayReq* internal_default_instance() {
    return reinterpret_cast<const UpdateServiceGatewayReq*>(
               &_UpdateServiceGatewayReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UpdateServiceGatewayReq& a, UpdateServiceGatewayReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateServiceGatewayReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateServiceGatewayReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateServiceGatewayReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateServiceGatewayReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateServiceGatewayReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateServiceGatewayReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateServiceGatewayReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.UpdateServiceGatewayReq";
  }
  protected:
  explicit UpdateServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceGatewayFieldNumber = 1,
  };
  // .bbf.sss.ServiceGateway service_gateway = 1;
  bool has_service_gateway() const;
  private:
  bool _internal_has_service_gateway() const;
  public:
  void clear_service_gateway();
  const ::bbf::sss::ServiceGateway& service_gateway() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGateway* release_service_gateway();
  ::bbf::sss::ServiceGateway* mutable_service_gateway();
  void set_allocated_service_gateway(::bbf::sss::ServiceGateway* service_gateway);
  private:
  const ::bbf::sss::ServiceGateway& _internal_service_gateway() const;
  ::bbf::sss::ServiceGateway* _internal_mutable_service_gateway();
  public:
  void unsafe_arena_set_allocated_service_gateway(
      ::bbf::sss::ServiceGateway* service_gateway);
  ::bbf::sss::ServiceGateway* unsafe_arena_release_service_gateway();

  // @@protoc_insertion_point(class_scope:bbf.sss.UpdateServiceGatewayReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ServiceGateway* service_gateway_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class DeleteServiceGatewayReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.DeleteServiceGatewayReq) */ {
 public:
  inline DeleteServiceGatewayReq() : DeleteServiceGatewayReq(nullptr) {}
  ~DeleteServiceGatewayReq() override;
  explicit constexpr DeleteServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteServiceGatewayReq(const DeleteServiceGatewayReq& from);
  DeleteServiceGatewayReq(DeleteServiceGatewayReq&& from) noexcept
    : DeleteServiceGatewayReq() {
    *this = ::std::move(from);
  }

  inline DeleteServiceGatewayReq& operator=(const DeleteServiceGatewayReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteServiceGatewayReq& operator=(DeleteServiceGatewayReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteServiceGatewayReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteServiceGatewayReq* internal_default_instance() {
    return reinterpret_cast<const DeleteServiceGatewayReq*>(
               &_DeleteServiceGatewayReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DeleteServiceGatewayReq& a, DeleteServiceGatewayReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteServiceGatewayReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteServiceGatewayReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteServiceGatewayReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteServiceGatewayReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteServiceGatewayReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteServiceGatewayReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteServiceGatewayReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.DeleteServiceGatewayReq";
  }
  protected:
  explicit DeleteServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.DeleteServiceGatewayReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class GetServiceGatewayReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.GetServiceGatewayReq) */ {
 public:
  inline GetServiceGatewayReq() : GetServiceGatewayReq(nullptr) {}
  ~GetServiceGatewayReq() override;
  explicit constexpr GetServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceGatewayReq(const GetServiceGatewayReq& from);
  GetServiceGatewayReq(GetServiceGatewayReq&& from) noexcept
    : GetServiceGatewayReq() {
    *this = ::std::move(from);
  }

  inline GetServiceGatewayReq& operator=(const GetServiceGatewayReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceGatewayReq& operator=(GetServiceGatewayReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceGatewayReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceGatewayReq* internal_default_instance() {
    return reinterpret_cast<const GetServiceGatewayReq*>(
               &_GetServiceGatewayReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetServiceGatewayReq& a, GetServiceGatewayReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceGatewayReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceGatewayReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceGatewayReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceGatewayReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceGatewayReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetServiceGatewayReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceGatewayReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.GetServiceGatewayReq";
  }
  protected:
  explicit GetServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.GetServiceGatewayReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ServiceGatewayResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ServiceGatewayResp) */ {
 public:
  inline ServiceGatewayResp() : ServiceGatewayResp(nullptr) {}
  ~ServiceGatewayResp() override;
  explicit constexpr ServiceGatewayResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceGatewayResp(const ServiceGatewayResp& from);
  ServiceGatewayResp(ServiceGatewayResp&& from) noexcept
    : ServiceGatewayResp() {
    *this = ::std::move(from);
  }

  inline ServiceGatewayResp& operator=(const ServiceGatewayResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceGatewayResp& operator=(ServiceGatewayResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceGatewayResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceGatewayResp* internal_default_instance() {
    return reinterpret_cast<const ServiceGatewayResp*>(
               &_ServiceGatewayResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ServiceGatewayResp& a, ServiceGatewayResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceGatewayResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceGatewayResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceGatewayResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceGatewayResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceGatewayResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceGatewayResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceGatewayResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ServiceGatewayResp";
  }
  protected:
  explicit ServiceGatewayResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceGatewayFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .bbf.sss.ServiceGateway service_gateway = 2;
  bool has_service_gateway() const;
  private:
  bool _internal_has_service_gateway() const;
  public:
  void clear_service_gateway();
  const ::bbf::sss::ServiceGateway& service_gateway() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGateway* release_service_gateway();
  ::bbf::sss::ServiceGateway* mutable_service_gateway();
  void set_allocated_service_gateway(::bbf::sss::ServiceGateway* service_gateway);
  private:
  const ::bbf::sss::ServiceGateway& _internal_service_gateway() const;
  ::bbf::sss::ServiceGateway* _internal_mutable_service_gateway();
  public:
  void unsafe_arena_set_allocated_service_gateway(
      ::bbf::sss::ServiceGateway* service_gateway);
  ::bbf::sss::ServiceGateway* unsafe_arena_release_service_gateway();

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ServiceGatewayResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ServiceGateway* service_gateway_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListServiceGatewayReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListServiceGatewayReq) */ {
 public:
  inline ListServiceGatewayReq() : ListServiceGatewayReq(nullptr) {}
  ~ListServiceGatewayReq() override;
  explicit constexpr ListServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceGatewayReq(const ListServiceGatewayReq& from);
  ListServiceGatewayReq(ListServiceGatewayReq&& from) noexcept
    : ListServiceGatewayReq() {
    *this = ::std::move(from);
  }

  inline ListServiceGatewayReq& operator=(const ListServiceGatewayReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceGatewayReq& operator=(ListServiceGatewayReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceGatewayReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceGatewayReq* internal_default_instance() {
    return reinterpret_cast<const ListServiceGatewayReq*>(
               &_ListServiceGatewayReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ListServiceGatewayReq& a, ListServiceGatewayReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceGatewayReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceGatewayReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceGatewayReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceGatewayReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceGatewayReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListServiceGatewayReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceGatewayReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListServiceGatewayReq";
  }
  protected:
  explicit ListServiceGatewayReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .bbf.sss.ListFilter filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::bbf::sss::ListFilter& filter() const;
  PROTOBUF_NODISCARD ::bbf::sss::ListFilter* release_filter();
  ::bbf::sss::ListFilter* mutable_filter();
  void set_allocated_filter(::bbf::sss::ListFilter* filter);
  private:
  const ::bbf::sss::ListFilter& _internal_filter() const;
  ::bbf::sss::ListFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::bbf::sss::ListFilter* filter);
  ::bbf::sss::ListFilter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:bbf.sss.ListServiceGatewayReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ListFilter* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListServiceGatewayResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListServiceGatewayResp) */ {
 public:
  inline ListServiceGatewayResp() : ListServiceGatewayResp(nullptr) {}
  ~ListServiceGatewayResp() override;
  explicit constexpr ListServiceGatewayResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceGatewayResp(const ListServiceGatewayResp& from);
  ListServiceGatewayResp(ListServiceGatewayResp&& from) noexcept
    : ListServiceGatewayResp() {
    *this = ::std::move(from);
  }

  inline ListServiceGatewayResp& operator=(const ListServiceGatewayResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceGatewayResp& operator=(ListServiceGatewayResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceGatewayResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceGatewayResp* internal_default_instance() {
    return reinterpret_cast<const ListServiceGatewayResp*>(
               &_ListServiceGatewayResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ListServiceGatewayResp& a, ListServiceGatewayResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceGatewayResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceGatewayResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceGatewayResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceGatewayResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceGatewayResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListServiceGatewayResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceGatewayResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListServiceGatewayResp";
  }
  protected:
  explicit ListServiceGatewayResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceGatewayFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .bbf.sss.ServiceGateway service_gateway = 2;
  int service_gateway_size() const;
  private:
  int _internal_service_gateway_size() const;
  public:
  void clear_service_gateway();
  ::bbf::sss::ServiceGateway* mutable_service_gateway(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGateway >*
      mutable_service_gateway();
  private:
  const ::bbf::sss::ServiceGateway& _internal_service_gateway(int index) const;
  ::bbf::sss::ServiceGateway* _internal_add_service_gateway();
  public:
  const ::bbf::sss::ServiceGateway& service_gateway(int index) const;
  ::bbf::sss::ServiceGateway* add_service_gateway();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGateway >&
      service_gateway() const;

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ListServiceGatewayResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGateway > service_gateway_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class UpdateShardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.UpdateShardReq) */ {
 public:
  inline UpdateShardReq() : UpdateShardReq(nullptr) {}
  ~UpdateShardReq() override;
  explicit constexpr UpdateShardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateShardReq(const UpdateShardReq& from);
  UpdateShardReq(UpdateShardReq&& from) noexcept
    : UpdateShardReq() {
    *this = ::std::move(from);
  }

  inline UpdateShardReq& operator=(const UpdateShardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateShardReq& operator=(UpdateShardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateShardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateShardReq* internal_default_instance() {
    return reinterpret_cast<const UpdateShardReq*>(
               &_UpdateShardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateShardReq& a, UpdateShardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateShardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateShardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateShardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateShardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateShardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateShardReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateShardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.UpdateShardReq";
  }
  protected:
  explicit UpdateShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardFieldNumber = 1,
  };
  // .bbf.sss.Shard shard = 1;
  bool has_shard() const;
  private:
  bool _internal_has_shard() const;
  public:
  void clear_shard();
  const ::bbf::sss::Shard& shard() const;
  PROTOBUF_NODISCARD ::bbf::sss::Shard* release_shard();
  ::bbf::sss::Shard* mutable_shard();
  void set_allocated_shard(::bbf::sss::Shard* shard);
  private:
  const ::bbf::sss::Shard& _internal_shard() const;
  ::bbf::sss::Shard* _internal_mutable_shard();
  public:
  void unsafe_arena_set_allocated_shard(
      ::bbf::sss::Shard* shard);
  ::bbf::sss::Shard* unsafe_arena_release_shard();

  // @@protoc_insertion_point(class_scope:bbf.sss.UpdateShardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::Shard* shard_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class DeleteShardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.DeleteShardReq) */ {
 public:
  inline DeleteShardReq() : DeleteShardReq(nullptr) {}
  ~DeleteShardReq() override;
  explicit constexpr DeleteShardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteShardReq(const DeleteShardReq& from);
  DeleteShardReq(DeleteShardReq&& from) noexcept
    : DeleteShardReq() {
    *this = ::std::move(from);
  }

  inline DeleteShardReq& operator=(const DeleteShardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteShardReq& operator=(DeleteShardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteShardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteShardReq* internal_default_instance() {
    return reinterpret_cast<const DeleteShardReq*>(
               &_DeleteShardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteShardReq& a, DeleteShardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteShardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteShardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteShardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteShardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteShardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteShardReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteShardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.DeleteShardReq";
  }
  protected:
  explicit DeleteShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.DeleteShardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class GetShardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.GetShardReq) */ {
 public:
  inline GetShardReq() : GetShardReq(nullptr) {}
  ~GetShardReq() override;
  explicit constexpr GetShardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetShardReq(const GetShardReq& from);
  GetShardReq(GetShardReq&& from) noexcept
    : GetShardReq() {
    *this = ::std::move(from);
  }

  inline GetShardReq& operator=(const GetShardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetShardReq& operator=(GetShardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetShardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetShardReq* internal_default_instance() {
    return reinterpret_cast<const GetShardReq*>(
               &_GetShardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetShardReq& a, GetShardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetShardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetShardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetShardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetShardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetShardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetShardReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetShardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.GetShardReq";
  }
  protected:
  explicit GetShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.GetShardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ShardResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ShardResp) */ {
 public:
  inline ShardResp() : ShardResp(nullptr) {}
  ~ShardResp() override;
  explicit constexpr ShardResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardResp(const ShardResp& from);
  ShardResp(ShardResp&& from) noexcept
    : ShardResp() {
    *this = ::std::move(from);
  }

  inline ShardResp& operator=(const ShardResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardResp& operator=(ShardResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardResp* internal_default_instance() {
    return reinterpret_cast<const ShardResp*>(
               &_ShardResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ShardResp& a, ShardResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ShardResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ShardResp";
  }
  protected:
  explicit ShardResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .bbf.sss.Shard shard = 2;
  bool has_shard() const;
  private:
  bool _internal_has_shard() const;
  public:
  void clear_shard();
  const ::bbf::sss::Shard& shard() const;
  PROTOBUF_NODISCARD ::bbf::sss::Shard* release_shard();
  ::bbf::sss::Shard* mutable_shard();
  void set_allocated_shard(::bbf::sss::Shard* shard);
  private:
  const ::bbf::sss::Shard& _internal_shard() const;
  ::bbf::sss::Shard* _internal_mutable_shard();
  public:
  void unsafe_arena_set_allocated_shard(
      ::bbf::sss::Shard* shard);
  ::bbf::sss::Shard* unsafe_arena_release_shard();

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ShardResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::Shard* shard_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListShardReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListShardReq) */ {
 public:
  inline ListShardReq() : ListShardReq(nullptr) {}
  ~ListShardReq() override;
  explicit constexpr ListShardReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListShardReq(const ListShardReq& from);
  ListShardReq(ListShardReq&& from) noexcept
    : ListShardReq() {
    *this = ::std::move(from);
  }

  inline ListShardReq& operator=(const ListShardReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListShardReq& operator=(ListShardReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListShardReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListShardReq* internal_default_instance() {
    return reinterpret_cast<const ListShardReq*>(
               &_ListShardReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ListShardReq& a, ListShardReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListShardReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListShardReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListShardReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListShardReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListShardReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListShardReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListShardReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListShardReq";
  }
  protected:
  explicit ListShardReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .bbf.sss.ListFilter filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::bbf::sss::ListFilter& filter() const;
  PROTOBUF_NODISCARD ::bbf::sss::ListFilter* release_filter();
  ::bbf::sss::ListFilter* mutable_filter();
  void set_allocated_filter(::bbf::sss::ListFilter* filter);
  private:
  const ::bbf::sss::ListFilter& _internal_filter() const;
  ::bbf::sss::ListFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::bbf::sss::ListFilter* filter);
  ::bbf::sss::ListFilter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:bbf.sss.ListShardReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ListFilter* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListShardResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListShardResp) */ {
 public:
  inline ListShardResp() : ListShardResp(nullptr) {}
  ~ListShardResp() override;
  explicit constexpr ListShardResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListShardResp(const ListShardResp& from);
  ListShardResp(ListShardResp&& from) noexcept
    : ListShardResp() {
    *this = ::std::move(from);
  }

  inline ListShardResp& operator=(const ListShardResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListShardResp& operator=(ListShardResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListShardResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListShardResp* internal_default_instance() {
    return reinterpret_cast<const ListShardResp*>(
               &_ListShardResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListShardResp& a, ListShardResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListShardResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListShardResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListShardResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListShardResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListShardResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListShardResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListShardResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListShardResp";
  }
  protected:
  explicit ListShardResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .bbf.sss.Shard shard = 2;
  int shard_size() const;
  private:
  int _internal_shard_size() const;
  public:
  void clear_shard();
  ::bbf::sss::Shard* mutable_shard(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::Shard >*
      mutable_shard();
  private:
  const ::bbf::sss::Shard& _internal_shard(int index) const;
  ::bbf::sss::Shard* _internal_add_shard();
  public:
  const ::bbf::sss::Shard& shard(int index) const;
  ::bbf::sss::Shard* add_shard();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::Shard >&
      shard() const;

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ListShardResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::Shard > shard_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class UpdateTrafficSteeringFunctionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.UpdateTrafficSteeringFunctionReq) */ {
 public:
  inline UpdateTrafficSteeringFunctionReq() : UpdateTrafficSteeringFunctionReq(nullptr) {}
  ~UpdateTrafficSteeringFunctionReq() override;
  explicit constexpr UpdateTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateTrafficSteeringFunctionReq(const UpdateTrafficSteeringFunctionReq& from);
  UpdateTrafficSteeringFunctionReq(UpdateTrafficSteeringFunctionReq&& from) noexcept
    : UpdateTrafficSteeringFunctionReq() {
    *this = ::std::move(from);
  }

  inline UpdateTrafficSteeringFunctionReq& operator=(const UpdateTrafficSteeringFunctionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateTrafficSteeringFunctionReq& operator=(UpdateTrafficSteeringFunctionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateTrafficSteeringFunctionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateTrafficSteeringFunctionReq* internal_default_instance() {
    return reinterpret_cast<const UpdateTrafficSteeringFunctionReq*>(
               &_UpdateTrafficSteeringFunctionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateTrafficSteeringFunctionReq& a, UpdateTrafficSteeringFunctionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateTrafficSteeringFunctionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateTrafficSteeringFunctionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateTrafficSteeringFunctionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateTrafficSteeringFunctionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateTrafficSteeringFunctionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateTrafficSteeringFunctionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateTrafficSteeringFunctionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.UpdateTrafficSteeringFunctionReq";
  }
  protected:
  explicit UpdateTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficSteeringFunctionFieldNumber = 1,
  };
  // .bbf.sss.TrafficSteeringFunction traffic_steering_function = 1;
  bool has_traffic_steering_function() const;
  private:
  bool _internal_has_traffic_steering_function() const;
  public:
  void clear_traffic_steering_function();
  const ::bbf::sss::TrafficSteeringFunction& traffic_steering_function() const;
  PROTOBUF_NODISCARD ::bbf::sss::TrafficSteeringFunction* release_traffic_steering_function();
  ::bbf::sss::TrafficSteeringFunction* mutable_traffic_steering_function();
  void set_allocated_traffic_steering_function(::bbf::sss::TrafficSteeringFunction* traffic_steering_function);
  private:
  const ::bbf::sss::TrafficSteeringFunction& _internal_traffic_steering_function() const;
  ::bbf::sss::TrafficSteeringFunction* _internal_mutable_traffic_steering_function();
  public:
  void unsafe_arena_set_allocated_traffic_steering_function(
      ::bbf::sss::TrafficSteeringFunction* traffic_steering_function);
  ::bbf::sss::TrafficSteeringFunction* unsafe_arena_release_traffic_steering_function();

  // @@protoc_insertion_point(class_scope:bbf.sss.UpdateTrafficSteeringFunctionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::TrafficSteeringFunction* traffic_steering_function_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class DeleteTrafficSteeringFunctionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.DeleteTrafficSteeringFunctionReq) */ {
 public:
  inline DeleteTrafficSteeringFunctionReq() : DeleteTrafficSteeringFunctionReq(nullptr) {}
  ~DeleteTrafficSteeringFunctionReq() override;
  explicit constexpr DeleteTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteTrafficSteeringFunctionReq(const DeleteTrafficSteeringFunctionReq& from);
  DeleteTrafficSteeringFunctionReq(DeleteTrafficSteeringFunctionReq&& from) noexcept
    : DeleteTrafficSteeringFunctionReq() {
    *this = ::std::move(from);
  }

  inline DeleteTrafficSteeringFunctionReq& operator=(const DeleteTrafficSteeringFunctionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteTrafficSteeringFunctionReq& operator=(DeleteTrafficSteeringFunctionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteTrafficSteeringFunctionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteTrafficSteeringFunctionReq* internal_default_instance() {
    return reinterpret_cast<const DeleteTrafficSteeringFunctionReq*>(
               &_DeleteTrafficSteeringFunctionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DeleteTrafficSteeringFunctionReq& a, DeleteTrafficSteeringFunctionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteTrafficSteeringFunctionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteTrafficSteeringFunctionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteTrafficSteeringFunctionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteTrafficSteeringFunctionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteTrafficSteeringFunctionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteTrafficSteeringFunctionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTrafficSteeringFunctionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.DeleteTrafficSteeringFunctionReq";
  }
  protected:
  explicit DeleteTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.DeleteTrafficSteeringFunctionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class GetTrafficSteeringFunctionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.GetTrafficSteeringFunctionReq) */ {
 public:
  inline GetTrafficSteeringFunctionReq() : GetTrafficSteeringFunctionReq(nullptr) {}
  ~GetTrafficSteeringFunctionReq() override;
  explicit constexpr GetTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTrafficSteeringFunctionReq(const GetTrafficSteeringFunctionReq& from);
  GetTrafficSteeringFunctionReq(GetTrafficSteeringFunctionReq&& from) noexcept
    : GetTrafficSteeringFunctionReq() {
    *this = ::std::move(from);
  }

  inline GetTrafficSteeringFunctionReq& operator=(const GetTrafficSteeringFunctionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTrafficSteeringFunctionReq& operator=(GetTrafficSteeringFunctionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTrafficSteeringFunctionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTrafficSteeringFunctionReq* internal_default_instance() {
    return reinterpret_cast<const GetTrafficSteeringFunctionReq*>(
               &_GetTrafficSteeringFunctionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GetTrafficSteeringFunctionReq& a, GetTrafficSteeringFunctionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTrafficSteeringFunctionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTrafficSteeringFunctionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTrafficSteeringFunctionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTrafficSteeringFunctionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTrafficSteeringFunctionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTrafficSteeringFunctionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTrafficSteeringFunctionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.GetTrafficSteeringFunctionReq";
  }
  protected:
  explicit GetTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.GetTrafficSteeringFunctionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class TrafficSteeringFunctionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.TrafficSteeringFunctionResp) */ {
 public:
  inline TrafficSteeringFunctionResp() : TrafficSteeringFunctionResp(nullptr) {}
  ~TrafficSteeringFunctionResp() override;
  explicit constexpr TrafficSteeringFunctionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficSteeringFunctionResp(const TrafficSteeringFunctionResp& from);
  TrafficSteeringFunctionResp(TrafficSteeringFunctionResp&& from) noexcept
    : TrafficSteeringFunctionResp() {
    *this = ::std::move(from);
  }

  inline TrafficSteeringFunctionResp& operator=(const TrafficSteeringFunctionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSteeringFunctionResp& operator=(TrafficSteeringFunctionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSteeringFunctionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSteeringFunctionResp* internal_default_instance() {
    return reinterpret_cast<const TrafficSteeringFunctionResp*>(
               &_TrafficSteeringFunctionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TrafficSteeringFunctionResp& a, TrafficSteeringFunctionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSteeringFunctionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSteeringFunctionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSteeringFunctionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSteeringFunctionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficSteeringFunctionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficSteeringFunctionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSteeringFunctionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.TrafficSteeringFunctionResp";
  }
  protected:
  explicit TrafficSteeringFunctionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficSteeringFunctionFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .bbf.sss.TrafficSteeringFunction traffic_steering_function = 2;
  bool has_traffic_steering_function() const;
  private:
  bool _internal_has_traffic_steering_function() const;
  public:
  void clear_traffic_steering_function();
  const ::bbf::sss::TrafficSteeringFunction& traffic_steering_function() const;
  PROTOBUF_NODISCARD ::bbf::sss::TrafficSteeringFunction* release_traffic_steering_function();
  ::bbf::sss::TrafficSteeringFunction* mutable_traffic_steering_function();
  void set_allocated_traffic_steering_function(::bbf::sss::TrafficSteeringFunction* traffic_steering_function);
  private:
  const ::bbf::sss::TrafficSteeringFunction& _internal_traffic_steering_function() const;
  ::bbf::sss::TrafficSteeringFunction* _internal_mutable_traffic_steering_function();
  public:
  void unsafe_arena_set_allocated_traffic_steering_function(
      ::bbf::sss::TrafficSteeringFunction* traffic_steering_function);
  ::bbf::sss::TrafficSteeringFunction* unsafe_arena_release_traffic_steering_function();

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.TrafficSteeringFunctionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::TrafficSteeringFunction* traffic_steering_function_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListTrafficSteeringFunctionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListTrafficSteeringFunctionReq) */ {
 public:
  inline ListTrafficSteeringFunctionReq() : ListTrafficSteeringFunctionReq(nullptr) {}
  ~ListTrafficSteeringFunctionReq() override;
  explicit constexpr ListTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTrafficSteeringFunctionReq(const ListTrafficSteeringFunctionReq& from);
  ListTrafficSteeringFunctionReq(ListTrafficSteeringFunctionReq&& from) noexcept
    : ListTrafficSteeringFunctionReq() {
    *this = ::std::move(from);
  }

  inline ListTrafficSteeringFunctionReq& operator=(const ListTrafficSteeringFunctionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTrafficSteeringFunctionReq& operator=(ListTrafficSteeringFunctionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTrafficSteeringFunctionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTrafficSteeringFunctionReq* internal_default_instance() {
    return reinterpret_cast<const ListTrafficSteeringFunctionReq*>(
               &_ListTrafficSteeringFunctionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ListTrafficSteeringFunctionReq& a, ListTrafficSteeringFunctionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTrafficSteeringFunctionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTrafficSteeringFunctionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTrafficSteeringFunctionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTrafficSteeringFunctionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTrafficSteeringFunctionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTrafficSteeringFunctionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTrafficSteeringFunctionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListTrafficSteeringFunctionReq";
  }
  protected:
  explicit ListTrafficSteeringFunctionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .bbf.sss.ListFilter filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::bbf::sss::ListFilter& filter() const;
  PROTOBUF_NODISCARD ::bbf::sss::ListFilter* release_filter();
  ::bbf::sss::ListFilter* mutable_filter();
  void set_allocated_filter(::bbf::sss::ListFilter* filter);
  private:
  const ::bbf::sss::ListFilter& _internal_filter() const;
  ::bbf::sss::ListFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::bbf::sss::ListFilter* filter);
  ::bbf::sss::ListFilter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:bbf.sss.ListTrafficSteeringFunctionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ListFilter* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListTrafficSteeringFunctionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListTrafficSteeringFunctionResp) */ {
 public:
  inline ListTrafficSteeringFunctionResp() : ListTrafficSteeringFunctionResp(nullptr) {}
  ~ListTrafficSteeringFunctionResp() override;
  explicit constexpr ListTrafficSteeringFunctionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListTrafficSteeringFunctionResp(const ListTrafficSteeringFunctionResp& from);
  ListTrafficSteeringFunctionResp(ListTrafficSteeringFunctionResp&& from) noexcept
    : ListTrafficSteeringFunctionResp() {
    *this = ::std::move(from);
  }

  inline ListTrafficSteeringFunctionResp& operator=(const ListTrafficSteeringFunctionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListTrafficSteeringFunctionResp& operator=(ListTrafficSteeringFunctionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListTrafficSteeringFunctionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListTrafficSteeringFunctionResp* internal_default_instance() {
    return reinterpret_cast<const ListTrafficSteeringFunctionResp*>(
               &_ListTrafficSteeringFunctionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ListTrafficSteeringFunctionResp& a, ListTrafficSteeringFunctionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListTrafficSteeringFunctionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListTrafficSteeringFunctionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListTrafficSteeringFunctionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListTrafficSteeringFunctionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListTrafficSteeringFunctionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListTrafficSteeringFunctionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListTrafficSteeringFunctionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListTrafficSteeringFunctionResp";
  }
  protected:
  explicit ListTrafficSteeringFunctionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficSteeringFunctionFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .bbf.sss.TrafficSteeringFunction traffic_steering_function = 2;
  int traffic_steering_function_size() const;
  private:
  int _internal_traffic_steering_function_size() const;
  public:
  void clear_traffic_steering_function();
  ::bbf::sss::TrafficSteeringFunction* mutable_traffic_steering_function(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::TrafficSteeringFunction >*
      mutable_traffic_steering_function();
  private:
  const ::bbf::sss::TrafficSteeringFunction& _internal_traffic_steering_function(int index) const;
  ::bbf::sss::TrafficSteeringFunction* _internal_add_traffic_steering_function();
  public:
  const ::bbf::sss::TrafficSteeringFunction& traffic_steering_function(int index) const;
  ::bbf::sss::TrafficSteeringFunction* add_traffic_steering_function();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::TrafficSteeringFunction >&
      traffic_steering_function() const;

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ListTrafficSteeringFunctionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::TrafficSteeringFunction > traffic_steering_function_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class UpdateServiceGatewayUserPlaneReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.UpdateServiceGatewayUserPlaneReq) */ {
 public:
  inline UpdateServiceGatewayUserPlaneReq() : UpdateServiceGatewayUserPlaneReq(nullptr) {}
  ~UpdateServiceGatewayUserPlaneReq() override;
  explicit constexpr UpdateServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateServiceGatewayUserPlaneReq(const UpdateServiceGatewayUserPlaneReq& from);
  UpdateServiceGatewayUserPlaneReq(UpdateServiceGatewayUserPlaneReq&& from) noexcept
    : UpdateServiceGatewayUserPlaneReq() {
    *this = ::std::move(from);
  }

  inline UpdateServiceGatewayUserPlaneReq& operator=(const UpdateServiceGatewayUserPlaneReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateServiceGatewayUserPlaneReq& operator=(UpdateServiceGatewayUserPlaneReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateServiceGatewayUserPlaneReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateServiceGatewayUserPlaneReq* internal_default_instance() {
    return reinterpret_cast<const UpdateServiceGatewayUserPlaneReq*>(
               &_UpdateServiceGatewayUserPlaneReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UpdateServiceGatewayUserPlaneReq& a, UpdateServiceGatewayUserPlaneReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateServiceGatewayUserPlaneReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateServiceGatewayUserPlaneReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateServiceGatewayUserPlaneReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateServiceGatewayUserPlaneReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateServiceGatewayUserPlaneReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.UpdateServiceGatewayUserPlaneReq";
  }
  protected:
  explicit UpdateServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceGatewayUserPlaneFieldNumber = 1,
  };
  // .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 1;
  bool has_service_gateway_user_plane() const;
  private:
  bool _internal_has_service_gateway_user_plane() const;
  public:
  void clear_service_gateway_user_plane();
  const ::bbf::sss::ServiceGatewayUserPlane& service_gateway_user_plane() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGatewayUserPlane* release_service_gateway_user_plane();
  ::bbf::sss::ServiceGatewayUserPlane* mutable_service_gateway_user_plane();
  void set_allocated_service_gateway_user_plane(::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane);
  private:
  const ::bbf::sss::ServiceGatewayUserPlane& _internal_service_gateway_user_plane() const;
  ::bbf::sss::ServiceGatewayUserPlane* _internal_mutable_service_gateway_user_plane();
  public:
  void unsafe_arena_set_allocated_service_gateway_user_plane(
      ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane);
  ::bbf::sss::ServiceGatewayUserPlane* unsafe_arena_release_service_gateway_user_plane();

  // @@protoc_insertion_point(class_scope:bbf.sss.UpdateServiceGatewayUserPlaneReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class DeleteServiceGatewayUserPlaneReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.DeleteServiceGatewayUserPlaneReq) */ {
 public:
  inline DeleteServiceGatewayUserPlaneReq() : DeleteServiceGatewayUserPlaneReq(nullptr) {}
  ~DeleteServiceGatewayUserPlaneReq() override;
  explicit constexpr DeleteServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteServiceGatewayUserPlaneReq(const DeleteServiceGatewayUserPlaneReq& from);
  DeleteServiceGatewayUserPlaneReq(DeleteServiceGatewayUserPlaneReq&& from) noexcept
    : DeleteServiceGatewayUserPlaneReq() {
    *this = ::std::move(from);
  }

  inline DeleteServiceGatewayUserPlaneReq& operator=(const DeleteServiceGatewayUserPlaneReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteServiceGatewayUserPlaneReq& operator=(DeleteServiceGatewayUserPlaneReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteServiceGatewayUserPlaneReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteServiceGatewayUserPlaneReq* internal_default_instance() {
    return reinterpret_cast<const DeleteServiceGatewayUserPlaneReq*>(
               &_DeleteServiceGatewayUserPlaneReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(DeleteServiceGatewayUserPlaneReq& a, DeleteServiceGatewayUserPlaneReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteServiceGatewayUserPlaneReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteServiceGatewayUserPlaneReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteServiceGatewayUserPlaneReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteServiceGatewayUserPlaneReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteServiceGatewayUserPlaneReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.DeleteServiceGatewayUserPlaneReq";
  }
  protected:
  explicit DeleteServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.DeleteServiceGatewayUserPlaneReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class GetServiceGatewayUserPlaneReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.GetServiceGatewayUserPlaneReq) */ {
 public:
  inline GetServiceGatewayUserPlaneReq() : GetServiceGatewayUserPlaneReq(nullptr) {}
  ~GetServiceGatewayUserPlaneReq() override;
  explicit constexpr GetServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetServiceGatewayUserPlaneReq(const GetServiceGatewayUserPlaneReq& from);
  GetServiceGatewayUserPlaneReq(GetServiceGatewayUserPlaneReq&& from) noexcept
    : GetServiceGatewayUserPlaneReq() {
    *this = ::std::move(from);
  }

  inline GetServiceGatewayUserPlaneReq& operator=(const GetServiceGatewayUserPlaneReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetServiceGatewayUserPlaneReq& operator=(GetServiceGatewayUserPlaneReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetServiceGatewayUserPlaneReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetServiceGatewayUserPlaneReq* internal_default_instance() {
    return reinterpret_cast<const GetServiceGatewayUserPlaneReq*>(
               &_GetServiceGatewayUserPlaneReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetServiceGatewayUserPlaneReq& a, GetServiceGatewayUserPlaneReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetServiceGatewayUserPlaneReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetServiceGatewayUserPlaneReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetServiceGatewayUserPlaneReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetServiceGatewayUserPlaneReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetServiceGatewayUserPlaneReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.GetServiceGatewayUserPlaneReq";
  }
  protected:
  explicit GetServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.GetServiceGatewayUserPlaneReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ServiceGatewayUserPlaneResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ServiceGatewayUserPlaneResp) */ {
 public:
  inline ServiceGatewayUserPlaneResp() : ServiceGatewayUserPlaneResp(nullptr) {}
  ~ServiceGatewayUserPlaneResp() override;
  explicit constexpr ServiceGatewayUserPlaneResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceGatewayUserPlaneResp(const ServiceGatewayUserPlaneResp& from);
  ServiceGatewayUserPlaneResp(ServiceGatewayUserPlaneResp&& from) noexcept
    : ServiceGatewayUserPlaneResp() {
    *this = ::std::move(from);
  }

  inline ServiceGatewayUserPlaneResp& operator=(const ServiceGatewayUserPlaneResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceGatewayUserPlaneResp& operator=(ServiceGatewayUserPlaneResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceGatewayUserPlaneResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceGatewayUserPlaneResp* internal_default_instance() {
    return reinterpret_cast<const ServiceGatewayUserPlaneResp*>(
               &_ServiceGatewayUserPlaneResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ServiceGatewayUserPlaneResp& a, ServiceGatewayUserPlaneResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceGatewayUserPlaneResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceGatewayUserPlaneResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceGatewayUserPlaneResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceGatewayUserPlaneResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceGatewayUserPlaneResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceGatewayUserPlaneResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceGatewayUserPlaneResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ServiceGatewayUserPlaneResp";
  }
  protected:
  explicit ServiceGatewayUserPlaneResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceGatewayUserPlaneFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 2;
  bool has_service_gateway_user_plane() const;
  private:
  bool _internal_has_service_gateway_user_plane() const;
  public:
  void clear_service_gateway_user_plane();
  const ::bbf::sss::ServiceGatewayUserPlane& service_gateway_user_plane() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGatewayUserPlane* release_service_gateway_user_plane();
  ::bbf::sss::ServiceGatewayUserPlane* mutable_service_gateway_user_plane();
  void set_allocated_service_gateway_user_plane(::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane);
  private:
  const ::bbf::sss::ServiceGatewayUserPlane& _internal_service_gateway_user_plane() const;
  ::bbf::sss::ServiceGatewayUserPlane* _internal_mutable_service_gateway_user_plane();
  public:
  void unsafe_arena_set_allocated_service_gateway_user_plane(
      ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane);
  ::bbf::sss::ServiceGatewayUserPlane* unsafe_arena_release_service_gateway_user_plane();

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ServiceGatewayUserPlaneResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListServiceGatewayUserPlaneReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListServiceGatewayUserPlaneReq) */ {
 public:
  inline ListServiceGatewayUserPlaneReq() : ListServiceGatewayUserPlaneReq(nullptr) {}
  ~ListServiceGatewayUserPlaneReq() override;
  explicit constexpr ListServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceGatewayUserPlaneReq(const ListServiceGatewayUserPlaneReq& from);
  ListServiceGatewayUserPlaneReq(ListServiceGatewayUserPlaneReq&& from) noexcept
    : ListServiceGatewayUserPlaneReq() {
    *this = ::std::move(from);
  }

  inline ListServiceGatewayUserPlaneReq& operator=(const ListServiceGatewayUserPlaneReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceGatewayUserPlaneReq& operator=(ListServiceGatewayUserPlaneReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceGatewayUserPlaneReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceGatewayUserPlaneReq* internal_default_instance() {
    return reinterpret_cast<const ListServiceGatewayUserPlaneReq*>(
               &_ListServiceGatewayUserPlaneReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ListServiceGatewayUserPlaneReq& a, ListServiceGatewayUserPlaneReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceGatewayUserPlaneReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceGatewayUserPlaneReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceGatewayUserPlaneReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceGatewayUserPlaneReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListServiceGatewayUserPlaneReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceGatewayUserPlaneReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListServiceGatewayUserPlaneReq";
  }
  protected:
  explicit ListServiceGatewayUserPlaneReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 2,
  };
  // .bbf.sss.ListFilter filter = 2;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::bbf::sss::ListFilter& filter() const;
  PROTOBUF_NODISCARD ::bbf::sss::ListFilter* release_filter();
  ::bbf::sss::ListFilter* mutable_filter();
  void set_allocated_filter(::bbf::sss::ListFilter* filter);
  private:
  const ::bbf::sss::ListFilter& _internal_filter() const;
  ::bbf::sss::ListFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::bbf::sss::ListFilter* filter);
  ::bbf::sss::ListFilter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:bbf.sss.ListServiceGatewayUserPlaneReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ListFilter* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListServiceGatewayUserPlaneResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListServiceGatewayUserPlaneResp) */ {
 public:
  inline ListServiceGatewayUserPlaneResp() : ListServiceGatewayUserPlaneResp(nullptr) {}
  ~ListServiceGatewayUserPlaneResp() override;
  explicit constexpr ListServiceGatewayUserPlaneResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListServiceGatewayUserPlaneResp(const ListServiceGatewayUserPlaneResp& from);
  ListServiceGatewayUserPlaneResp(ListServiceGatewayUserPlaneResp&& from) noexcept
    : ListServiceGatewayUserPlaneResp() {
    *this = ::std::move(from);
  }

  inline ListServiceGatewayUserPlaneResp& operator=(const ListServiceGatewayUserPlaneResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListServiceGatewayUserPlaneResp& operator=(ListServiceGatewayUserPlaneResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListServiceGatewayUserPlaneResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListServiceGatewayUserPlaneResp* internal_default_instance() {
    return reinterpret_cast<const ListServiceGatewayUserPlaneResp*>(
               &_ListServiceGatewayUserPlaneResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ListServiceGatewayUserPlaneResp& a, ListServiceGatewayUserPlaneResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListServiceGatewayUserPlaneResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListServiceGatewayUserPlaneResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListServiceGatewayUserPlaneResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListServiceGatewayUserPlaneResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListServiceGatewayUserPlaneResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListServiceGatewayUserPlaneResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListServiceGatewayUserPlaneResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListServiceGatewayUserPlaneResp";
  }
  protected:
  explicit ListServiceGatewayUserPlaneResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceGatewayUserPlaneFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 2;
  int service_gateway_user_plane_size() const;
  private:
  int _internal_service_gateway_user_plane_size() const;
  public:
  void clear_service_gateway_user_plane();
  ::bbf::sss::ServiceGatewayUserPlane* mutable_service_gateway_user_plane(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGatewayUserPlane >*
      mutable_service_gateway_user_plane();
  private:
  const ::bbf::sss::ServiceGatewayUserPlane& _internal_service_gateway_user_plane(int index) const;
  ::bbf::sss::ServiceGatewayUserPlane* _internal_add_service_gateway_user_plane();
  public:
  const ::bbf::sss::ServiceGatewayUserPlane& service_gateway_user_plane(int index) const;
  ::bbf::sss::ServiceGatewayUserPlane* add_service_gateway_user_plane();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGatewayUserPlane >&
      service_gateway_user_plane() const;

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ListServiceGatewayUserPlaneResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGatewayUserPlane > service_gateway_user_plane_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class UpdateNetworkConnectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.UpdateNetworkConnectionReq) */ {
 public:
  inline UpdateNetworkConnectionReq() : UpdateNetworkConnectionReq(nullptr) {}
  ~UpdateNetworkConnectionReq() override;
  explicit constexpr UpdateNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateNetworkConnectionReq(const UpdateNetworkConnectionReq& from);
  UpdateNetworkConnectionReq(UpdateNetworkConnectionReq&& from) noexcept
    : UpdateNetworkConnectionReq() {
    *this = ::std::move(from);
  }

  inline UpdateNetworkConnectionReq& operator=(const UpdateNetworkConnectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateNetworkConnectionReq& operator=(UpdateNetworkConnectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateNetworkConnectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateNetworkConnectionReq* internal_default_instance() {
    return reinterpret_cast<const UpdateNetworkConnectionReq*>(
               &_UpdateNetworkConnectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UpdateNetworkConnectionReq& a, UpdateNetworkConnectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateNetworkConnectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateNetworkConnectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateNetworkConnectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateNetworkConnectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateNetworkConnectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateNetworkConnectionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateNetworkConnectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.UpdateNetworkConnectionReq";
  }
  protected:
  explicit UpdateNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkConnectionFieldNumber = 1,
  };
  // .bbf.sss.NetworkConnection network_connection = 1;
  bool has_network_connection() const;
  private:
  bool _internal_has_network_connection() const;
  public:
  void clear_network_connection();
  const ::bbf::sss::NetworkConnection& network_connection() const;
  PROTOBUF_NODISCARD ::bbf::sss::NetworkConnection* release_network_connection();
  ::bbf::sss::NetworkConnection* mutable_network_connection();
  void set_allocated_network_connection(::bbf::sss::NetworkConnection* network_connection);
  private:
  const ::bbf::sss::NetworkConnection& _internal_network_connection() const;
  ::bbf::sss::NetworkConnection* _internal_mutable_network_connection();
  public:
  void unsafe_arena_set_allocated_network_connection(
      ::bbf::sss::NetworkConnection* network_connection);
  ::bbf::sss::NetworkConnection* unsafe_arena_release_network_connection();

  // @@protoc_insertion_point(class_scope:bbf.sss.UpdateNetworkConnectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::NetworkConnection* network_connection_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class DeleteNetworkConnectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.DeleteNetworkConnectionReq) */ {
 public:
  inline DeleteNetworkConnectionReq() : DeleteNetworkConnectionReq(nullptr) {}
  ~DeleteNetworkConnectionReq() override;
  explicit constexpr DeleteNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteNetworkConnectionReq(const DeleteNetworkConnectionReq& from);
  DeleteNetworkConnectionReq(DeleteNetworkConnectionReq&& from) noexcept
    : DeleteNetworkConnectionReq() {
    *this = ::std::move(from);
  }

  inline DeleteNetworkConnectionReq& operator=(const DeleteNetworkConnectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNetworkConnectionReq& operator=(DeleteNetworkConnectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNetworkConnectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNetworkConnectionReq* internal_default_instance() {
    return reinterpret_cast<const DeleteNetworkConnectionReq*>(
               &_DeleteNetworkConnectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(DeleteNetworkConnectionReq& a, DeleteNetworkConnectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteNetworkConnectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNetworkConnectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNetworkConnectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteNetworkConnectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteNetworkConnectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteNetworkConnectionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteNetworkConnectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.DeleteNetworkConnectionReq";
  }
  protected:
  explicit DeleteNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.DeleteNetworkConnectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkConnectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.GetNetworkConnectionReq) */ {
 public:
  inline GetNetworkConnectionReq() : GetNetworkConnectionReq(nullptr) {}
  ~GetNetworkConnectionReq() override;
  explicit constexpr GetNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNetworkConnectionReq(const GetNetworkConnectionReq& from);
  GetNetworkConnectionReq(GetNetworkConnectionReq&& from) noexcept
    : GetNetworkConnectionReq() {
    *this = ::std::move(from);
  }

  inline GetNetworkConnectionReq& operator=(const GetNetworkConnectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkConnectionReq& operator=(GetNetworkConnectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNetworkConnectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNetworkConnectionReq* internal_default_instance() {
    return reinterpret_cast<const GetNetworkConnectionReq*>(
               &_GetNetworkConnectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GetNetworkConnectionReq& a, GetNetworkConnectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkConnectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkConnectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetNetworkConnectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetNetworkConnectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNetworkConnectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNetworkConnectionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkConnectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.GetNetworkConnectionReq";
  }
  protected:
  explicit GetNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.GetNetworkConnectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class NetworkConnectionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.NetworkConnectionResp) */ {
 public:
  inline NetworkConnectionResp() : NetworkConnectionResp(nullptr) {}
  ~NetworkConnectionResp() override;
  explicit constexpr NetworkConnectionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkConnectionResp(const NetworkConnectionResp& from);
  NetworkConnectionResp(NetworkConnectionResp&& from) noexcept
    : NetworkConnectionResp() {
    *this = ::std::move(from);
  }

  inline NetworkConnectionResp& operator=(const NetworkConnectionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConnectionResp& operator=(NetworkConnectionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConnectionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkConnectionResp* internal_default_instance() {
    return reinterpret_cast<const NetworkConnectionResp*>(
               &_NetworkConnectionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(NetworkConnectionResp& a, NetworkConnectionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConnectionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConnectionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConnectionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConnectionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkConnectionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetworkConnectionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConnectionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.NetworkConnectionResp";
  }
  protected:
  explicit NetworkConnectionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkConnectionFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .bbf.sss.NetworkConnection network_connection = 2;
  bool has_network_connection() const;
  private:
  bool _internal_has_network_connection() const;
  public:
  void clear_network_connection();
  const ::bbf::sss::NetworkConnection& network_connection() const;
  PROTOBUF_NODISCARD ::bbf::sss::NetworkConnection* release_network_connection();
  ::bbf::sss::NetworkConnection* mutable_network_connection();
  void set_allocated_network_connection(::bbf::sss::NetworkConnection* network_connection);
  private:
  const ::bbf::sss::NetworkConnection& _internal_network_connection() const;
  ::bbf::sss::NetworkConnection* _internal_mutable_network_connection();
  public:
  void unsafe_arena_set_allocated_network_connection(
      ::bbf::sss::NetworkConnection* network_connection);
  ::bbf::sss::NetworkConnection* unsafe_arena_release_network_connection();

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.NetworkConnectionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::NetworkConnection* network_connection_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListNetworkConnectionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListNetworkConnectionReq) */ {
 public:
  inline ListNetworkConnectionReq() : ListNetworkConnectionReq(nullptr) {}
  ~ListNetworkConnectionReq() override;
  explicit constexpr ListNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNetworkConnectionReq(const ListNetworkConnectionReq& from);
  ListNetworkConnectionReq(ListNetworkConnectionReq&& from) noexcept
    : ListNetworkConnectionReq() {
    *this = ::std::move(from);
  }

  inline ListNetworkConnectionReq& operator=(const ListNetworkConnectionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNetworkConnectionReq& operator=(ListNetworkConnectionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNetworkConnectionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNetworkConnectionReq* internal_default_instance() {
    return reinterpret_cast<const ListNetworkConnectionReq*>(
               &_ListNetworkConnectionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ListNetworkConnectionReq& a, ListNetworkConnectionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNetworkConnectionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNetworkConnectionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNetworkConnectionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNetworkConnectionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNetworkConnectionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNetworkConnectionReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNetworkConnectionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListNetworkConnectionReq";
  }
  protected:
  explicit ListNetworkConnectionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .bbf.sss.ListFilter filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::bbf::sss::ListFilter& filter() const;
  PROTOBUF_NODISCARD ::bbf::sss::ListFilter* release_filter();
  ::bbf::sss::ListFilter* mutable_filter();
  void set_allocated_filter(::bbf::sss::ListFilter* filter);
  private:
  const ::bbf::sss::ListFilter& _internal_filter() const;
  ::bbf::sss::ListFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::bbf::sss::ListFilter* filter);
  ::bbf::sss::ListFilter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:bbf.sss.ListNetworkConnectionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ListFilter* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListNetworkConnectionResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListNetworkConnectionResp) */ {
 public:
  inline ListNetworkConnectionResp() : ListNetworkConnectionResp(nullptr) {}
  ~ListNetworkConnectionResp() override;
  explicit constexpr ListNetworkConnectionResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListNetworkConnectionResp(const ListNetworkConnectionResp& from);
  ListNetworkConnectionResp(ListNetworkConnectionResp&& from) noexcept
    : ListNetworkConnectionResp() {
    *this = ::std::move(from);
  }

  inline ListNetworkConnectionResp& operator=(const ListNetworkConnectionResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListNetworkConnectionResp& operator=(ListNetworkConnectionResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListNetworkConnectionResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListNetworkConnectionResp* internal_default_instance() {
    return reinterpret_cast<const ListNetworkConnectionResp*>(
               &_ListNetworkConnectionResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ListNetworkConnectionResp& a, ListNetworkConnectionResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListNetworkConnectionResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListNetworkConnectionResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListNetworkConnectionResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListNetworkConnectionResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListNetworkConnectionResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListNetworkConnectionResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListNetworkConnectionResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListNetworkConnectionResp";
  }
  protected:
  explicit ListNetworkConnectionResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkConnectionFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // repeated .bbf.sss.NetworkConnection network_connection = 2;
  int network_connection_size() const;
  private:
  int _internal_network_connection_size() const;
  public:
  void clear_network_connection();
  ::bbf::sss::NetworkConnection* mutable_network_connection(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::NetworkConnection >*
      mutable_network_connection();
  private:
  const ::bbf::sss::NetworkConnection& _internal_network_connection(int index) const;
  ::bbf::sss::NetworkConnection* _internal_add_network_connection();
  public:
  const ::bbf::sss::NetworkConnection& network_connection(int index) const;
  ::bbf::sss::NetworkConnection* add_network_connection();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::NetworkConnection >&
      network_connection() const;

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ListNetworkConnectionResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::NetworkConnection > network_connection_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class UpdateSessionContextReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.UpdateSessionContextReq) */ {
 public:
  inline UpdateSessionContextReq() : UpdateSessionContextReq(nullptr) {}
  ~UpdateSessionContextReq() override;
  explicit constexpr UpdateSessionContextReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateSessionContextReq(const UpdateSessionContextReq& from);
  UpdateSessionContextReq(UpdateSessionContextReq&& from) noexcept
    : UpdateSessionContextReq() {
    *this = ::std::move(from);
  }

  inline UpdateSessionContextReq& operator=(const UpdateSessionContextReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateSessionContextReq& operator=(UpdateSessionContextReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateSessionContextReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateSessionContextReq* internal_default_instance() {
    return reinterpret_cast<const UpdateSessionContextReq*>(
               &_UpdateSessionContextReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(UpdateSessionContextReq& a, UpdateSessionContextReq& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateSessionContextReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateSessionContextReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateSessionContextReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateSessionContextReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateSessionContextReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateSessionContextReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSessionContextReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.UpdateSessionContextReq";
  }
  protected:
  explicit UpdateSessionContextReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionContextFieldNumber = 1,
  };
  // .bbf.sss.SessionContext session_context = 1;
  bool has_session_context() const;
  private:
  bool _internal_has_session_context() const;
  public:
  void clear_session_context();
  const ::bbf::sss::SessionContext& session_context() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionContext* release_session_context();
  ::bbf::sss::SessionContext* mutable_session_context();
  void set_allocated_session_context(::bbf::sss::SessionContext* session_context);
  private:
  const ::bbf::sss::SessionContext& _internal_session_context() const;
  ::bbf::sss::SessionContext* _internal_mutable_session_context();
  public:
  void unsafe_arena_set_allocated_session_context(
      ::bbf::sss::SessionContext* session_context);
  ::bbf::sss::SessionContext* unsafe_arena_release_session_context();

  // @@protoc_insertion_point(class_scope:bbf.sss.UpdateSessionContextReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::SessionContext* session_context_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class DeleteSessionContextReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.DeleteSessionContextReq) */ {
 public:
  inline DeleteSessionContextReq() : DeleteSessionContextReq(nullptr) {}
  ~DeleteSessionContextReq() override;
  explicit constexpr DeleteSessionContextReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteSessionContextReq(const DeleteSessionContextReq& from);
  DeleteSessionContextReq(DeleteSessionContextReq&& from) noexcept
    : DeleteSessionContextReq() {
    *this = ::std::move(from);
  }

  inline DeleteSessionContextReq& operator=(const DeleteSessionContextReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSessionContextReq& operator=(DeleteSessionContextReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteSessionContextReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteSessionContextReq* internal_default_instance() {
    return reinterpret_cast<const DeleteSessionContextReq*>(
               &_DeleteSessionContextReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(DeleteSessionContextReq& a, DeleteSessionContextReq& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSessionContextReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSessionContextReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteSessionContextReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteSessionContextReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteSessionContextReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteSessionContextReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSessionContextReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.DeleteSessionContextReq";
  }
  protected:
  explicit DeleteSessionContextReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.DeleteSessionContextReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class GetSessionContextReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.GetSessionContextReq) */ {
 public:
  inline GetSessionContextReq() : GetSessionContextReq(nullptr) {}
  ~GetSessionContextReq() override;
  explicit constexpr GetSessionContextReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSessionContextReq(const GetSessionContextReq& from);
  GetSessionContextReq(GetSessionContextReq&& from) noexcept
    : GetSessionContextReq() {
    *this = ::std::move(from);
  }

  inline GetSessionContextReq& operator=(const GetSessionContextReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSessionContextReq& operator=(GetSessionContextReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSessionContextReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSessionContextReq* internal_default_instance() {
    return reinterpret_cast<const GetSessionContextReq*>(
               &_GetSessionContextReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(GetSessionContextReq& a, GetSessionContextReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSessionContextReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSessionContextReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSessionContextReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSessionContextReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSessionContextReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSessionContextReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSessionContextReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.GetSessionContextReq";
  }
  protected:
  explicit GetSessionContextReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.GetSessionContextReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class SessionContextResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.SessionContextResp) */ {
 public:
  inline SessionContextResp() : SessionContextResp(nullptr) {}
  ~SessionContextResp() override;
  explicit constexpr SessionContextResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionContextResp(const SessionContextResp& from);
  SessionContextResp(SessionContextResp&& from) noexcept
    : SessionContextResp() {
    *this = ::std::move(from);
  }

  inline SessionContextResp& operator=(const SessionContextResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionContextResp& operator=(SessionContextResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionContextResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionContextResp* internal_default_instance() {
    return reinterpret_cast<const SessionContextResp*>(
               &_SessionContextResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(SessionContextResp& a, SessionContextResp& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionContextResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionContextResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionContextResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionContextResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionContextResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionContextResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionContextResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.SessionContextResp";
  }
  protected:
  explicit SessionContextResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionContextFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // .bbf.sss.SessionContext session_context = 2;
  bool has_session_context() const;
  private:
  bool _internal_has_session_context() const;
  public:
  void clear_session_context();
  const ::bbf::sss::SessionContext& session_context() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionContext* release_session_context();
  ::bbf::sss::SessionContext* mutable_session_context();
  void set_allocated_session_context(::bbf::sss::SessionContext* session_context);
  private:
  const ::bbf::sss::SessionContext& _internal_session_context() const;
  ::bbf::sss::SessionContext* _internal_mutable_session_context();
  public:
  void unsafe_arena_set_allocated_session_context(
      ::bbf::sss::SessionContext* session_context);
  ::bbf::sss::SessionContext* unsafe_arena_release_session_context();

  // .bbf.sss.Result result = 1;
  void clear_result();
  ::bbf::sss::Result result() const;
  void set_result(::bbf::sss::Result value);
  private:
  ::bbf::sss::Result _internal_result() const;
  void _internal_set_result(::bbf::sss::Result value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.SessionContextResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::SessionContext* session_context_;
  int result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListSessionContextReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListSessionContextReq) */ {
 public:
  inline ListSessionContextReq() : ListSessionContextReq(nullptr) {}
  ~ListSessionContextReq() override;
  explicit constexpr ListSessionContextReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSessionContextReq(const ListSessionContextReq& from);
  ListSessionContextReq(ListSessionContextReq&& from) noexcept
    : ListSessionContextReq() {
    *this = ::std::move(from);
  }

  inline ListSessionContextReq& operator=(const ListSessionContextReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSessionContextReq& operator=(ListSessionContextReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSessionContextReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSessionContextReq* internal_default_instance() {
    return reinterpret_cast<const ListSessionContextReq*>(
               &_ListSessionContextReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(ListSessionContextReq& a, ListSessionContextReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSessionContextReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSessionContextReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSessionContextReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSessionContextReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSessionContextReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListSessionContextReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSessionContextReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListSessionContextReq";
  }
  protected:
  explicit ListSessionContextReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .bbf.sss.ListFilter filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::bbf::sss::ListFilter& filter() const;
  PROTOBUF_NODISCARD ::bbf::sss::ListFilter* release_filter();
  ::bbf::sss::ListFilter* mutable_filter();
  void set_allocated_filter(::bbf::sss::ListFilter* filter);
  private:
  const ::bbf::sss::ListFilter& _internal_filter() const;
  ::bbf::sss::ListFilter* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::bbf::sss::ListFilter* filter);
  ::bbf::sss::ListFilter* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:bbf.sss.ListSessionContextReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::ListFilter* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ListSessionContextResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ListSessionContextResp) */ {
 public:
  inline ListSessionContextResp() : ListSessionContextResp(nullptr) {}
  ~ListSessionContextResp() override;
  explicit constexpr ListSessionContextResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListSessionContextResp(const ListSessionContextResp& from);
  ListSessionContextResp(ListSessionContextResp&& from) noexcept
    : ListSessionContextResp() {
    *this = ::std::move(from);
  }

  inline ListSessionContextResp& operator=(const ListSessionContextResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSessionContextResp& operator=(ListSessionContextResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListSessionContextResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListSessionContextResp* internal_default_instance() {
    return reinterpret_cast<const ListSessionContextResp*>(
               &_ListSessionContextResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ListSessionContextResp& a, ListSessionContextResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSessionContextResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSessionContextResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListSessionContextResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListSessionContextResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListSessionContextResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListSessionContextResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSessionContextResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ListSessionContextResp";
  }
  protected:
  explicit ListSessionContextResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionContextFieldNumber = 1,
  };
  // repeated .bbf.sss.SessionContext session_context = 1;
  int session_context_size() const;
  private:
  int _internal_session_context_size() const;
  public:
  void clear_session_context();
  ::bbf::sss::SessionContext* mutable_session_context(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::SessionContext >*
      mutable_session_context();
  private:
  const ::bbf::sss::SessionContext& _internal_session_context(int index) const;
  ::bbf::sss::SessionContext* _internal_add_session_context();
  public:
  const ::bbf::sss::SessionContext& session_context(int index) const;
  ::bbf::sss::SessionContext* add_session_context();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::SessionContext >&
      session_context() const;

  // @@protoc_insertion_point(class_scope:bbf.sss.ListSessionContextResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::SessionContext > session_context_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ServiceGatewayUserPlane_Spec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ServiceGatewayUserPlane.Spec) */ {
 public:
  inline ServiceGatewayUserPlane_Spec() : ServiceGatewayUserPlane_Spec(nullptr) {}
  ~ServiceGatewayUserPlane_Spec() override;
  explicit constexpr ServiceGatewayUserPlane_Spec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceGatewayUserPlane_Spec(const ServiceGatewayUserPlane_Spec& from);
  ServiceGatewayUserPlane_Spec(ServiceGatewayUserPlane_Spec&& from) noexcept
    : ServiceGatewayUserPlane_Spec() {
    *this = ::std::move(from);
  }

  inline ServiceGatewayUserPlane_Spec& operator=(const ServiceGatewayUserPlane_Spec& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceGatewayUserPlane_Spec& operator=(ServiceGatewayUserPlane_Spec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceGatewayUserPlane_Spec& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceGatewayUserPlane_Spec* internal_default_instance() {
    return reinterpret_cast<const ServiceGatewayUserPlane_Spec*>(
               &_ServiceGatewayUserPlane_Spec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(ServiceGatewayUserPlane_Spec& a, ServiceGatewayUserPlane_Spec& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceGatewayUserPlane_Spec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceGatewayUserPlane_Spec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceGatewayUserPlane_Spec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceGatewayUserPlane_Spec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceGatewayUserPlane_Spec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceGatewayUserPlane_Spec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceGatewayUserPlane_Spec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ServiceGatewayUserPlane.Spec";
  }
  protected:
  explicit ServiceGatewayUserPlane_Spec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedServiceGroupFieldNumber = 2,
    kAccessIpAddressFieldNumber = 9901,
    kCoreIpAddressFieldNumber = 9902,
    kAccessMacFieldNumber = 9903,
    kCoreMacFieldNumber = 9904,
    kMaxSessionCountFieldNumber = 1,
    kMaintenenceFieldNumber = 3,
  };
  // repeated string supported_service_group = 2;
  int supported_service_group_size() const;
  private:
  int _internal_supported_service_group_size() const;
  public:
  void clear_supported_service_group();
  const std::string& supported_service_group(int index) const;
  std::string* mutable_supported_service_group(int index);
  void set_supported_service_group(int index, const std::string& value);
  void set_supported_service_group(int index, std::string&& value);
  void set_supported_service_group(int index, const char* value);
  void set_supported_service_group(int index, const char* value, size_t size);
  std::string* add_supported_service_group();
  void add_supported_service_group(const std::string& value);
  void add_supported_service_group(std::string&& value);
  void add_supported_service_group(const char* value);
  void add_supported_service_group(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_service_group() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_service_group();
  private:
  const std::string& _internal_supported_service_group(int index) const;
  std::string* _internal_add_supported_service_group();
  public:

  // string access_ip_address = 9901;
  void clear_access_ip_address();
  const std::string& access_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_ip_address();
  PROTOBUF_NODISCARD std::string* release_access_ip_address();
  void set_allocated_access_ip_address(std::string* access_ip_address);
  private:
  const std::string& _internal_access_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_ip_address(const std::string& value);
  std::string* _internal_mutable_access_ip_address();
  public:

  // string core_ip_address = 9902;
  void clear_core_ip_address();
  const std::string& core_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_core_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_core_ip_address();
  PROTOBUF_NODISCARD std::string* release_core_ip_address();
  void set_allocated_core_ip_address(std::string* core_ip_address);
  private:
  const std::string& _internal_core_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_core_ip_address(const std::string& value);
  std::string* _internal_mutable_core_ip_address();
  public:

  // string access_mac = 9903;
  void clear_access_mac();
  const std::string& access_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_mac();
  PROTOBUF_NODISCARD std::string* release_access_mac();
  void set_allocated_access_mac(std::string* access_mac);
  private:
  const std::string& _internal_access_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_mac(const std::string& value);
  std::string* _internal_mutable_access_mac();
  public:

  // string core_mac = 9904;
  void clear_core_mac();
  const std::string& core_mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_core_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_core_mac();
  PROTOBUF_NODISCARD std::string* release_core_mac();
  void set_allocated_core_mac(std::string* core_mac);
  private:
  const std::string& _internal_core_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_core_mac(const std::string& value);
  std::string* _internal_mutable_core_mac();
  public:

  // int32 max_session_count = 1;
  void clear_max_session_count();
  int32_t max_session_count() const;
  void set_max_session_count(int32_t value);
  private:
  int32_t _internal_max_session_count() const;
  void _internal_set_max_session_count(int32_t value);
  public:

  // bool maintenence = 3;
  void clear_maintenence();
  bool maintenence() const;
  void set_maintenence(bool value);
  private:
  bool _internal_maintenence() const;
  void _internal_set_maintenence(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ServiceGatewayUserPlane.Spec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_service_group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr core_ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_mac_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr core_mac_;
  int32_t max_session_count_;
  bool maintenence_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ServiceGatewayUserPlane_Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ServiceGatewayUserPlane.Status) */ {
 public:
  inline ServiceGatewayUserPlane_Status() : ServiceGatewayUserPlane_Status(nullptr) {}
  ~ServiceGatewayUserPlane_Status() override;
  explicit constexpr ServiceGatewayUserPlane_Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceGatewayUserPlane_Status(const ServiceGatewayUserPlane_Status& from);
  ServiceGatewayUserPlane_Status(ServiceGatewayUserPlane_Status&& from) noexcept
    : ServiceGatewayUserPlane_Status() {
    *this = ::std::move(from);
  }

  inline ServiceGatewayUserPlane_Status& operator=(const ServiceGatewayUserPlane_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceGatewayUserPlane_Status& operator=(ServiceGatewayUserPlane_Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceGatewayUserPlane_Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceGatewayUserPlane_Status* internal_default_instance() {
    return reinterpret_cast<const ServiceGatewayUserPlane_Status*>(
               &_ServiceGatewayUserPlane_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(ServiceGatewayUserPlane_Status& a, ServiceGatewayUserPlane_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceGatewayUserPlane_Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceGatewayUserPlane_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceGatewayUserPlane_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceGatewayUserPlane_Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceGatewayUserPlane_Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceGatewayUserPlane_Status& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceGatewayUserPlane_Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ServiceGatewayUserPlane.Status";
  }
  protected:
  explicit ServiceGatewayUserPlane_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkConnectionFieldNumber = 2,
    kAllocatedSessionCountFieldNumber = 1,
  };
  // repeated int32 network_connection = 2;
  int network_connection_size() const;
  private:
  int _internal_network_connection_size() const;
  public:
  void clear_network_connection();
  private:
  int32_t _internal_network_connection(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_network_connection() const;
  void _internal_add_network_connection(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_network_connection();
  public:
  int32_t network_connection(int index) const;
  void set_network_connection(int index, int32_t value);
  void add_network_connection(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      network_connection() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_network_connection();

  // int32 allocated_session_count = 1;
  void clear_allocated_session_count();
  int32_t allocated_session_count() const;
  void set_allocated_session_count(int32_t value);
  private:
  int32_t _internal_allocated_session_count() const;
  void _internal_set_allocated_session_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.ServiceGatewayUserPlane.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > network_connection_;
  mutable std::atomic<int> _network_connection_cached_byte_size_;
  int32_t allocated_session_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ServiceGatewayUserPlane final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ServiceGatewayUserPlane) */ {
 public:
  inline ServiceGatewayUserPlane() : ServiceGatewayUserPlane(nullptr) {}
  ~ServiceGatewayUserPlane() override;
  explicit constexpr ServiceGatewayUserPlane(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceGatewayUserPlane(const ServiceGatewayUserPlane& from);
  ServiceGatewayUserPlane(ServiceGatewayUserPlane&& from) noexcept
    : ServiceGatewayUserPlane() {
    *this = ::std::move(from);
  }

  inline ServiceGatewayUserPlane& operator=(const ServiceGatewayUserPlane& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceGatewayUserPlane& operator=(ServiceGatewayUserPlane&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceGatewayUserPlane& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceGatewayUserPlane* internal_default_instance() {
    return reinterpret_cast<const ServiceGatewayUserPlane*>(
               &_ServiceGatewayUserPlane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ServiceGatewayUserPlane& a, ServiceGatewayUserPlane& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceGatewayUserPlane* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceGatewayUserPlane* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceGatewayUserPlane* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceGatewayUserPlane>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceGatewayUserPlane& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceGatewayUserPlane& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceGatewayUserPlane* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ServiceGatewayUserPlane";
  }
  protected:
  explicit ServiceGatewayUserPlane(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ServiceGatewayUserPlane_Spec Spec;
  typedef ServiceGatewayUserPlane_Status Status;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kServiceGatewayIdFieldNumber = 2,
    kMetadataFieldNumber = 3,
    kSpecFieldNumber = 4,
    kStatusFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string service_gateway_id = 2;
  void clear_service_gateway_id();
  const std::string& service_gateway_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_gateway_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_gateway_id();
  PROTOBUF_NODISCARD std::string* release_service_gateway_id();
  void set_allocated_service_gateway_id(std::string* service_gateway_id);
  private:
  const std::string& _internal_service_gateway_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_gateway_id(const std::string& value);
  std::string* _internal_mutable_service_gateway_id();
  public:

  // .bbf.sss.MetaData metadata = 3;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bbf::sss::MetaData& metadata() const;
  PROTOBUF_NODISCARD ::bbf::sss::MetaData* release_metadata();
  ::bbf::sss::MetaData* mutable_metadata();
  void set_allocated_metadata(::bbf::sss::MetaData* metadata);
  private:
  const ::bbf::sss::MetaData& _internal_metadata() const;
  ::bbf::sss::MetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bbf::sss::MetaData* metadata);
  ::bbf::sss::MetaData* unsafe_arena_release_metadata();

  // .bbf.sss.ServiceGatewayUserPlane.Spec spec = 4;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bbf::sss::ServiceGatewayUserPlane_Spec& spec() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGatewayUserPlane_Spec* release_spec();
  ::bbf::sss::ServiceGatewayUserPlane_Spec* mutable_spec();
  void set_allocated_spec(::bbf::sss::ServiceGatewayUserPlane_Spec* spec);
  private:
  const ::bbf::sss::ServiceGatewayUserPlane_Spec& _internal_spec() const;
  ::bbf::sss::ServiceGatewayUserPlane_Spec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bbf::sss::ServiceGatewayUserPlane_Spec* spec);
  ::bbf::sss::ServiceGatewayUserPlane_Spec* unsafe_arena_release_spec();

  // .bbf.sss.ServiceGatewayUserPlane.Status status = 5;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::bbf::sss::ServiceGatewayUserPlane_Status& status() const;
  PROTOBUF_NODISCARD ::bbf::sss::ServiceGatewayUserPlane_Status* release_status();
  ::bbf::sss::ServiceGatewayUserPlane_Status* mutable_status();
  void set_allocated_status(::bbf::sss::ServiceGatewayUserPlane_Status* status);
  private:
  const ::bbf::sss::ServiceGatewayUserPlane_Status& _internal_status() const;
  ::bbf::sss::ServiceGatewayUserPlane_Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::bbf::sss::ServiceGatewayUserPlane_Status* status);
  ::bbf::sss::ServiceGatewayUserPlane_Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:bbf.sss.ServiceGatewayUserPlane)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_gateway_id_;
  ::bbf::sss::MetaData* metadata_;
  ::bbf::sss::ServiceGatewayUserPlane_Spec* spec_;
  ::bbf::sss::ServiceGatewayUserPlane_Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class Shard_Spec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.Shard.Spec) */ {
 public:
  inline Shard_Spec() : Shard_Spec(nullptr) {}
  ~Shard_Spec() override;
  explicit constexpr Shard_Spec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shard_Spec(const Shard_Spec& from);
  Shard_Spec(Shard_Spec&& from) noexcept
    : Shard_Spec() {
    *this = ::std::move(from);
  }

  inline Shard_Spec& operator=(const Shard_Spec& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shard_Spec& operator=(Shard_Spec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shard_Spec& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shard_Spec* internal_default_instance() {
    return reinterpret_cast<const Shard_Spec*>(
               &_Shard_Spec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Shard_Spec& a, Shard_Spec& b) {
    a.Swap(&b);
  }
  inline void Swap(Shard_Spec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shard_Spec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shard_Spec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shard_Spec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shard_Spec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Shard_Spec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shard_Spec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.Shard.Spec";
  }
  protected:
  explicit Shard_Spec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDesiredNetworkConnectionFieldNumber = 3,
    kDesiredServiceGatewayUserPlaneFieldNumber = 2,
    kRequiredQosFieldNumber = 4,
    kMaxSessionCountFieldNumber = 1,
  };
  // repeated string desired_network_connection = 3;
  int desired_network_connection_size() const;
  private:
  int _internal_desired_network_connection_size() const;
  public:
  void clear_desired_network_connection();
  const std::string& desired_network_connection(int index) const;
  std::string* mutable_desired_network_connection(int index);
  void set_desired_network_connection(int index, const std::string& value);
  void set_desired_network_connection(int index, std::string&& value);
  void set_desired_network_connection(int index, const char* value);
  void set_desired_network_connection(int index, const char* value, size_t size);
  std::string* add_desired_network_connection();
  void add_desired_network_connection(const std::string& value);
  void add_desired_network_connection(std::string&& value);
  void add_desired_network_connection(const char* value);
  void add_desired_network_connection(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& desired_network_connection() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_desired_network_connection();
  private:
  const std::string& _internal_desired_network_connection(int index) const;
  std::string* _internal_add_desired_network_connection();
  public:

  // string desired_service_gateway_user_plane = 2;
  void clear_desired_service_gateway_user_plane();
  const std::string& desired_service_gateway_user_plane() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desired_service_gateway_user_plane(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desired_service_gateway_user_plane();
  PROTOBUF_NODISCARD std::string* release_desired_service_gateway_user_plane();
  void set_allocated_desired_service_gateway_user_plane(std::string* desired_service_gateway_user_plane);
  private:
  const std::string& _internal_desired_service_gateway_user_plane() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desired_service_gateway_user_plane(const std::string& value);
  std::string* _internal_mutable_desired_service_gateway_user_plane();
  public:

  // string required_qos = 4;
  void clear_required_qos();
  const std::string& required_qos() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_required_qos(ArgT0&& arg0, ArgT... args);
  std::string* mutable_required_qos();
  PROTOBUF_NODISCARD std::string* release_required_qos();
  void set_allocated_required_qos(std::string* required_qos);
  private:
  const std::string& _internal_required_qos() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_required_qos(const std::string& value);
  std::string* _internal_mutable_required_qos();
  public:

  // int32 max_session_count = 1;
  void clear_max_session_count();
  int32_t max_session_count() const;
  void set_max_session_count(int32_t value);
  private:
  int32_t _internal_max_session_count() const;
  void _internal_set_max_session_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.Shard.Spec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> desired_network_connection_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desired_service_gateway_user_plane_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_qos_;
  int32_t max_session_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class Shard_Status_TsfNetworkConnectionEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Shard_Status_TsfNetworkConnectionEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Shard_Status_TsfNetworkConnectionEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Shard_Status_TsfNetworkConnectionEntry_DoNotUse();
  explicit constexpr Shard_Status_TsfNetworkConnectionEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Shard_Status_TsfNetworkConnectionEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Shard_Status_TsfNetworkConnectionEntry_DoNotUse& other);
  static const Shard_Status_TsfNetworkConnectionEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Shard_Status_TsfNetworkConnectionEntry_DoNotUse*>(&_Shard_Status_TsfNetworkConnectionEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bbf.sss.Shard.Status.TsfNetworkConnectionEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "bbf.sss.Shard.Status.TsfNetworkConnectionEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Shard_Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.Shard.Status) */ {
 public:
  inline Shard_Status() : Shard_Status(nullptr) {}
  ~Shard_Status() override;
  explicit constexpr Shard_Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shard_Status(const Shard_Status& from);
  Shard_Status(Shard_Status&& from) noexcept
    : Shard_Status() {
    *this = ::std::move(from);
  }

  inline Shard_Status& operator=(const Shard_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shard_Status& operator=(Shard_Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shard_Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shard_Status* internal_default_instance() {
    return reinterpret_cast<const Shard_Status*>(
               &_Shard_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(Shard_Status& a, Shard_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Shard_Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shard_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shard_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shard_Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shard_Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Shard_Status& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shard_Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.Shard.Status";
  }
  protected:
  explicit Shard_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTsfNetworkConnectionFieldNumber = 2,
    kIpPrefixesFieldNumber = 3,
    kCurrentServiceGatewayUserPlaneFieldNumber = 1,
  };
  // map<string, string> tsf_network_connection = 2;
  int tsf_network_connection_size() const;
  private:
  int _internal_tsf_network_connection_size() const;
  public:
  void clear_tsf_network_connection();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tsf_network_connection() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tsf_network_connection();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tsf_network_connection() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tsf_network_connection();

  // repeated string ip_prefixes = 3;
  int ip_prefixes_size() const;
  private:
  int _internal_ip_prefixes_size() const;
  public:
  void clear_ip_prefixes();
  const std::string& ip_prefixes(int index) const;
  std::string* mutable_ip_prefixes(int index);
  void set_ip_prefixes(int index, const std::string& value);
  void set_ip_prefixes(int index, std::string&& value);
  void set_ip_prefixes(int index, const char* value);
  void set_ip_prefixes(int index, const char* value, size_t size);
  std::string* add_ip_prefixes();
  void add_ip_prefixes(const std::string& value);
  void add_ip_prefixes(std::string&& value);
  void add_ip_prefixes(const char* value);
  void add_ip_prefixes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip_prefixes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip_prefixes();
  private:
  const std::string& _internal_ip_prefixes(int index) const;
  std::string* _internal_add_ip_prefixes();
  public:

  // string current_service_gateway_user_plane = 1;
  void clear_current_service_gateway_user_plane();
  const std::string& current_service_gateway_user_plane() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_service_gateway_user_plane(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_service_gateway_user_plane();
  PROTOBUF_NODISCARD std::string* release_current_service_gateway_user_plane();
  void set_allocated_current_service_gateway_user_plane(std::string* current_service_gateway_user_plane);
  private:
  const std::string& _internal_current_service_gateway_user_plane() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_service_gateway_user_plane(const std::string& value);
  std::string* _internal_mutable_current_service_gateway_user_plane();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.Shard.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Shard_Status_TsfNetworkConnectionEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tsf_network_connection_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_prefixes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_service_gateway_user_plane_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class Shard final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.Shard) */ {
 public:
  inline Shard() : Shard(nullptr) {}
  ~Shard() override;
  explicit constexpr Shard(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Shard(const Shard& from);
  Shard(Shard&& from) noexcept
    : Shard() {
    *this = ::std::move(from);
  }

  inline Shard& operator=(const Shard& from) {
    CopyFrom(from);
    return *this;
  }
  inline Shard& operator=(Shard&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Shard& default_instance() {
    return *internal_default_instance();
  }
  static inline const Shard* internal_default_instance() {
    return reinterpret_cast<const Shard*>(
               &_Shard_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(Shard& a, Shard& b) {
    a.Swap(&b);
  }
  inline void Swap(Shard* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Shard* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Shard* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Shard>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Shard& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Shard& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Shard* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.Shard";
  }
  protected:
  explicit Shard(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Shard_Spec Spec;
  typedef Shard_Status Status;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kSpecFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .bbf.sss.MetaData metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bbf::sss::MetaData& metadata() const;
  PROTOBUF_NODISCARD ::bbf::sss::MetaData* release_metadata();
  ::bbf::sss::MetaData* mutable_metadata();
  void set_allocated_metadata(::bbf::sss::MetaData* metadata);
  private:
  const ::bbf::sss::MetaData& _internal_metadata() const;
  ::bbf::sss::MetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bbf::sss::MetaData* metadata);
  ::bbf::sss::MetaData* unsafe_arena_release_metadata();

  // .bbf.sss.Shard.Spec spec = 3;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bbf::sss::Shard_Spec& spec() const;
  PROTOBUF_NODISCARD ::bbf::sss::Shard_Spec* release_spec();
  ::bbf::sss::Shard_Spec* mutable_spec();
  void set_allocated_spec(::bbf::sss::Shard_Spec* spec);
  private:
  const ::bbf::sss::Shard_Spec& _internal_spec() const;
  ::bbf::sss::Shard_Spec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bbf::sss::Shard_Spec* spec);
  ::bbf::sss::Shard_Spec* unsafe_arena_release_spec();

  // .bbf.sss.Shard.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::bbf::sss::Shard_Status& status() const;
  PROTOBUF_NODISCARD ::bbf::sss::Shard_Status* release_status();
  ::bbf::sss::Shard_Status* mutable_status();
  void set_allocated_status(::bbf::sss::Shard_Status* status);
  private:
  const ::bbf::sss::Shard_Status& _internal_status() const;
  ::bbf::sss::Shard_Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::bbf::sss::Shard_Status* status);
  ::bbf::sss::Shard_Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:bbf.sss.Shard)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::bbf::sss::MetaData* metadata_;
  ::bbf::sss::Shard_Spec* spec_;
  ::bbf::sss::Shard_Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class TrafficSteeringFunction_Spec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.TrafficSteeringFunction.Spec) */ {
 public:
  inline TrafficSteeringFunction_Spec() : TrafficSteeringFunction_Spec(nullptr) {}
  ~TrafficSteeringFunction_Spec() override;
  explicit constexpr TrafficSteeringFunction_Spec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficSteeringFunction_Spec(const TrafficSteeringFunction_Spec& from);
  TrafficSteeringFunction_Spec(TrafficSteeringFunction_Spec&& from) noexcept
    : TrafficSteeringFunction_Spec() {
    *this = ::std::move(from);
  }

  inline TrafficSteeringFunction_Spec& operator=(const TrafficSteeringFunction_Spec& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSteeringFunction_Spec& operator=(TrafficSteeringFunction_Spec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSteeringFunction_Spec& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSteeringFunction_Spec* internal_default_instance() {
    return reinterpret_cast<const TrafficSteeringFunction_Spec*>(
               &_TrafficSteeringFunction_Spec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(TrafficSteeringFunction_Spec& a, TrafficSteeringFunction_Spec& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSteeringFunction_Spec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSteeringFunction_Spec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSteeringFunction_Spec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSteeringFunction_Spec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficSteeringFunction_Spec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficSteeringFunction_Spec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSteeringFunction_Spec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.TrafficSteeringFunction.Spec";
  }
  protected:
  explicit TrafficSteeringFunction_Spec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 9901,
    kMacFieldNumber = 9903,
  };
  // string ip_address = 9901;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // string mac = 9903;
  void clear_mac();
  const std::string& mac() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac();
  PROTOBUF_NODISCARD std::string* release_mac();
  void set_allocated_mac(std::string* mac);
  private:
  const std::string& _internal_mac() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac(const std::string& value);
  std::string* _internal_mutable_mac();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.TrafficSteeringFunction.Spec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class TrafficSteeringFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.TrafficSteeringFunction) */ {
 public:
  inline TrafficSteeringFunction() : TrafficSteeringFunction(nullptr) {}
  ~TrafficSteeringFunction() override;
  explicit constexpr TrafficSteeringFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrafficSteeringFunction(const TrafficSteeringFunction& from);
  TrafficSteeringFunction(TrafficSteeringFunction&& from) noexcept
    : TrafficSteeringFunction() {
    *this = ::std::move(from);
  }

  inline TrafficSteeringFunction& operator=(const TrafficSteeringFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrafficSteeringFunction& operator=(TrafficSteeringFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrafficSteeringFunction& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrafficSteeringFunction* internal_default_instance() {
    return reinterpret_cast<const TrafficSteeringFunction*>(
               &_TrafficSteeringFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(TrafficSteeringFunction& a, TrafficSteeringFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(TrafficSteeringFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrafficSteeringFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrafficSteeringFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrafficSteeringFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrafficSteeringFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TrafficSteeringFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSteeringFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.TrafficSteeringFunction";
  }
  protected:
  explicit TrafficSteeringFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TrafficSteeringFunction_Spec Spec;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kSpecFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .bbf.sss.MetaData metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bbf::sss::MetaData& metadata() const;
  PROTOBUF_NODISCARD ::bbf::sss::MetaData* release_metadata();
  ::bbf::sss::MetaData* mutable_metadata();
  void set_allocated_metadata(::bbf::sss::MetaData* metadata);
  private:
  const ::bbf::sss::MetaData& _internal_metadata() const;
  ::bbf::sss::MetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bbf::sss::MetaData* metadata);
  ::bbf::sss::MetaData* unsafe_arena_release_metadata();

  // .bbf.sss.TrafficSteeringFunction.Spec spec = 3;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bbf::sss::TrafficSteeringFunction_Spec& spec() const;
  PROTOBUF_NODISCARD ::bbf::sss::TrafficSteeringFunction_Spec* release_spec();
  ::bbf::sss::TrafficSteeringFunction_Spec* mutable_spec();
  void set_allocated_spec(::bbf::sss::TrafficSteeringFunction_Spec* spec);
  private:
  const ::bbf::sss::TrafficSteeringFunction_Spec& _internal_spec() const;
  ::bbf::sss::TrafficSteeringFunction_Spec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bbf::sss::TrafficSteeringFunction_Spec* spec);
  ::bbf::sss::TrafficSteeringFunction_Spec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:bbf.sss.TrafficSteeringFunction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::bbf::sss::MetaData* metadata_;
  ::bbf::sss::TrafficSteeringFunction_Spec* spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class ServiceGateway final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.ServiceGateway) */ {
 public:
  inline ServiceGateway() : ServiceGateway(nullptr) {}
  ~ServiceGateway() override;
  explicit constexpr ServiceGateway(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceGateway(const ServiceGateway& from);
  ServiceGateway(ServiceGateway&& from) noexcept
    : ServiceGateway() {
    *this = ::std::move(from);
  }

  inline ServiceGateway& operator=(const ServiceGateway& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceGateway& operator=(ServiceGateway&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceGateway& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceGateway* internal_default_instance() {
    return reinterpret_cast<const ServiceGateway*>(
               &_ServiceGateway_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ServiceGateway& a, ServiceGateway& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceGateway* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceGateway* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServiceGateway* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ServiceGateway>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceGateway& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceGateway& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceGateway* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.ServiceGateway";
  }
  protected:
  explicit ServiceGateway(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .bbf.sss.MetaData metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bbf::sss::MetaData& metadata() const;
  PROTOBUF_NODISCARD ::bbf::sss::MetaData* release_metadata();
  ::bbf::sss::MetaData* mutable_metadata();
  void set_allocated_metadata(::bbf::sss::MetaData* metadata);
  private:
  const ::bbf::sss::MetaData& _internal_metadata() const;
  ::bbf::sss::MetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bbf::sss::MetaData* metadata);
  ::bbf::sss::MetaData* unsafe_arena_release_metadata();

  // @@protoc_insertion_point(class_scope:bbf.sss.ServiceGateway)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::bbf::sss::MetaData* metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class NetworkConnection_Spec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.NetworkConnection.Spec) */ {
 public:
  inline NetworkConnection_Spec() : NetworkConnection_Spec(nullptr) {}
  ~NetworkConnection_Spec() override;
  explicit constexpr NetworkConnection_Spec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkConnection_Spec(const NetworkConnection_Spec& from);
  NetworkConnection_Spec(NetworkConnection_Spec&& from) noexcept
    : NetworkConnection_Spec() {
    *this = ::std::move(from);
  }

  inline NetworkConnection_Spec& operator=(const NetworkConnection_Spec& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConnection_Spec& operator=(NetworkConnection_Spec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConnection_Spec& default_instance() {
    return *internal_default_instance();
  }
  enum TransportCase {
    kVxlan = 3,
    TRANSPORT_NOT_SET = 0,
  };

  static inline const NetworkConnection_Spec* internal_default_instance() {
    return reinterpret_cast<const NetworkConnection_Spec*>(
               &_NetworkConnection_Spec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(NetworkConnection_Spec& a, NetworkConnection_Spec& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConnection_Spec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConnection_Spec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConnection_Spec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConnection_Spec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkConnection_Spec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetworkConnection_Spec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConnection_Spec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.NetworkConnection.Spec";
  }
  protected:
  explicit NetworkConnection_Spec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficSteeringFunctionFieldNumber = 1,
    kServiceGatewayUserPlaneFieldNumber = 2,
    kVxlanFieldNumber = 3,
  };
  // string traffic_steering_function = 1;
  void clear_traffic_steering_function();
  const std::string& traffic_steering_function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_traffic_steering_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_traffic_steering_function();
  PROTOBUF_NODISCARD std::string* release_traffic_steering_function();
  void set_allocated_traffic_steering_function(std::string* traffic_steering_function);
  private:
  const std::string& _internal_traffic_steering_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_traffic_steering_function(const std::string& value);
  std::string* _internal_mutable_traffic_steering_function();
  public:

  // string service_gateway_user_plane = 2;
  void clear_service_gateway_user_plane();
  const std::string& service_gateway_user_plane() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_gateway_user_plane(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_gateway_user_plane();
  PROTOBUF_NODISCARD std::string* release_service_gateway_user_plane();
  void set_allocated_service_gateway_user_plane(std::string* service_gateway_user_plane);
  private:
  const std::string& _internal_service_gateway_user_plane() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_gateway_user_plane(const std::string& value);
  std::string* _internal_mutable_service_gateway_user_plane();
  public:

  // .bbf.sss.VxlanConnection vxlan = 3;
  bool has_vxlan() const;
  private:
  bool _internal_has_vxlan() const;
  public:
  void clear_vxlan();
  const ::bbf::sss::VxlanConnection& vxlan() const;
  PROTOBUF_NODISCARD ::bbf::sss::VxlanConnection* release_vxlan();
  ::bbf::sss::VxlanConnection* mutable_vxlan();
  void set_allocated_vxlan(::bbf::sss::VxlanConnection* vxlan);
  private:
  const ::bbf::sss::VxlanConnection& _internal_vxlan() const;
  ::bbf::sss::VxlanConnection* _internal_mutable_vxlan();
  public:
  void unsafe_arena_set_allocated_vxlan(
      ::bbf::sss::VxlanConnection* vxlan);
  ::bbf::sss::VxlanConnection* unsafe_arena_release_vxlan();

  void clear_transport();
  TransportCase transport_case() const;
  // @@protoc_insertion_point(class_scope:bbf.sss.NetworkConnection.Spec)
 private:
  class _Internal;
  void set_has_vxlan();

  inline bool has_transport() const;
  inline void clear_has_transport();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr traffic_steering_function_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_gateway_user_plane_;
  union TransportUnion {
    constexpr TransportUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::bbf::sss::VxlanConnection* vxlan_;
  } transport_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class NetworkConnection_Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.NetworkConnection.Status) */ {
 public:
  inline NetworkConnection_Status() : NetworkConnection_Status(nullptr) {}
  ~NetworkConnection_Status() override;
  explicit constexpr NetworkConnection_Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkConnection_Status(const NetworkConnection_Status& from);
  NetworkConnection_Status(NetworkConnection_Status&& from) noexcept
    : NetworkConnection_Status() {
    *this = ::std::move(from);
  }

  inline NetworkConnection_Status& operator=(const NetworkConnection_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConnection_Status& operator=(NetworkConnection_Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConnection_Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkConnection_Status* internal_default_instance() {
    return reinterpret_cast<const NetworkConnection_Status*>(
               &_NetworkConnection_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(NetworkConnection_Status& a, NetworkConnection_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConnection_Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConnection_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConnection_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConnection_Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkConnection_Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetworkConnection_Status& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConnection_Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.NetworkConnection.Status";
  }
  protected:
  explicit NetworkConnection_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NetworkConnection_Status_NcEndpointStatus NcEndpointStatus;
  static constexpr NcEndpointStatus UNKNOWN =
    NetworkConnection_Status_NcEndpointStatus_UNKNOWN;
  static constexpr NcEndpointStatus UP =
    NetworkConnection_Status_NcEndpointStatus_UP;
  static constexpr NcEndpointStatus DOWN =
    NetworkConnection_Status_NcEndpointStatus_DOWN;
  static inline bool NcEndpointStatus_IsValid(int value) {
    return NetworkConnection_Status_NcEndpointStatus_IsValid(value);
  }
  static constexpr NcEndpointStatus NcEndpointStatus_MIN =
    NetworkConnection_Status_NcEndpointStatus_NcEndpointStatus_MIN;
  static constexpr NcEndpointStatus NcEndpointStatus_MAX =
    NetworkConnection_Status_NcEndpointStatus_NcEndpointStatus_MAX;
  static constexpr int NcEndpointStatus_ARRAYSIZE =
    NetworkConnection_Status_NcEndpointStatus_NcEndpointStatus_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  NcEndpointStatus_descriptor() {
    return NetworkConnection_Status_NcEndpointStatus_descriptor();
  }
  template<typename T>
  static inline const std::string& NcEndpointStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, NcEndpointStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function NcEndpointStatus_Name.");
    return NetworkConnection_Status_NcEndpointStatus_Name(enum_t_value);
  }
  static inline bool NcEndpointStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      NcEndpointStatus* value) {
    return NetworkConnection_Status_NcEndpointStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNcTrafficSteeringFunctionStatusFieldNumber = 1,
    kNcServiceGatewayUserPlaneStatusFieldNumber = 2,
  };
  // .bbf.sss.NetworkConnection.Status.NcEndpointStatus nc_traffic_steering_function_status = 1;
  void clear_nc_traffic_steering_function_status();
  ::bbf::sss::NetworkConnection_Status_NcEndpointStatus nc_traffic_steering_function_status() const;
  void set_nc_traffic_steering_function_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value);
  private:
  ::bbf::sss::NetworkConnection_Status_NcEndpointStatus _internal_nc_traffic_steering_function_status() const;
  void _internal_set_nc_traffic_steering_function_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value);
  public:

  // .bbf.sss.NetworkConnection.Status.NcEndpointStatus nc_service_gateway_user_plane_status = 2;
  void clear_nc_service_gateway_user_plane_status();
  ::bbf::sss::NetworkConnection_Status_NcEndpointStatus nc_service_gateway_user_plane_status() const;
  void set_nc_service_gateway_user_plane_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value);
  private:
  ::bbf::sss::NetworkConnection_Status_NcEndpointStatus _internal_nc_service_gateway_user_plane_status() const;
  void _internal_set_nc_service_gateway_user_plane_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.NetworkConnection.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int nc_traffic_steering_function_status_;
  int nc_service_gateway_user_plane_status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class NetworkConnection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.NetworkConnection) */ {
 public:
  inline NetworkConnection() : NetworkConnection(nullptr) {}
  ~NetworkConnection() override;
  explicit constexpr NetworkConnection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NetworkConnection(const NetworkConnection& from);
  NetworkConnection(NetworkConnection&& from) noexcept
    : NetworkConnection() {
    *this = ::std::move(from);
  }

  inline NetworkConnection& operator=(const NetworkConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetworkConnection& operator=(NetworkConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetworkConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetworkConnection* internal_default_instance() {
    return reinterpret_cast<const NetworkConnection*>(
               &_NetworkConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(NetworkConnection& a, NetworkConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(NetworkConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetworkConnection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetworkConnection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NetworkConnection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NetworkConnection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NetworkConnection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetworkConnection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.NetworkConnection";
  }
  protected:
  explicit NetworkConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef NetworkConnection_Spec Spec;
  typedef NetworkConnection_Status Status;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kSpecFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .bbf.sss.MetaData metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bbf::sss::MetaData& metadata() const;
  PROTOBUF_NODISCARD ::bbf::sss::MetaData* release_metadata();
  ::bbf::sss::MetaData* mutable_metadata();
  void set_allocated_metadata(::bbf::sss::MetaData* metadata);
  private:
  const ::bbf::sss::MetaData& _internal_metadata() const;
  ::bbf::sss::MetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bbf::sss::MetaData* metadata);
  ::bbf::sss::MetaData* unsafe_arena_release_metadata();

  // .bbf.sss.NetworkConnection.Spec spec = 3;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bbf::sss::NetworkConnection_Spec& spec() const;
  PROTOBUF_NODISCARD ::bbf::sss::NetworkConnection_Spec* release_spec();
  ::bbf::sss::NetworkConnection_Spec* mutable_spec();
  void set_allocated_spec(::bbf::sss::NetworkConnection_Spec* spec);
  private:
  const ::bbf::sss::NetworkConnection_Spec& _internal_spec() const;
  ::bbf::sss::NetworkConnection_Spec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bbf::sss::NetworkConnection_Spec* spec);
  ::bbf::sss::NetworkConnection_Spec* unsafe_arena_release_spec();

  // .bbf.sss.NetworkConnection.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::bbf::sss::NetworkConnection_Status& status() const;
  PROTOBUF_NODISCARD ::bbf::sss::NetworkConnection_Status* release_status();
  ::bbf::sss::NetworkConnection_Status* mutable_status();
  void set_allocated_status(::bbf::sss::NetworkConnection_Status* status);
  private:
  const ::bbf::sss::NetworkConnection_Status& _internal_status() const;
  ::bbf::sss::NetworkConnection_Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::bbf::sss::NetworkConnection_Status* status);
  ::bbf::sss::NetworkConnection_Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:bbf.sss.NetworkConnection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::bbf::sss::MetaData* metadata_;
  ::bbf::sss::NetworkConnection_Spec* spec_;
  ::bbf::sss::NetworkConnection_Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class VxlanConnection_Vtep final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.VxlanConnection.Vtep) */ {
 public:
  inline VxlanConnection_Vtep() : VxlanConnection_Vtep(nullptr) {}
  ~VxlanConnection_Vtep() override;
  explicit constexpr VxlanConnection_Vtep(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VxlanConnection_Vtep(const VxlanConnection_Vtep& from);
  VxlanConnection_Vtep(VxlanConnection_Vtep&& from) noexcept
    : VxlanConnection_Vtep() {
    *this = ::std::move(from);
  }

  inline VxlanConnection_Vtep& operator=(const VxlanConnection_Vtep& from) {
    CopyFrom(from);
    return *this;
  }
  inline VxlanConnection_Vtep& operator=(VxlanConnection_Vtep&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VxlanConnection_Vtep& default_instance() {
    return *internal_default_instance();
  }
  static inline const VxlanConnection_Vtep* internal_default_instance() {
    return reinterpret_cast<const VxlanConnection_Vtep*>(
               &_VxlanConnection_Vtep_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(VxlanConnection_Vtep& a, VxlanConnection_Vtep& b) {
    a.Swap(&b);
  }
  inline void Swap(VxlanConnection_Vtep* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VxlanConnection_Vtep* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VxlanConnection_Vtep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VxlanConnection_Vtep>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VxlanConnection_Vtep& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VxlanConnection_Vtep& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VxlanConnection_Vtep* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.VxlanConnection.Vtep";
  }
  protected:
  explicit VxlanConnection_Vtep(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpAddressFieldNumber = 1,
    kMacAddressFieldNumber = 9903,
    kUdpPortFieldNumber = 2,
  };
  // string ip_address = 1;
  void clear_ip_address();
  const std::string& ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_address();
  PROTOBUF_NODISCARD std::string* release_ip_address();
  void set_allocated_ip_address(std::string* ip_address);
  private:
  const std::string& _internal_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_address(const std::string& value);
  std::string* _internal_mutable_ip_address();
  public:

  // string mac_address = 9903;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // int32 udp_port = 2;
  void clear_udp_port();
  int32_t udp_port() const;
  void set_udp_port(int32_t value);
  private:
  int32_t _internal_udp_port() const;
  void _internal_set_udp_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.VxlanConnection.Vtep)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  int32_t udp_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class VxlanConnection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.VxlanConnection) */ {
 public:
  inline VxlanConnection() : VxlanConnection(nullptr) {}
  ~VxlanConnection() override;
  explicit constexpr VxlanConnection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VxlanConnection(const VxlanConnection& from);
  VxlanConnection(VxlanConnection&& from) noexcept
    : VxlanConnection() {
    *this = ::std::move(from);
  }

  inline VxlanConnection& operator=(const VxlanConnection& from) {
    CopyFrom(from);
    return *this;
  }
  inline VxlanConnection& operator=(VxlanConnection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VxlanConnection& default_instance() {
    return *internal_default_instance();
  }
  static inline const VxlanConnection* internal_default_instance() {
    return reinterpret_cast<const VxlanConnection*>(
               &_VxlanConnection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(VxlanConnection& a, VxlanConnection& b) {
    a.Swap(&b);
  }
  inline void Swap(VxlanConnection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VxlanConnection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VxlanConnection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VxlanConnection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VxlanConnection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VxlanConnection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VxlanConnection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.VxlanConnection";
  }
  protected:
  explicit VxlanConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VxlanConnection_Vtep Vtep;

  // accessors -------------------------------------------------------

  enum : int {
    kTrafficSteeringFunctionVniFieldNumber = 1,
    kServiceGatewayUserPlaneVniFieldNumber = 2,
    kVniFieldNumber = 3,
  };
  // .bbf.sss.VxlanConnection.Vtep traffic_steering_function_vni = 1;
  bool has_traffic_steering_function_vni() const;
  private:
  bool _internal_has_traffic_steering_function_vni() const;
  public:
  void clear_traffic_steering_function_vni();
  const ::bbf::sss::VxlanConnection_Vtep& traffic_steering_function_vni() const;
  PROTOBUF_NODISCARD ::bbf::sss::VxlanConnection_Vtep* release_traffic_steering_function_vni();
  ::bbf::sss::VxlanConnection_Vtep* mutable_traffic_steering_function_vni();
  void set_allocated_traffic_steering_function_vni(::bbf::sss::VxlanConnection_Vtep* traffic_steering_function_vni);
  private:
  const ::bbf::sss::VxlanConnection_Vtep& _internal_traffic_steering_function_vni() const;
  ::bbf::sss::VxlanConnection_Vtep* _internal_mutable_traffic_steering_function_vni();
  public:
  void unsafe_arena_set_allocated_traffic_steering_function_vni(
      ::bbf::sss::VxlanConnection_Vtep* traffic_steering_function_vni);
  ::bbf::sss::VxlanConnection_Vtep* unsafe_arena_release_traffic_steering_function_vni();

  // .bbf.sss.VxlanConnection.Vtep service_gateway_user_plane_vni = 2;
  bool has_service_gateway_user_plane_vni() const;
  private:
  bool _internal_has_service_gateway_user_plane_vni() const;
  public:
  void clear_service_gateway_user_plane_vni();
  const ::bbf::sss::VxlanConnection_Vtep& service_gateway_user_plane_vni() const;
  PROTOBUF_NODISCARD ::bbf::sss::VxlanConnection_Vtep* release_service_gateway_user_plane_vni();
  ::bbf::sss::VxlanConnection_Vtep* mutable_service_gateway_user_plane_vni();
  void set_allocated_service_gateway_user_plane_vni(::bbf::sss::VxlanConnection_Vtep* service_gateway_user_plane_vni);
  private:
  const ::bbf::sss::VxlanConnection_Vtep& _internal_service_gateway_user_plane_vni() const;
  ::bbf::sss::VxlanConnection_Vtep* _internal_mutable_service_gateway_user_plane_vni();
  public:
  void unsafe_arena_set_allocated_service_gateway_user_plane_vni(
      ::bbf::sss::VxlanConnection_Vtep* service_gateway_user_plane_vni);
  ::bbf::sss::VxlanConnection_Vtep* unsafe_arena_release_service_gateway_user_plane_vni();

  // int32 vni = 3;
  void clear_vni();
  int32_t vni() const;
  void set_vni(int32_t value);
  private:
  int32_t _internal_vni() const;
  void _internal_set_vni(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.VxlanConnection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::bbf::sss::VxlanConnection_Vtep* traffic_steering_function_vni_;
  ::bbf::sss::VxlanConnection_Vtep* service_gateway_user_plane_vni_;
  int32_t vni_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class SessionContext_Spec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.SessionContext.Spec) */ {
 public:
  inline SessionContext_Spec() : SessionContext_Spec(nullptr) {}
  ~SessionContext_Spec() override;
  explicit constexpr SessionContext_Spec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionContext_Spec(const SessionContext_Spec& from);
  SessionContext_Spec(SessionContext_Spec&& from) noexcept
    : SessionContext_Spec() {
    *this = ::std::move(from);
  }

  inline SessionContext_Spec& operator=(const SessionContext_Spec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionContext_Spec& operator=(SessionContext_Spec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionContext_Spec& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionContext_Spec* internal_default_instance() {
    return reinterpret_cast<const SessionContext_Spec*>(
               &_SessionContext_Spec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(SessionContext_Spec& a, SessionContext_Spec& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionContext_Spec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionContext_Spec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionContext_Spec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionContext_Spec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionContext_Spec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionContext_Spec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionContext_Spec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.SessionContext.Spec";
  }
  protected:
  explicit SessionContext_Spec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SessionContext_Spec_ContextType ContextType;
  static constexpr ContextType DEFAULT =
    SessionContext_Spec_ContextType_DEFAULT;
  static constexpr ContextType PPPOE =
    SessionContext_Spec_ContextType_PPPOE;
  static constexpr ContextType IPOE =
    SessionContext_Spec_ContextType_IPOE;
  static inline bool ContextType_IsValid(int value) {
    return SessionContext_Spec_ContextType_IsValid(value);
  }
  static constexpr ContextType ContextType_MIN =
    SessionContext_Spec_ContextType_ContextType_MIN;
  static constexpr ContextType ContextType_MAX =
    SessionContext_Spec_ContextType_ContextType_MAX;
  static constexpr int ContextType_ARRAYSIZE =
    SessionContext_Spec_ContextType_ContextType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ContextType_descriptor() {
    return SessionContext_Spec_ContextType_descriptor();
  }
  template<typename T>
  static inline const std::string& ContextType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ContextType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ContextType_Name.");
    return SessionContext_Spec_ContextType_Name(enum_t_value);
  }
  static inline bool ContextType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ContextType* value) {
    return SessionContext_Spec_ContextType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredServiceGroupFieldNumber = 3,
    kTrafficSteeringFunctionFieldNumber = 1,
    kDesiredShardFieldNumber = 2,
    kRequiredQosFieldNumber = 4,
    kSessionFilterFieldNumber = 6,
    kContextTypeFieldNumber = 5,
  };
  // repeated string required_service_group = 3;
  int required_service_group_size() const;
  private:
  int _internal_required_service_group_size() const;
  public:
  void clear_required_service_group();
  const std::string& required_service_group(int index) const;
  std::string* mutable_required_service_group(int index);
  void set_required_service_group(int index, const std::string& value);
  void set_required_service_group(int index, std::string&& value);
  void set_required_service_group(int index, const char* value);
  void set_required_service_group(int index, const char* value, size_t size);
  std::string* add_required_service_group();
  void add_required_service_group(const std::string& value);
  void add_required_service_group(std::string&& value);
  void add_required_service_group(const char* value);
  void add_required_service_group(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& required_service_group() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_required_service_group();
  private:
  const std::string& _internal_required_service_group(int index) const;
  std::string* _internal_add_required_service_group();
  public:

  // string traffic_steering_function = 1;
  void clear_traffic_steering_function();
  const std::string& traffic_steering_function() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_traffic_steering_function(ArgT0&& arg0, ArgT... args);
  std::string* mutable_traffic_steering_function();
  PROTOBUF_NODISCARD std::string* release_traffic_steering_function();
  void set_allocated_traffic_steering_function(std::string* traffic_steering_function);
  private:
  const std::string& _internal_traffic_steering_function() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_traffic_steering_function(const std::string& value);
  std::string* _internal_mutable_traffic_steering_function();
  public:

  // string desired_shard = 2;
  void clear_desired_shard();
  const std::string& desired_shard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_desired_shard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_desired_shard();
  PROTOBUF_NODISCARD std::string* release_desired_shard();
  void set_allocated_desired_shard(std::string* desired_shard);
  private:
  const std::string& _internal_desired_shard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_desired_shard(const std::string& value);
  std::string* _internal_mutable_desired_shard();
  public:

  // string required_qos = 4;
  void clear_required_qos();
  const std::string& required_qos() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_required_qos(ArgT0&& arg0, ArgT... args);
  std::string* mutable_required_qos();
  PROTOBUF_NODISCARD std::string* release_required_qos();
  void set_allocated_required_qos(std::string* required_qos);
  private:
  const std::string& _internal_required_qos() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_required_qos(const std::string& value);
  std::string* _internal_mutable_required_qos();
  public:

  // .bbf.sss.SessionFilter session_filter = 6;
  bool has_session_filter() const;
  private:
  bool _internal_has_session_filter() const;
  public:
  void clear_session_filter();
  const ::bbf::sss::SessionFilter& session_filter() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionFilter* release_session_filter();
  ::bbf::sss::SessionFilter* mutable_session_filter();
  void set_allocated_session_filter(::bbf::sss::SessionFilter* session_filter);
  private:
  const ::bbf::sss::SessionFilter& _internal_session_filter() const;
  ::bbf::sss::SessionFilter* _internal_mutable_session_filter();
  public:
  void unsafe_arena_set_allocated_session_filter(
      ::bbf::sss::SessionFilter* session_filter);
  ::bbf::sss::SessionFilter* unsafe_arena_release_session_filter();

  // .bbf.sss.SessionContext.Spec.ContextType context_type = 5;
  void clear_context_type();
  ::bbf::sss::SessionContext_Spec_ContextType context_type() const;
  void set_context_type(::bbf::sss::SessionContext_Spec_ContextType value);
  private:
  ::bbf::sss::SessionContext_Spec_ContextType _internal_context_type() const;
  void _internal_set_context_type(::bbf::sss::SessionContext_Spec_ContextType value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.SessionContext.Spec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> required_service_group_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr traffic_steering_function_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr desired_shard_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr required_qos_;
  ::bbf::sss::SessionFilter* session_filter_;
  int context_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class SessionContext_Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.SessionContext.Status) */ {
 public:
  inline SessionContext_Status() : SessionContext_Status(nullptr) {}
  ~SessionContext_Status() override;
  explicit constexpr SessionContext_Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionContext_Status(const SessionContext_Status& from);
  SessionContext_Status(SessionContext_Status&& from) noexcept
    : SessionContext_Status() {
    *this = ::std::move(from);
  }

  inline SessionContext_Status& operator=(const SessionContext_Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionContext_Status& operator=(SessionContext_Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionContext_Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionContext_Status* internal_default_instance() {
    return reinterpret_cast<const SessionContext_Status*>(
               &_SessionContext_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(SessionContext_Status& a, SessionContext_Status& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionContext_Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionContext_Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionContext_Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionContext_Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionContext_Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionContext_Status& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionContext_Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.SessionContext.Status";
  }
  protected:
  explicit SessionContext_Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentShardFieldNumber = 2,
  };
  // string current_shard = 2;
  void clear_current_shard();
  const std::string& current_shard() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_shard(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_shard();
  PROTOBUF_NODISCARD std::string* release_current_shard();
  void set_allocated_current_shard(std::string* current_shard);
  private:
  const std::string& _internal_current_shard() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_shard(const std::string& value);
  std::string* _internal_mutable_current_shard();
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.SessionContext.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_shard_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class SessionContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.SessionContext) */ {
 public:
  inline SessionContext() : SessionContext(nullptr) {}
  ~SessionContext() override;
  explicit constexpr SessionContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionContext(const SessionContext& from);
  SessionContext(SessionContext&& from) noexcept
    : SessionContext() {
    *this = ::std::move(from);
  }

  inline SessionContext& operator=(const SessionContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionContext& operator=(SessionContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionContext* internal_default_instance() {
    return reinterpret_cast<const SessionContext*>(
               &_SessionContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(SessionContext& a, SessionContext& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.SessionContext";
  }
  protected:
  explicit SessionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SessionContext_Spec Spec;
  typedef SessionContext_Status Status;

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kMetadataFieldNumber = 2,
    kSpecFieldNumber = 3,
    kStatusFieldNumber = 4,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .bbf.sss.MetaData metadata = 2;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::bbf::sss::MetaData& metadata() const;
  PROTOBUF_NODISCARD ::bbf::sss::MetaData* release_metadata();
  ::bbf::sss::MetaData* mutable_metadata();
  void set_allocated_metadata(::bbf::sss::MetaData* metadata);
  private:
  const ::bbf::sss::MetaData& _internal_metadata() const;
  ::bbf::sss::MetaData* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::bbf::sss::MetaData* metadata);
  ::bbf::sss::MetaData* unsafe_arena_release_metadata();

  // .bbf.sss.SessionContext.Spec spec = 3;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::bbf::sss::SessionContext_Spec& spec() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionContext_Spec* release_spec();
  ::bbf::sss::SessionContext_Spec* mutable_spec();
  void set_allocated_spec(::bbf::sss::SessionContext_Spec* spec);
  private:
  const ::bbf::sss::SessionContext_Spec& _internal_spec() const;
  ::bbf::sss::SessionContext_Spec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::bbf::sss::SessionContext_Spec* spec);
  ::bbf::sss::SessionContext_Spec* unsafe_arena_release_spec();

  // .bbf.sss.SessionContext.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::bbf::sss::SessionContext_Status& status() const;
  PROTOBUF_NODISCARD ::bbf::sss::SessionContext_Status* release_status();
  ::bbf::sss::SessionContext_Status* mutable_status();
  void set_allocated_status(::bbf::sss::SessionContext_Status* status);
  private:
  const ::bbf::sss::SessionContext_Status& _internal_status() const;
  ::bbf::sss::SessionContext_Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::bbf::sss::SessionContext_Status* status);
  ::bbf::sss::SessionContext_Status* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:bbf.sss.SessionContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::bbf::sss::MetaData* metadata_;
  ::bbf::sss::SessionContext_Spec* spec_;
  ::bbf::sss::SessionContext_Status* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// -------------------------------------------------------------------

class SessionFilter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bbf.sss.SessionFilter) */ {
 public:
  inline SessionFilter() : SessionFilter(nullptr) {}
  ~SessionFilter() override;
  explicit constexpr SessionFilter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionFilter(const SessionFilter& from);
  SessionFilter(SessionFilter&& from) noexcept
    : SessionFilter() {
    *this = ::std::move(from);
  }

  inline SessionFilter& operator=(const SessionFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionFilter& operator=(SessionFilter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SessionFilter& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionFilter* internal_default_instance() {
    return reinterpret_cast<const SessionFilter*>(
               &_SessionFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(SessionFilter& a, SessionFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SessionFilter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionFilter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionFilter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SessionFilter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SessionFilter& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionFilter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bbf.sss.SessionFilter";
  }
  protected:
  explicit SessionFilter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMacAddressFieldNumber = 1,
    kCircuitIdFieldNumber = 4,
    kRemoteIdFieldNumber = 5,
    kSvlanFieldNumber = 2,
    kCvlanFieldNumber = 3,
  };
  // string mac_address = 1;
  void clear_mac_address();
  const std::string& mac_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mac_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mac_address();
  PROTOBUF_NODISCARD std::string* release_mac_address();
  void set_allocated_mac_address(std::string* mac_address);
  private:
  const std::string& _internal_mac_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_address(const std::string& value);
  std::string* _internal_mutable_mac_address();
  public:

  // string circuit_id = 4;
  void clear_circuit_id();
  const std::string& circuit_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_circuit_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_circuit_id();
  PROTOBUF_NODISCARD std::string* release_circuit_id();
  void set_allocated_circuit_id(std::string* circuit_id);
  private:
  const std::string& _internal_circuit_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_circuit_id(const std::string& value);
  std::string* _internal_mutable_circuit_id();
  public:

  // string remote_id = 5;
  void clear_remote_id();
  const std::string& remote_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_id();
  PROTOBUF_NODISCARD std::string* release_remote_id();
  void set_allocated_remote_id(std::string* remote_id);
  private:
  const std::string& _internal_remote_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_id(const std::string& value);
  std::string* _internal_mutable_remote_id();
  public:

  // int32 svlan = 2;
  void clear_svlan();
  int32_t svlan() const;
  void set_svlan(int32_t value);
  private:
  int32_t _internal_svlan() const;
  void _internal_set_svlan(int32_t value);
  public:

  // int32 cvlan = 3;
  void clear_cvlan();
  int32_t cvlan() const;
  void set_cvlan(int32_t value);
  private:
  int32_t _internal_cvlan() const;
  void _internal_set_cvlan(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bbf.sss.SessionFilter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr circuit_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_id_;
  int32_t svlan_;
  int32_t cvlan_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sssupsf_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MetaData

// .google.protobuf.Timestamp last_updated = 1;
inline bool MetaData::_internal_has_last_updated() const {
  return this != internal_default_instance() && last_updated_ != nullptr;
}
inline bool MetaData::has_last_updated() const {
  return _internal_has_last_updated();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::_internal_last_updated() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = last_updated_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::last_updated() const {
  // @@protoc_insertion_point(field_get:bbf.sss.MetaData.last_updated)
  return _internal_last_updated();
}
inline void MetaData::unsafe_arena_set_allocated_last_updated(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  last_updated_ = last_updated;
  if (last_updated) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.MetaData.last_updated)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::release_last_updated() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::unsafe_arena_release_last_updated() {
  // @@protoc_insertion_point(field_release:bbf.sss.MetaData.last_updated)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = last_updated_;
  last_updated_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::_internal_mutable_last_updated() {
  
  if (last_updated_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    last_updated_ = p;
  }
  return last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::mutable_last_updated() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_last_updated();
  // @@protoc_insertion_point(field_mutable:bbf.sss.MetaData.last_updated)
  return _msg;
}
inline void MetaData::set_allocated_last_updated(::PROTOBUF_NAMESPACE_ID::Timestamp* last_updated) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated_);
  }
  if (last_updated) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_updated));
    if (message_arena != submessage_arena) {
      last_updated = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_updated, submessage_arena);
    }
    
  } else {
    
  }
  last_updated_ = last_updated;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.MetaData.last_updated)
}

// .google.protobuf.Timestamp created = 2;
inline bool MetaData::_internal_has_created() const {
  return this != internal_default_instance() && created_ != nullptr;
}
inline bool MetaData::has_created() const {
  return _internal_has_created();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::_internal_created() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = created_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::created() const {
  // @@protoc_insertion_point(field_get:bbf.sss.MetaData.created)
  return _internal_created();
}
inline void MetaData::unsafe_arena_set_allocated_created(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  created_ = created;
  if (created) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.MetaData.created)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::release_created() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::unsafe_arena_release_created() {
  // @@protoc_insertion_point(field_release:bbf.sss.MetaData.created)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = created_;
  created_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::_internal_mutable_created() {
  
  if (created_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    created_ = p;
  }
  return created_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::mutable_created() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_created();
  // @@protoc_insertion_point(field_mutable:bbf.sss.MetaData.created)
  return _msg;
}
inline void MetaData::set_allocated_created(::PROTOBUF_NAMESPACE_ID::Timestamp* created) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(created_);
  }
  if (created) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(created));
    if (message_arena != submessage_arena) {
      created = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, created, submessage_arena);
    }
    
  } else {
    
  }
  created_ = created;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.MetaData.created)
}

// .google.protobuf.Timestamp delete_requested = 3;
inline bool MetaData::_internal_has_delete_requested() const {
  return this != internal_default_instance() && delete_requested_ != nullptr;
}
inline bool MetaData::has_delete_requested() const {
  return _internal_has_delete_requested();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::_internal_delete_requested() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = delete_requested_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::delete_requested() const {
  // @@protoc_insertion_point(field_get:bbf.sss.MetaData.delete_requested)
  return _internal_delete_requested();
}
inline void MetaData::unsafe_arena_set_allocated_delete_requested(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* delete_requested) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_requested_);
  }
  delete_requested_ = delete_requested;
  if (delete_requested) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.MetaData.delete_requested)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::release_delete_requested() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = delete_requested_;
  delete_requested_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::unsafe_arena_release_delete_requested() {
  // @@protoc_insertion_point(field_release:bbf.sss.MetaData.delete_requested)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = delete_requested_;
  delete_requested_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::_internal_mutable_delete_requested() {
  
  if (delete_requested_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    delete_requested_ = p;
  }
  return delete_requested_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::mutable_delete_requested() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_delete_requested();
  // @@protoc_insertion_point(field_mutable:bbf.sss.MetaData.delete_requested)
  return _msg;
}
inline void MetaData::set_allocated_delete_requested(::PROTOBUF_NAMESPACE_ID::Timestamp* delete_requested) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_requested_);
  }
  if (delete_requested) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(delete_requested));
    if (message_arena != submessage_arena) {
      delete_requested = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, delete_requested, submessage_arena);
    }
    
  } else {
    
  }
  delete_requested_ = delete_requested;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.MetaData.delete_requested)
}

// .google.protobuf.Timestamp deleted = 4;
inline bool MetaData::_internal_has_deleted() const {
  return this != internal_default_instance() && deleted_ != nullptr;
}
inline bool MetaData::has_deleted() const {
  return _internal_has_deleted();
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::_internal_deleted() const {
  const ::PROTOBUF_NAMESPACE_ID::Timestamp* p = deleted_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Timestamp&>(
      ::PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Timestamp& MetaData::deleted() const {
  // @@protoc_insertion_point(field_get:bbf.sss.MetaData.deleted)
  return _internal_deleted();
}
inline void MetaData::unsafe_arena_set_allocated_deleted(
    ::PROTOBUF_NAMESPACE_ID::Timestamp* deleted) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_);
  }
  deleted_ = deleted;
  if (deleted) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.MetaData.deleted)
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::release_deleted() {
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = deleted_;
  deleted_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::unsafe_arena_release_deleted() {
  // @@protoc_insertion_point(field_release:bbf.sss.MetaData.deleted)
  
  ::PROTOBUF_NAMESPACE_ID::Timestamp* temp = deleted_;
  deleted_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::_internal_mutable_deleted() {
  
  if (deleted_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Timestamp>(GetArenaForAllocation());
    deleted_ = p;
  }
  return deleted_;
}
inline ::PROTOBUF_NAMESPACE_ID::Timestamp* MetaData::mutable_deleted() {
  ::PROTOBUF_NAMESPACE_ID::Timestamp* _msg = _internal_mutable_deleted();
  // @@protoc_insertion_point(field_mutable:bbf.sss.MetaData.deleted)
  return _msg;
}
inline void MetaData::set_allocated_deleted(::PROTOBUF_NAMESPACE_ID::Timestamp* deleted) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted_);
  }
  if (deleted) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deleted));
    if (message_arena != submessage_arena) {
      deleted = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, deleted, submessage_arena);
    }
    
  } else {
    
  }
  deleted_ = deleted;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.MetaData.deleted)
}

// .bbf.sss.ItemStatus item_status = 5;
inline void MetaData::clear_item_status() {
  item_status_ = 0;
}
inline ::bbf::sss::ItemStatus MetaData::_internal_item_status() const {
  return static_cast< ::bbf::sss::ItemStatus >(item_status_);
}
inline ::bbf::sss::ItemStatus MetaData::item_status() const {
  // @@protoc_insertion_point(field_get:bbf.sss.MetaData.item_status)
  return _internal_item_status();
}
inline void MetaData::_internal_set_item_status(::bbf::sss::ItemStatus value) {
  
  item_status_ = value;
}
inline void MetaData::set_item_status(::bbf::sss::ItemStatus value) {
  _internal_set_item_status(value);
  // @@protoc_insertion_point(field_set:bbf.sss.MetaData.item_status)
}

// string name = 6;
inline void MetaData::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& MetaData::name() const {
  // @@protoc_insertion_point(field_get:bbf.sss.MetaData.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MetaData::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.MetaData.name)
}
inline std::string* MetaData::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:bbf.sss.MetaData.name)
  return _s;
}
inline const std::string& MetaData::_internal_name() const {
  return name_.Get();
}
inline void MetaData::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MetaData::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MetaData::release_name() {
  // @@protoc_insertion_point(field_release:bbf.sss.MetaData.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MetaData::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.MetaData.name)
}

// -------------------------------------------------------------------

// ListFilter

// repeated string id_list = 2;
inline int ListFilter::_internal_id_list_size() const {
  return id_list_.size();
}
inline int ListFilter::id_list_size() const {
  return _internal_id_list_size();
}
inline void ListFilter::clear_id_list() {
  id_list_.Clear();
}
inline std::string* ListFilter::add_id_list() {
  std::string* _s = _internal_add_id_list();
  // @@protoc_insertion_point(field_add_mutable:bbf.sss.ListFilter.id_list)
  return _s;
}
inline const std::string& ListFilter::_internal_id_list(int index) const {
  return id_list_.Get(index);
}
inline const std::string& ListFilter::id_list(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListFilter.id_list)
  return _internal_id_list(index);
}
inline std::string* ListFilter::mutable_id_list(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListFilter.id_list)
  return id_list_.Mutable(index);
}
inline void ListFilter::set_id_list(int index, const std::string& value) {
  id_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ListFilter.id_list)
}
inline void ListFilter::set_id_list(int index, std::string&& value) {
  id_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bbf.sss.ListFilter.id_list)
}
inline void ListFilter::set_id_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bbf.sss.ListFilter.id_list)
}
inline void ListFilter::set_id_list(int index, const char* value, size_t size) {
  id_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bbf.sss.ListFilter.id_list)
}
inline std::string* ListFilter::_internal_add_id_list() {
  return id_list_.Add();
}
inline void ListFilter::add_id_list(const std::string& value) {
  id_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bbf.sss.ListFilter.id_list)
}
inline void ListFilter::add_id_list(std::string&& value) {
  id_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bbf.sss.ListFilter.id_list)
}
inline void ListFilter::add_id_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bbf.sss.ListFilter.id_list)
}
inline void ListFilter::add_id_list(const char* value, size_t size) {
  id_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bbf.sss.ListFilter.id_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListFilter::id_list() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ListFilter.id_list)
  return id_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListFilter::mutable_id_list() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ListFilter.id_list)
  return &id_list_;
}

// -------------------------------------------------------------------

// SubscribeReq

// repeated .bbf.sss.SubscribeReq.SubscriptionType subscription = 1;
inline int SubscribeReq::_internal_subscription_size() const {
  return subscription_.size();
}
inline int SubscribeReq::subscription_size() const {
  return _internal_subscription_size();
}
inline void SubscribeReq::clear_subscription() {
  subscription_.Clear();
}
inline ::bbf::sss::SubscribeReq_SubscriptionType SubscribeReq::_internal_subscription(int index) const {
  return static_cast< ::bbf::sss::SubscribeReq_SubscriptionType >(subscription_.Get(index));
}
inline ::bbf::sss::SubscribeReq_SubscriptionType SubscribeReq::subscription(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.SubscribeReq.subscription)
  return _internal_subscription(index);
}
inline void SubscribeReq::set_subscription(int index, ::bbf::sss::SubscribeReq_SubscriptionType value) {
  subscription_.Set(index, value);
  // @@protoc_insertion_point(field_set:bbf.sss.SubscribeReq.subscription)
}
inline void SubscribeReq::_internal_add_subscription(::bbf::sss::SubscribeReq_SubscriptionType value) {
  subscription_.Add(value);
}
inline void SubscribeReq::add_subscription(::bbf::sss::SubscribeReq_SubscriptionType value) {
  _internal_add_subscription(value);
  // @@protoc_insertion_point(field_add:bbf.sss.SubscribeReq.subscription)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
SubscribeReq::subscription() const {
  // @@protoc_insertion_point(field_list:bbf.sss.SubscribeReq.subscription)
  return subscription_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SubscribeReq::_internal_mutable_subscription() {
  return &subscription_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
SubscribeReq::mutable_subscription() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.SubscribeReq.subscription)
  return _internal_mutable_subscription();
}

// repeated string id_list = 2;
inline int SubscribeReq::_internal_id_list_size() const {
  return id_list_.size();
}
inline int SubscribeReq::id_list_size() const {
  return _internal_id_list_size();
}
inline void SubscribeReq::clear_id_list() {
  id_list_.Clear();
}
inline std::string* SubscribeReq::add_id_list() {
  std::string* _s = _internal_add_id_list();
  // @@protoc_insertion_point(field_add_mutable:bbf.sss.SubscribeReq.id_list)
  return _s;
}
inline const std::string& SubscribeReq::_internal_id_list(int index) const {
  return id_list_.Get(index);
}
inline const std::string& SubscribeReq::id_list(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.SubscribeReq.id_list)
  return _internal_id_list(index);
}
inline std::string* SubscribeReq::mutable_id_list(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.SubscribeReq.id_list)
  return id_list_.Mutable(index);
}
inline void SubscribeReq::set_id_list(int index, const std::string& value) {
  id_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bbf.sss.SubscribeReq.id_list)
}
inline void SubscribeReq::set_id_list(int index, std::string&& value) {
  id_list_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bbf.sss.SubscribeReq.id_list)
}
inline void SubscribeReq::set_id_list(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bbf.sss.SubscribeReq.id_list)
}
inline void SubscribeReq::set_id_list(int index, const char* value, size_t size) {
  id_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bbf.sss.SubscribeReq.id_list)
}
inline std::string* SubscribeReq::_internal_add_id_list() {
  return id_list_.Add();
}
inline void SubscribeReq::add_id_list(const std::string& value) {
  id_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bbf.sss.SubscribeReq.id_list)
}
inline void SubscribeReq::add_id_list(std::string&& value) {
  id_list_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bbf.sss.SubscribeReq.id_list)
}
inline void SubscribeReq::add_id_list(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  id_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bbf.sss.SubscribeReq.id_list)
}
inline void SubscribeReq::add_id_list(const char* value, size_t size) {
  id_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bbf.sss.SubscribeReq.id_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SubscribeReq::id_list() const {
  // @@protoc_insertion_point(field_list:bbf.sss.SubscribeReq.id_list)
  return id_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SubscribeReq::mutable_id_list() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.SubscribeReq.id_list)
  return &id_list_;
}

// -------------------------------------------------------------------

// Update

// .bbf.sss.Shard shard = 1;
inline bool Update::_internal_has_shard() const {
  return item_case() == kShard;
}
inline bool Update::has_shard() const {
  return _internal_has_shard();
}
inline void Update::set_has_shard() {
  _oneof_case_[0] = kShard;
}
inline void Update::clear_shard() {
  if (_internal_has_shard()) {
    if (GetArenaForAllocation() == nullptr) {
      delete item_.shard_;
    }
    clear_has_item();
  }
}
inline ::bbf::sss::Shard* Update::release_shard() {
  // @@protoc_insertion_point(field_release:bbf.sss.Update.shard)
  if (_internal_has_shard()) {
    clear_has_item();
      ::bbf::sss::Shard* temp = item_.shard_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    item_.shard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bbf::sss::Shard& Update::_internal_shard() const {
  return _internal_has_shard()
      ? *item_.shard_
      : reinterpret_cast< ::bbf::sss::Shard&>(::bbf::sss::_Shard_default_instance_);
}
inline const ::bbf::sss::Shard& Update::shard() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Update.shard)
  return _internal_shard();
}
inline ::bbf::sss::Shard* Update::unsafe_arena_release_shard() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bbf.sss.Update.shard)
  if (_internal_has_shard()) {
    clear_has_item();
    ::bbf::sss::Shard* temp = item_.shard_;
    item_.shard_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Update::unsafe_arena_set_allocated_shard(::bbf::sss::Shard* shard) {
  clear_item();
  if (shard) {
    set_has_shard();
    item_.shard_ = shard;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Update.shard)
}
inline ::bbf::sss::Shard* Update::_internal_mutable_shard() {
  if (!_internal_has_shard()) {
    clear_item();
    set_has_shard();
    item_.shard_ = CreateMaybeMessage< ::bbf::sss::Shard >(GetArenaForAllocation());
  }
  return item_.shard_;
}
inline ::bbf::sss::Shard* Update::mutable_shard() {
  ::bbf::sss::Shard* _msg = _internal_mutable_shard();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Update.shard)
  return _msg;
}

// .bbf.sss.SessionContext session_context = 2;
inline bool Update::_internal_has_session_context() const {
  return item_case() == kSessionContext;
}
inline bool Update::has_session_context() const {
  return _internal_has_session_context();
}
inline void Update::set_has_session_context() {
  _oneof_case_[0] = kSessionContext;
}
inline void Update::clear_session_context() {
  if (_internal_has_session_context()) {
    if (GetArenaForAllocation() == nullptr) {
      delete item_.session_context_;
    }
    clear_has_item();
  }
}
inline ::bbf::sss::SessionContext* Update::release_session_context() {
  // @@protoc_insertion_point(field_release:bbf.sss.Update.session_context)
  if (_internal_has_session_context()) {
    clear_has_item();
      ::bbf::sss::SessionContext* temp = item_.session_context_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    item_.session_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bbf::sss::SessionContext& Update::_internal_session_context() const {
  return _internal_has_session_context()
      ? *item_.session_context_
      : reinterpret_cast< ::bbf::sss::SessionContext&>(::bbf::sss::_SessionContext_default_instance_);
}
inline const ::bbf::sss::SessionContext& Update::session_context() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Update.session_context)
  return _internal_session_context();
}
inline ::bbf::sss::SessionContext* Update::unsafe_arena_release_session_context() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bbf.sss.Update.session_context)
  if (_internal_has_session_context()) {
    clear_has_item();
    ::bbf::sss::SessionContext* temp = item_.session_context_;
    item_.session_context_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Update::unsafe_arena_set_allocated_session_context(::bbf::sss::SessionContext* session_context) {
  clear_item();
  if (session_context) {
    set_has_session_context();
    item_.session_context_ = session_context;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Update.session_context)
}
inline ::bbf::sss::SessionContext* Update::_internal_mutable_session_context() {
  if (!_internal_has_session_context()) {
    clear_item();
    set_has_session_context();
    item_.session_context_ = CreateMaybeMessage< ::bbf::sss::SessionContext >(GetArenaForAllocation());
  }
  return item_.session_context_;
}
inline ::bbf::sss::SessionContext* Update::mutable_session_context() {
  ::bbf::sss::SessionContext* _msg = _internal_mutable_session_context();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Update.session_context)
  return _msg;
}

// .bbf.sss.NetworkConnection network_connection = 3;
inline bool Update::_internal_has_network_connection() const {
  return item_case() == kNetworkConnection;
}
inline bool Update::has_network_connection() const {
  return _internal_has_network_connection();
}
inline void Update::set_has_network_connection() {
  _oneof_case_[0] = kNetworkConnection;
}
inline void Update::clear_network_connection() {
  if (_internal_has_network_connection()) {
    if (GetArenaForAllocation() == nullptr) {
      delete item_.network_connection_;
    }
    clear_has_item();
  }
}
inline ::bbf::sss::NetworkConnection* Update::release_network_connection() {
  // @@protoc_insertion_point(field_release:bbf.sss.Update.network_connection)
  if (_internal_has_network_connection()) {
    clear_has_item();
      ::bbf::sss::NetworkConnection* temp = item_.network_connection_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    item_.network_connection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bbf::sss::NetworkConnection& Update::_internal_network_connection() const {
  return _internal_has_network_connection()
      ? *item_.network_connection_
      : reinterpret_cast< ::bbf::sss::NetworkConnection&>(::bbf::sss::_NetworkConnection_default_instance_);
}
inline const ::bbf::sss::NetworkConnection& Update::network_connection() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Update.network_connection)
  return _internal_network_connection();
}
inline ::bbf::sss::NetworkConnection* Update::unsafe_arena_release_network_connection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bbf.sss.Update.network_connection)
  if (_internal_has_network_connection()) {
    clear_has_item();
    ::bbf::sss::NetworkConnection* temp = item_.network_connection_;
    item_.network_connection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Update::unsafe_arena_set_allocated_network_connection(::bbf::sss::NetworkConnection* network_connection) {
  clear_item();
  if (network_connection) {
    set_has_network_connection();
    item_.network_connection_ = network_connection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Update.network_connection)
}
inline ::bbf::sss::NetworkConnection* Update::_internal_mutable_network_connection() {
  if (!_internal_has_network_connection()) {
    clear_item();
    set_has_network_connection();
    item_.network_connection_ = CreateMaybeMessage< ::bbf::sss::NetworkConnection >(GetArenaForAllocation());
  }
  return item_.network_connection_;
}
inline ::bbf::sss::NetworkConnection* Update::mutable_network_connection() {
  ::bbf::sss::NetworkConnection* _msg = _internal_mutable_network_connection();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Update.network_connection)
  return _msg;
}

// .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 4;
inline bool Update::_internal_has_service_gateway_user_plane() const {
  return item_case() == kServiceGatewayUserPlane;
}
inline bool Update::has_service_gateway_user_plane() const {
  return _internal_has_service_gateway_user_plane();
}
inline void Update::set_has_service_gateway_user_plane() {
  _oneof_case_[0] = kServiceGatewayUserPlane;
}
inline void Update::clear_service_gateway_user_plane() {
  if (_internal_has_service_gateway_user_plane()) {
    if (GetArenaForAllocation() == nullptr) {
      delete item_.service_gateway_user_plane_;
    }
    clear_has_item();
  }
}
inline ::bbf::sss::ServiceGatewayUserPlane* Update::release_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_release:bbf.sss.Update.service_gateway_user_plane)
  if (_internal_has_service_gateway_user_plane()) {
    clear_has_item();
      ::bbf::sss::ServiceGatewayUserPlane* temp = item_.service_gateway_user_plane_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    item_.service_gateway_user_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bbf::sss::ServiceGatewayUserPlane& Update::_internal_service_gateway_user_plane() const {
  return _internal_has_service_gateway_user_plane()
      ? *item_.service_gateway_user_plane_
      : reinterpret_cast< ::bbf::sss::ServiceGatewayUserPlane&>(::bbf::sss::_ServiceGatewayUserPlane_default_instance_);
}
inline const ::bbf::sss::ServiceGatewayUserPlane& Update::service_gateway_user_plane() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Update.service_gateway_user_plane)
  return _internal_service_gateway_user_plane();
}
inline ::bbf::sss::ServiceGatewayUserPlane* Update::unsafe_arena_release_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bbf.sss.Update.service_gateway_user_plane)
  if (_internal_has_service_gateway_user_plane()) {
    clear_has_item();
    ::bbf::sss::ServiceGatewayUserPlane* temp = item_.service_gateway_user_plane_;
    item_.service_gateway_user_plane_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Update::unsafe_arena_set_allocated_service_gateway_user_plane(::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane) {
  clear_item();
  if (service_gateway_user_plane) {
    set_has_service_gateway_user_plane();
    item_.service_gateway_user_plane_ = service_gateway_user_plane;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Update.service_gateway_user_plane)
}
inline ::bbf::sss::ServiceGatewayUserPlane* Update::_internal_mutable_service_gateway_user_plane() {
  if (!_internal_has_service_gateway_user_plane()) {
    clear_item();
    set_has_service_gateway_user_plane();
    item_.service_gateway_user_plane_ = CreateMaybeMessage< ::bbf::sss::ServiceGatewayUserPlane >(GetArenaForAllocation());
  }
  return item_.service_gateway_user_plane_;
}
inline ::bbf::sss::ServiceGatewayUserPlane* Update::mutable_service_gateway_user_plane() {
  ::bbf::sss::ServiceGatewayUserPlane* _msg = _internal_mutable_service_gateway_user_plane();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Update.service_gateway_user_plane)
  return _msg;
}

// .bbf.sss.TrafficSteeringFunction traffic_steering_function = 5;
inline bool Update::_internal_has_traffic_steering_function() const {
  return item_case() == kTrafficSteeringFunction;
}
inline bool Update::has_traffic_steering_function() const {
  return _internal_has_traffic_steering_function();
}
inline void Update::set_has_traffic_steering_function() {
  _oneof_case_[0] = kTrafficSteeringFunction;
}
inline void Update::clear_traffic_steering_function() {
  if (_internal_has_traffic_steering_function()) {
    if (GetArenaForAllocation() == nullptr) {
      delete item_.traffic_steering_function_;
    }
    clear_has_item();
  }
}
inline ::bbf::sss::TrafficSteeringFunction* Update::release_traffic_steering_function() {
  // @@protoc_insertion_point(field_release:bbf.sss.Update.traffic_steering_function)
  if (_internal_has_traffic_steering_function()) {
    clear_has_item();
      ::bbf::sss::TrafficSteeringFunction* temp = item_.traffic_steering_function_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    item_.traffic_steering_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bbf::sss::TrafficSteeringFunction& Update::_internal_traffic_steering_function() const {
  return _internal_has_traffic_steering_function()
      ? *item_.traffic_steering_function_
      : reinterpret_cast< ::bbf::sss::TrafficSteeringFunction&>(::bbf::sss::_TrafficSteeringFunction_default_instance_);
}
inline const ::bbf::sss::TrafficSteeringFunction& Update::traffic_steering_function() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Update.traffic_steering_function)
  return _internal_traffic_steering_function();
}
inline ::bbf::sss::TrafficSteeringFunction* Update::unsafe_arena_release_traffic_steering_function() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bbf.sss.Update.traffic_steering_function)
  if (_internal_has_traffic_steering_function()) {
    clear_has_item();
    ::bbf::sss::TrafficSteeringFunction* temp = item_.traffic_steering_function_;
    item_.traffic_steering_function_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Update::unsafe_arena_set_allocated_traffic_steering_function(::bbf::sss::TrafficSteeringFunction* traffic_steering_function) {
  clear_item();
  if (traffic_steering_function) {
    set_has_traffic_steering_function();
    item_.traffic_steering_function_ = traffic_steering_function;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Update.traffic_steering_function)
}
inline ::bbf::sss::TrafficSteeringFunction* Update::_internal_mutable_traffic_steering_function() {
  if (!_internal_has_traffic_steering_function()) {
    clear_item();
    set_has_traffic_steering_function();
    item_.traffic_steering_function_ = CreateMaybeMessage< ::bbf::sss::TrafficSteeringFunction >(GetArenaForAllocation());
  }
  return item_.traffic_steering_function_;
}
inline ::bbf::sss::TrafficSteeringFunction* Update::mutable_traffic_steering_function() {
  ::bbf::sss::TrafficSteeringFunction* _msg = _internal_mutable_traffic_steering_function();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Update.traffic_steering_function)
  return _msg;
}

// .bbf.sss.ServiceGateway service_gateway = 6;
inline bool Update::_internal_has_service_gateway() const {
  return item_case() == kServiceGateway;
}
inline bool Update::has_service_gateway() const {
  return _internal_has_service_gateway();
}
inline void Update::set_has_service_gateway() {
  _oneof_case_[0] = kServiceGateway;
}
inline void Update::clear_service_gateway() {
  if (_internal_has_service_gateway()) {
    if (GetArenaForAllocation() == nullptr) {
      delete item_.service_gateway_;
    }
    clear_has_item();
  }
}
inline ::bbf::sss::ServiceGateway* Update::release_service_gateway() {
  // @@protoc_insertion_point(field_release:bbf.sss.Update.service_gateway)
  if (_internal_has_service_gateway()) {
    clear_has_item();
      ::bbf::sss::ServiceGateway* temp = item_.service_gateway_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    item_.service_gateway_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bbf::sss::ServiceGateway& Update::_internal_service_gateway() const {
  return _internal_has_service_gateway()
      ? *item_.service_gateway_
      : reinterpret_cast< ::bbf::sss::ServiceGateway&>(::bbf::sss::_ServiceGateway_default_instance_);
}
inline const ::bbf::sss::ServiceGateway& Update::service_gateway() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Update.service_gateway)
  return _internal_service_gateway();
}
inline ::bbf::sss::ServiceGateway* Update::unsafe_arena_release_service_gateway() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bbf.sss.Update.service_gateway)
  if (_internal_has_service_gateway()) {
    clear_has_item();
    ::bbf::sss::ServiceGateway* temp = item_.service_gateway_;
    item_.service_gateway_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Update::unsafe_arena_set_allocated_service_gateway(::bbf::sss::ServiceGateway* service_gateway) {
  clear_item();
  if (service_gateway) {
    set_has_service_gateway();
    item_.service_gateway_ = service_gateway;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Update.service_gateway)
}
inline ::bbf::sss::ServiceGateway* Update::_internal_mutable_service_gateway() {
  if (!_internal_has_service_gateway()) {
    clear_item();
    set_has_service_gateway();
    item_.service_gateway_ = CreateMaybeMessage< ::bbf::sss::ServiceGateway >(GetArenaForAllocation());
  }
  return item_.service_gateway_;
}
inline ::bbf::sss::ServiceGateway* Update::mutable_service_gateway() {
  ::bbf::sss::ServiceGateway* _msg = _internal_mutable_service_gateway();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Update.service_gateway)
  return _msg;
}

inline bool Update::has_item() const {
  return item_case() != ITEM_NOT_SET;
}
inline void Update::clear_has_item() {
  _oneof_case_[0] = ITEM_NOT_SET;
}
inline Update::ItemCase Update::item_case() const {
  return Update::ItemCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// LookupReq

// .bbf.sss.SessionContext.Spec spec = 2;
inline bool LookupReq::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool LookupReq::has_spec() const {
  return _internal_has_spec();
}
inline void LookupReq::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::bbf::sss::SessionContext_Spec& LookupReq::_internal_spec() const {
  const ::bbf::sss::SessionContext_Spec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::SessionContext_Spec&>(
      ::bbf::sss::_SessionContext_Spec_default_instance_);
}
inline const ::bbf::sss::SessionContext_Spec& LookupReq::spec() const {
  // @@protoc_insertion_point(field_get:bbf.sss.LookupReq.spec)
  return _internal_spec();
}
inline void LookupReq::unsafe_arena_set_allocated_spec(
    ::bbf::sss::SessionContext_Spec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.LookupReq.spec)
}
inline ::bbf::sss::SessionContext_Spec* LookupReq::release_spec() {
  
  ::bbf::sss::SessionContext_Spec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::SessionContext_Spec* LookupReq::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bbf.sss.LookupReq.spec)
  
  ::bbf::sss::SessionContext_Spec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::bbf::sss::SessionContext_Spec* LookupReq::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::SessionContext_Spec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::bbf::sss::SessionContext_Spec* LookupReq::mutable_spec() {
  ::bbf::sss::SessionContext_Spec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bbf.sss.LookupReq.spec)
  return _msg;
}
inline void LookupReq::set_allocated_spec(::bbf::sss::SessionContext_Spec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::SessionContext_Spec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.LookupReq.spec)
}

// -------------------------------------------------------------------

// LookupResp

// .bbf.sss.Result result = 1;
inline void LookupResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result LookupResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result LookupResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.LookupResp.result)
  return _internal_result();
}
inline void LookupResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void LookupResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.LookupResp.result)
}

// .bbf.sss.SessionContext session_context = 2;
inline bool LookupResp::_internal_has_session_context() const {
  return this != internal_default_instance() && session_context_ != nullptr;
}
inline bool LookupResp::has_session_context() const {
  return _internal_has_session_context();
}
inline void LookupResp::clear_session_context() {
  if (GetArenaForAllocation() == nullptr && session_context_ != nullptr) {
    delete session_context_;
  }
  session_context_ = nullptr;
}
inline const ::bbf::sss::SessionContext& LookupResp::_internal_session_context() const {
  const ::bbf::sss::SessionContext* p = session_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::SessionContext&>(
      ::bbf::sss::_SessionContext_default_instance_);
}
inline const ::bbf::sss::SessionContext& LookupResp::session_context() const {
  // @@protoc_insertion_point(field_get:bbf.sss.LookupResp.session_context)
  return _internal_session_context();
}
inline void LookupResp::unsafe_arena_set_allocated_session_context(
    ::bbf::sss::SessionContext* session_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_context_);
  }
  session_context_ = session_context;
  if (session_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.LookupResp.session_context)
}
inline ::bbf::sss::SessionContext* LookupResp::release_session_context() {
  
  ::bbf::sss::SessionContext* temp = session_context_;
  session_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::SessionContext* LookupResp::unsafe_arena_release_session_context() {
  // @@protoc_insertion_point(field_release:bbf.sss.LookupResp.session_context)
  
  ::bbf::sss::SessionContext* temp = session_context_;
  session_context_ = nullptr;
  return temp;
}
inline ::bbf::sss::SessionContext* LookupResp::_internal_mutable_session_context() {
  
  if (session_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::SessionContext>(GetArenaForAllocation());
    session_context_ = p;
  }
  return session_context_;
}
inline ::bbf::sss::SessionContext* LookupResp::mutable_session_context() {
  ::bbf::sss::SessionContext* _msg = _internal_mutable_session_context();
  // @@protoc_insertion_point(field_mutable:bbf.sss.LookupResp.session_context)
  return _msg;
}
inline void LookupResp::set_allocated_session_context(::bbf::sss::SessionContext* session_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_context_;
  }
  if (session_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::SessionContext>::GetOwningArena(session_context);
    if (message_arena != submessage_arena) {
      session_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_context, submessage_arena);
    }
    
  } else {
    
  }
  session_context_ = session_context;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.LookupResp.session_context)
}

// -------------------------------------------------------------------

// UpdateServiceGatewayReq

// .bbf.sss.ServiceGateway service_gateway = 1;
inline bool UpdateServiceGatewayReq::_internal_has_service_gateway() const {
  return this != internal_default_instance() && service_gateway_ != nullptr;
}
inline bool UpdateServiceGatewayReq::has_service_gateway() const {
  return _internal_has_service_gateway();
}
inline void UpdateServiceGatewayReq::clear_service_gateway() {
  if (GetArenaForAllocation() == nullptr && service_gateway_ != nullptr) {
    delete service_gateway_;
  }
  service_gateway_ = nullptr;
}
inline const ::bbf::sss::ServiceGateway& UpdateServiceGatewayReq::_internal_service_gateway() const {
  const ::bbf::sss::ServiceGateway* p = service_gateway_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ServiceGateway&>(
      ::bbf::sss::_ServiceGateway_default_instance_);
}
inline const ::bbf::sss::ServiceGateway& UpdateServiceGatewayReq::service_gateway() const {
  // @@protoc_insertion_point(field_get:bbf.sss.UpdateServiceGatewayReq.service_gateway)
  return _internal_service_gateway();
}
inline void UpdateServiceGatewayReq::unsafe_arena_set_allocated_service_gateway(
    ::bbf::sss::ServiceGateway* service_gateway) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_gateway_);
  }
  service_gateway_ = service_gateway;
  if (service_gateway) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.UpdateServiceGatewayReq.service_gateway)
}
inline ::bbf::sss::ServiceGateway* UpdateServiceGatewayReq::release_service_gateway() {
  
  ::bbf::sss::ServiceGateway* temp = service_gateway_;
  service_gateway_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ServiceGateway* UpdateServiceGatewayReq::unsafe_arena_release_service_gateway() {
  // @@protoc_insertion_point(field_release:bbf.sss.UpdateServiceGatewayReq.service_gateway)
  
  ::bbf::sss::ServiceGateway* temp = service_gateway_;
  service_gateway_ = nullptr;
  return temp;
}
inline ::bbf::sss::ServiceGateway* UpdateServiceGatewayReq::_internal_mutable_service_gateway() {
  
  if (service_gateway_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ServiceGateway>(GetArenaForAllocation());
    service_gateway_ = p;
  }
  return service_gateway_;
}
inline ::bbf::sss::ServiceGateway* UpdateServiceGatewayReq::mutable_service_gateway() {
  ::bbf::sss::ServiceGateway* _msg = _internal_mutable_service_gateway();
  // @@protoc_insertion_point(field_mutable:bbf.sss.UpdateServiceGatewayReq.service_gateway)
  return _msg;
}
inline void UpdateServiceGatewayReq::set_allocated_service_gateway(::bbf::sss::ServiceGateway* service_gateway) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_gateway_;
  }
  if (service_gateway) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ServiceGateway>::GetOwningArena(service_gateway);
    if (message_arena != submessage_arena) {
      service_gateway = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_gateway, submessage_arena);
    }
    
  } else {
    
  }
  service_gateway_ = service_gateway;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.UpdateServiceGatewayReq.service_gateway)
}

// -------------------------------------------------------------------

// DeleteServiceGatewayReq

// string id = 1;
inline void DeleteServiceGatewayReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteServiceGatewayReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.DeleteServiceGatewayReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteServiceGatewayReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.DeleteServiceGatewayReq.id)
}
inline std::string* DeleteServiceGatewayReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.DeleteServiceGatewayReq.id)
  return _s;
}
inline const std::string& DeleteServiceGatewayReq::_internal_id() const {
  return id_.Get();
}
inline void DeleteServiceGatewayReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteServiceGatewayReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteServiceGatewayReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.DeleteServiceGatewayReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteServiceGatewayReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.DeleteServiceGatewayReq.id)
}

// -------------------------------------------------------------------

// GetServiceGatewayReq

// string id = 1;
inline void GetServiceGatewayReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetServiceGatewayReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.GetServiceGatewayReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceGatewayReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.GetServiceGatewayReq.id)
}
inline std::string* GetServiceGatewayReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.GetServiceGatewayReq.id)
  return _s;
}
inline const std::string& GetServiceGatewayReq::_internal_id() const {
  return id_.Get();
}
inline void GetServiceGatewayReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetServiceGatewayReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetServiceGatewayReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.GetServiceGatewayReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetServiceGatewayReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.GetServiceGatewayReq.id)
}

// -------------------------------------------------------------------

// ServiceGatewayResp

// .bbf.sss.Result result = 1;
inline void ServiceGatewayResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ServiceGatewayResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ServiceGatewayResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayResp.result)
  return _internal_result();
}
inline void ServiceGatewayResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ServiceGatewayResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayResp.result)
}

// .bbf.sss.ServiceGateway service_gateway = 2;
inline bool ServiceGatewayResp::_internal_has_service_gateway() const {
  return this != internal_default_instance() && service_gateway_ != nullptr;
}
inline bool ServiceGatewayResp::has_service_gateway() const {
  return _internal_has_service_gateway();
}
inline void ServiceGatewayResp::clear_service_gateway() {
  if (GetArenaForAllocation() == nullptr && service_gateway_ != nullptr) {
    delete service_gateway_;
  }
  service_gateway_ = nullptr;
}
inline const ::bbf::sss::ServiceGateway& ServiceGatewayResp::_internal_service_gateway() const {
  const ::bbf::sss::ServiceGateway* p = service_gateway_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ServiceGateway&>(
      ::bbf::sss::_ServiceGateway_default_instance_);
}
inline const ::bbf::sss::ServiceGateway& ServiceGatewayResp::service_gateway() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayResp.service_gateway)
  return _internal_service_gateway();
}
inline void ServiceGatewayResp::unsafe_arena_set_allocated_service_gateway(
    ::bbf::sss::ServiceGateway* service_gateway) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_gateway_);
  }
  service_gateway_ = service_gateway;
  if (service_gateway) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ServiceGatewayResp.service_gateway)
}
inline ::bbf::sss::ServiceGateway* ServiceGatewayResp::release_service_gateway() {
  
  ::bbf::sss::ServiceGateway* temp = service_gateway_;
  service_gateway_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ServiceGateway* ServiceGatewayResp::unsafe_arena_release_service_gateway() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayResp.service_gateway)
  
  ::bbf::sss::ServiceGateway* temp = service_gateway_;
  service_gateway_ = nullptr;
  return temp;
}
inline ::bbf::sss::ServiceGateway* ServiceGatewayResp::_internal_mutable_service_gateway() {
  
  if (service_gateway_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ServiceGateway>(GetArenaForAllocation());
    service_gateway_ = p;
  }
  return service_gateway_;
}
inline ::bbf::sss::ServiceGateway* ServiceGatewayResp::mutable_service_gateway() {
  ::bbf::sss::ServiceGateway* _msg = _internal_mutable_service_gateway();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayResp.service_gateway)
  return _msg;
}
inline void ServiceGatewayResp::set_allocated_service_gateway(::bbf::sss::ServiceGateway* service_gateway) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_gateway_;
  }
  if (service_gateway) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ServiceGateway>::GetOwningArena(service_gateway);
    if (message_arena != submessage_arena) {
      service_gateway = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_gateway, submessage_arena);
    }
    
  } else {
    
  }
  service_gateway_ = service_gateway;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayResp.service_gateway)
}

// -------------------------------------------------------------------

// ListServiceGatewayReq

// .bbf.sss.ListFilter filter = 1;
inline bool ListServiceGatewayReq::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListServiceGatewayReq::has_filter() const {
  return _internal_has_filter();
}
inline void ListServiceGatewayReq::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::bbf::sss::ListFilter& ListServiceGatewayReq::_internal_filter() const {
  const ::bbf::sss::ListFilter* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ListFilter&>(
      ::bbf::sss::_ListFilter_default_instance_);
}
inline const ::bbf::sss::ListFilter& ListServiceGatewayReq::filter() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListServiceGatewayReq.filter)
  return _internal_filter();
}
inline void ListServiceGatewayReq::unsafe_arena_set_allocated_filter(
    ::bbf::sss::ListFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ListServiceGatewayReq.filter)
}
inline ::bbf::sss::ListFilter* ListServiceGatewayReq::release_filter() {
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ListFilter* ListServiceGatewayReq::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:bbf.sss.ListServiceGatewayReq.filter)
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::bbf::sss::ListFilter* ListServiceGatewayReq::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ListFilter>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::bbf::sss::ListFilter* ListServiceGatewayReq::mutable_filter() {
  ::bbf::sss::ListFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListServiceGatewayReq.filter)
  return _msg;
}
inline void ListServiceGatewayReq::set_allocated_filter(::bbf::sss::ListFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ListFilter>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ListServiceGatewayReq.filter)
}

// -------------------------------------------------------------------

// ListServiceGatewayResp

// .bbf.sss.Result result = 1;
inline void ListServiceGatewayResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ListServiceGatewayResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ListServiceGatewayResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListServiceGatewayResp.result)
  return _internal_result();
}
inline void ListServiceGatewayResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ListServiceGatewayResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ListServiceGatewayResp.result)
}

// repeated .bbf.sss.ServiceGateway service_gateway = 2;
inline int ListServiceGatewayResp::_internal_service_gateway_size() const {
  return service_gateway_.size();
}
inline int ListServiceGatewayResp::service_gateway_size() const {
  return _internal_service_gateway_size();
}
inline void ListServiceGatewayResp::clear_service_gateway() {
  service_gateway_.Clear();
}
inline ::bbf::sss::ServiceGateway* ListServiceGatewayResp::mutable_service_gateway(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListServiceGatewayResp.service_gateway)
  return service_gateway_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGateway >*
ListServiceGatewayResp::mutable_service_gateway() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ListServiceGatewayResp.service_gateway)
  return &service_gateway_;
}
inline const ::bbf::sss::ServiceGateway& ListServiceGatewayResp::_internal_service_gateway(int index) const {
  return service_gateway_.Get(index);
}
inline const ::bbf::sss::ServiceGateway& ListServiceGatewayResp::service_gateway(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListServiceGatewayResp.service_gateway)
  return _internal_service_gateway(index);
}
inline ::bbf::sss::ServiceGateway* ListServiceGatewayResp::_internal_add_service_gateway() {
  return service_gateway_.Add();
}
inline ::bbf::sss::ServiceGateway* ListServiceGatewayResp::add_service_gateway() {
  ::bbf::sss::ServiceGateway* _add = _internal_add_service_gateway();
  // @@protoc_insertion_point(field_add:bbf.sss.ListServiceGatewayResp.service_gateway)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGateway >&
ListServiceGatewayResp::service_gateway() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ListServiceGatewayResp.service_gateway)
  return service_gateway_;
}

// -------------------------------------------------------------------

// UpdateShardReq

// .bbf.sss.Shard shard = 1;
inline bool UpdateShardReq::_internal_has_shard() const {
  return this != internal_default_instance() && shard_ != nullptr;
}
inline bool UpdateShardReq::has_shard() const {
  return _internal_has_shard();
}
inline void UpdateShardReq::clear_shard() {
  if (GetArenaForAllocation() == nullptr && shard_ != nullptr) {
    delete shard_;
  }
  shard_ = nullptr;
}
inline const ::bbf::sss::Shard& UpdateShardReq::_internal_shard() const {
  const ::bbf::sss::Shard* p = shard_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::Shard&>(
      ::bbf::sss::_Shard_default_instance_);
}
inline const ::bbf::sss::Shard& UpdateShardReq::shard() const {
  // @@protoc_insertion_point(field_get:bbf.sss.UpdateShardReq.shard)
  return _internal_shard();
}
inline void UpdateShardReq::unsafe_arena_set_allocated_shard(
    ::bbf::sss::Shard* shard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shard_);
  }
  shard_ = shard;
  if (shard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.UpdateShardReq.shard)
}
inline ::bbf::sss::Shard* UpdateShardReq::release_shard() {
  
  ::bbf::sss::Shard* temp = shard_;
  shard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::Shard* UpdateShardReq::unsafe_arena_release_shard() {
  // @@protoc_insertion_point(field_release:bbf.sss.UpdateShardReq.shard)
  
  ::bbf::sss::Shard* temp = shard_;
  shard_ = nullptr;
  return temp;
}
inline ::bbf::sss::Shard* UpdateShardReq::_internal_mutable_shard() {
  
  if (shard_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::Shard>(GetArenaForAllocation());
    shard_ = p;
  }
  return shard_;
}
inline ::bbf::sss::Shard* UpdateShardReq::mutable_shard() {
  ::bbf::sss::Shard* _msg = _internal_mutable_shard();
  // @@protoc_insertion_point(field_mutable:bbf.sss.UpdateShardReq.shard)
  return _msg;
}
inline void UpdateShardReq::set_allocated_shard(::bbf::sss::Shard* shard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shard_;
  }
  if (shard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::Shard>::GetOwningArena(shard);
    if (message_arena != submessage_arena) {
      shard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shard, submessage_arena);
    }
    
  } else {
    
  }
  shard_ = shard;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.UpdateShardReq.shard)
}

// -------------------------------------------------------------------

// DeleteShardReq

// string id = 1;
inline void DeleteShardReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteShardReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.DeleteShardReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteShardReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.DeleteShardReq.id)
}
inline std::string* DeleteShardReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.DeleteShardReq.id)
  return _s;
}
inline const std::string& DeleteShardReq::_internal_id() const {
  return id_.Get();
}
inline void DeleteShardReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteShardReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteShardReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.DeleteShardReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteShardReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.DeleteShardReq.id)
}

// -------------------------------------------------------------------

// GetShardReq

// string id = 1;
inline void GetShardReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetShardReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.GetShardReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetShardReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.GetShardReq.id)
}
inline std::string* GetShardReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.GetShardReq.id)
  return _s;
}
inline const std::string& GetShardReq::_internal_id() const {
  return id_.Get();
}
inline void GetShardReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetShardReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetShardReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.GetShardReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetShardReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.GetShardReq.id)
}

// -------------------------------------------------------------------

// ShardResp

// .bbf.sss.Result result = 1;
inline void ShardResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ShardResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ShardResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ShardResp.result)
  return _internal_result();
}
inline void ShardResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ShardResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ShardResp.result)
}

// .bbf.sss.Shard shard = 2;
inline bool ShardResp::_internal_has_shard() const {
  return this != internal_default_instance() && shard_ != nullptr;
}
inline bool ShardResp::has_shard() const {
  return _internal_has_shard();
}
inline void ShardResp::clear_shard() {
  if (GetArenaForAllocation() == nullptr && shard_ != nullptr) {
    delete shard_;
  }
  shard_ = nullptr;
}
inline const ::bbf::sss::Shard& ShardResp::_internal_shard() const {
  const ::bbf::sss::Shard* p = shard_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::Shard&>(
      ::bbf::sss::_Shard_default_instance_);
}
inline const ::bbf::sss::Shard& ShardResp::shard() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ShardResp.shard)
  return _internal_shard();
}
inline void ShardResp::unsafe_arena_set_allocated_shard(
    ::bbf::sss::Shard* shard) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(shard_);
  }
  shard_ = shard;
  if (shard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ShardResp.shard)
}
inline ::bbf::sss::Shard* ShardResp::release_shard() {
  
  ::bbf::sss::Shard* temp = shard_;
  shard_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::Shard* ShardResp::unsafe_arena_release_shard() {
  // @@protoc_insertion_point(field_release:bbf.sss.ShardResp.shard)
  
  ::bbf::sss::Shard* temp = shard_;
  shard_ = nullptr;
  return temp;
}
inline ::bbf::sss::Shard* ShardResp::_internal_mutable_shard() {
  
  if (shard_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::Shard>(GetArenaForAllocation());
    shard_ = p;
  }
  return shard_;
}
inline ::bbf::sss::Shard* ShardResp::mutable_shard() {
  ::bbf::sss::Shard* _msg = _internal_mutable_shard();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ShardResp.shard)
  return _msg;
}
inline void ShardResp::set_allocated_shard(::bbf::sss::Shard* shard) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete shard_;
  }
  if (shard) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::Shard>::GetOwningArena(shard);
    if (message_arena != submessage_arena) {
      shard = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shard, submessage_arena);
    }
    
  } else {
    
  }
  shard_ = shard;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ShardResp.shard)
}

// -------------------------------------------------------------------

// ListShardReq

// .bbf.sss.ListFilter filter = 1;
inline bool ListShardReq::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListShardReq::has_filter() const {
  return _internal_has_filter();
}
inline void ListShardReq::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::bbf::sss::ListFilter& ListShardReq::_internal_filter() const {
  const ::bbf::sss::ListFilter* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ListFilter&>(
      ::bbf::sss::_ListFilter_default_instance_);
}
inline const ::bbf::sss::ListFilter& ListShardReq::filter() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListShardReq.filter)
  return _internal_filter();
}
inline void ListShardReq::unsafe_arena_set_allocated_filter(
    ::bbf::sss::ListFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ListShardReq.filter)
}
inline ::bbf::sss::ListFilter* ListShardReq::release_filter() {
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ListFilter* ListShardReq::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:bbf.sss.ListShardReq.filter)
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::bbf::sss::ListFilter* ListShardReq::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ListFilter>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::bbf::sss::ListFilter* ListShardReq::mutable_filter() {
  ::bbf::sss::ListFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListShardReq.filter)
  return _msg;
}
inline void ListShardReq::set_allocated_filter(::bbf::sss::ListFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ListFilter>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ListShardReq.filter)
}

// -------------------------------------------------------------------

// ListShardResp

// .bbf.sss.Result result = 1;
inline void ListShardResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ListShardResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ListShardResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListShardResp.result)
  return _internal_result();
}
inline void ListShardResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ListShardResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ListShardResp.result)
}

// repeated .bbf.sss.Shard shard = 2;
inline int ListShardResp::_internal_shard_size() const {
  return shard_.size();
}
inline int ListShardResp::shard_size() const {
  return _internal_shard_size();
}
inline void ListShardResp::clear_shard() {
  shard_.Clear();
}
inline ::bbf::sss::Shard* ListShardResp::mutable_shard(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListShardResp.shard)
  return shard_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::Shard >*
ListShardResp::mutable_shard() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ListShardResp.shard)
  return &shard_;
}
inline const ::bbf::sss::Shard& ListShardResp::_internal_shard(int index) const {
  return shard_.Get(index);
}
inline const ::bbf::sss::Shard& ListShardResp::shard(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListShardResp.shard)
  return _internal_shard(index);
}
inline ::bbf::sss::Shard* ListShardResp::_internal_add_shard() {
  return shard_.Add();
}
inline ::bbf::sss::Shard* ListShardResp::add_shard() {
  ::bbf::sss::Shard* _add = _internal_add_shard();
  // @@protoc_insertion_point(field_add:bbf.sss.ListShardResp.shard)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::Shard >&
ListShardResp::shard() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ListShardResp.shard)
  return shard_;
}

// -------------------------------------------------------------------

// UpdateTrafficSteeringFunctionReq

// .bbf.sss.TrafficSteeringFunction traffic_steering_function = 1;
inline bool UpdateTrafficSteeringFunctionReq::_internal_has_traffic_steering_function() const {
  return this != internal_default_instance() && traffic_steering_function_ != nullptr;
}
inline bool UpdateTrafficSteeringFunctionReq::has_traffic_steering_function() const {
  return _internal_has_traffic_steering_function();
}
inline void UpdateTrafficSteeringFunctionReq::clear_traffic_steering_function() {
  if (GetArenaForAllocation() == nullptr && traffic_steering_function_ != nullptr) {
    delete traffic_steering_function_;
  }
  traffic_steering_function_ = nullptr;
}
inline const ::bbf::sss::TrafficSteeringFunction& UpdateTrafficSteeringFunctionReq::_internal_traffic_steering_function() const {
  const ::bbf::sss::TrafficSteeringFunction* p = traffic_steering_function_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::TrafficSteeringFunction&>(
      ::bbf::sss::_TrafficSteeringFunction_default_instance_);
}
inline const ::bbf::sss::TrafficSteeringFunction& UpdateTrafficSteeringFunctionReq::traffic_steering_function() const {
  // @@protoc_insertion_point(field_get:bbf.sss.UpdateTrafficSteeringFunctionReq.traffic_steering_function)
  return _internal_traffic_steering_function();
}
inline void UpdateTrafficSteeringFunctionReq::unsafe_arena_set_allocated_traffic_steering_function(
    ::bbf::sss::TrafficSteeringFunction* traffic_steering_function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traffic_steering_function_);
  }
  traffic_steering_function_ = traffic_steering_function;
  if (traffic_steering_function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.UpdateTrafficSteeringFunctionReq.traffic_steering_function)
}
inline ::bbf::sss::TrafficSteeringFunction* UpdateTrafficSteeringFunctionReq::release_traffic_steering_function() {
  
  ::bbf::sss::TrafficSteeringFunction* temp = traffic_steering_function_;
  traffic_steering_function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::TrafficSteeringFunction* UpdateTrafficSteeringFunctionReq::unsafe_arena_release_traffic_steering_function() {
  // @@protoc_insertion_point(field_release:bbf.sss.UpdateTrafficSteeringFunctionReq.traffic_steering_function)
  
  ::bbf::sss::TrafficSteeringFunction* temp = traffic_steering_function_;
  traffic_steering_function_ = nullptr;
  return temp;
}
inline ::bbf::sss::TrafficSteeringFunction* UpdateTrafficSteeringFunctionReq::_internal_mutable_traffic_steering_function() {
  
  if (traffic_steering_function_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::TrafficSteeringFunction>(GetArenaForAllocation());
    traffic_steering_function_ = p;
  }
  return traffic_steering_function_;
}
inline ::bbf::sss::TrafficSteeringFunction* UpdateTrafficSteeringFunctionReq::mutable_traffic_steering_function() {
  ::bbf::sss::TrafficSteeringFunction* _msg = _internal_mutable_traffic_steering_function();
  // @@protoc_insertion_point(field_mutable:bbf.sss.UpdateTrafficSteeringFunctionReq.traffic_steering_function)
  return _msg;
}
inline void UpdateTrafficSteeringFunctionReq::set_allocated_traffic_steering_function(::bbf::sss::TrafficSteeringFunction* traffic_steering_function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete traffic_steering_function_;
  }
  if (traffic_steering_function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::TrafficSteeringFunction>::GetOwningArena(traffic_steering_function);
    if (message_arena != submessage_arena) {
      traffic_steering_function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_steering_function, submessage_arena);
    }
    
  } else {
    
  }
  traffic_steering_function_ = traffic_steering_function;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.UpdateTrafficSteeringFunctionReq.traffic_steering_function)
}

// -------------------------------------------------------------------

// DeleteTrafficSteeringFunctionReq

// string id = 1;
inline void DeleteTrafficSteeringFunctionReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteTrafficSteeringFunctionReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.DeleteTrafficSteeringFunctionReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteTrafficSteeringFunctionReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.DeleteTrafficSteeringFunctionReq.id)
}
inline std::string* DeleteTrafficSteeringFunctionReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.DeleteTrafficSteeringFunctionReq.id)
  return _s;
}
inline const std::string& DeleteTrafficSteeringFunctionReq::_internal_id() const {
  return id_.Get();
}
inline void DeleteTrafficSteeringFunctionReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteTrafficSteeringFunctionReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteTrafficSteeringFunctionReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.DeleteTrafficSteeringFunctionReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteTrafficSteeringFunctionReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.DeleteTrafficSteeringFunctionReq.id)
}

// -------------------------------------------------------------------

// GetTrafficSteeringFunctionReq

// string id = 1;
inline void GetTrafficSteeringFunctionReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetTrafficSteeringFunctionReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.GetTrafficSteeringFunctionReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTrafficSteeringFunctionReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.GetTrafficSteeringFunctionReq.id)
}
inline std::string* GetTrafficSteeringFunctionReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.GetTrafficSteeringFunctionReq.id)
  return _s;
}
inline const std::string& GetTrafficSteeringFunctionReq::_internal_id() const {
  return id_.Get();
}
inline void GetTrafficSteeringFunctionReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTrafficSteeringFunctionReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTrafficSteeringFunctionReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.GetTrafficSteeringFunctionReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTrafficSteeringFunctionReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.GetTrafficSteeringFunctionReq.id)
}

// -------------------------------------------------------------------

// TrafficSteeringFunctionResp

// .bbf.sss.Result result = 1;
inline void TrafficSteeringFunctionResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result TrafficSteeringFunctionResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result TrafficSteeringFunctionResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.TrafficSteeringFunctionResp.result)
  return _internal_result();
}
inline void TrafficSteeringFunctionResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void TrafficSteeringFunctionResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.TrafficSteeringFunctionResp.result)
}

// .bbf.sss.TrafficSteeringFunction traffic_steering_function = 2;
inline bool TrafficSteeringFunctionResp::_internal_has_traffic_steering_function() const {
  return this != internal_default_instance() && traffic_steering_function_ != nullptr;
}
inline bool TrafficSteeringFunctionResp::has_traffic_steering_function() const {
  return _internal_has_traffic_steering_function();
}
inline void TrafficSteeringFunctionResp::clear_traffic_steering_function() {
  if (GetArenaForAllocation() == nullptr && traffic_steering_function_ != nullptr) {
    delete traffic_steering_function_;
  }
  traffic_steering_function_ = nullptr;
}
inline const ::bbf::sss::TrafficSteeringFunction& TrafficSteeringFunctionResp::_internal_traffic_steering_function() const {
  const ::bbf::sss::TrafficSteeringFunction* p = traffic_steering_function_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::TrafficSteeringFunction&>(
      ::bbf::sss::_TrafficSteeringFunction_default_instance_);
}
inline const ::bbf::sss::TrafficSteeringFunction& TrafficSteeringFunctionResp::traffic_steering_function() const {
  // @@protoc_insertion_point(field_get:bbf.sss.TrafficSteeringFunctionResp.traffic_steering_function)
  return _internal_traffic_steering_function();
}
inline void TrafficSteeringFunctionResp::unsafe_arena_set_allocated_traffic_steering_function(
    ::bbf::sss::TrafficSteeringFunction* traffic_steering_function) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traffic_steering_function_);
  }
  traffic_steering_function_ = traffic_steering_function;
  if (traffic_steering_function) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.TrafficSteeringFunctionResp.traffic_steering_function)
}
inline ::bbf::sss::TrafficSteeringFunction* TrafficSteeringFunctionResp::release_traffic_steering_function() {
  
  ::bbf::sss::TrafficSteeringFunction* temp = traffic_steering_function_;
  traffic_steering_function_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::TrafficSteeringFunction* TrafficSteeringFunctionResp::unsafe_arena_release_traffic_steering_function() {
  // @@protoc_insertion_point(field_release:bbf.sss.TrafficSteeringFunctionResp.traffic_steering_function)
  
  ::bbf::sss::TrafficSteeringFunction* temp = traffic_steering_function_;
  traffic_steering_function_ = nullptr;
  return temp;
}
inline ::bbf::sss::TrafficSteeringFunction* TrafficSteeringFunctionResp::_internal_mutable_traffic_steering_function() {
  
  if (traffic_steering_function_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::TrafficSteeringFunction>(GetArenaForAllocation());
    traffic_steering_function_ = p;
  }
  return traffic_steering_function_;
}
inline ::bbf::sss::TrafficSteeringFunction* TrafficSteeringFunctionResp::mutable_traffic_steering_function() {
  ::bbf::sss::TrafficSteeringFunction* _msg = _internal_mutable_traffic_steering_function();
  // @@protoc_insertion_point(field_mutable:bbf.sss.TrafficSteeringFunctionResp.traffic_steering_function)
  return _msg;
}
inline void TrafficSteeringFunctionResp::set_allocated_traffic_steering_function(::bbf::sss::TrafficSteeringFunction* traffic_steering_function) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete traffic_steering_function_;
  }
  if (traffic_steering_function) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::TrafficSteeringFunction>::GetOwningArena(traffic_steering_function);
    if (message_arena != submessage_arena) {
      traffic_steering_function = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_steering_function, submessage_arena);
    }
    
  } else {
    
  }
  traffic_steering_function_ = traffic_steering_function;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.TrafficSteeringFunctionResp.traffic_steering_function)
}

// -------------------------------------------------------------------

// ListTrafficSteeringFunctionReq

// .bbf.sss.ListFilter filter = 1;
inline bool ListTrafficSteeringFunctionReq::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListTrafficSteeringFunctionReq::has_filter() const {
  return _internal_has_filter();
}
inline void ListTrafficSteeringFunctionReq::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::bbf::sss::ListFilter& ListTrafficSteeringFunctionReq::_internal_filter() const {
  const ::bbf::sss::ListFilter* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ListFilter&>(
      ::bbf::sss::_ListFilter_default_instance_);
}
inline const ::bbf::sss::ListFilter& ListTrafficSteeringFunctionReq::filter() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListTrafficSteeringFunctionReq.filter)
  return _internal_filter();
}
inline void ListTrafficSteeringFunctionReq::unsafe_arena_set_allocated_filter(
    ::bbf::sss::ListFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ListTrafficSteeringFunctionReq.filter)
}
inline ::bbf::sss::ListFilter* ListTrafficSteeringFunctionReq::release_filter() {
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ListFilter* ListTrafficSteeringFunctionReq::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:bbf.sss.ListTrafficSteeringFunctionReq.filter)
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::bbf::sss::ListFilter* ListTrafficSteeringFunctionReq::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ListFilter>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::bbf::sss::ListFilter* ListTrafficSteeringFunctionReq::mutable_filter() {
  ::bbf::sss::ListFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListTrafficSteeringFunctionReq.filter)
  return _msg;
}
inline void ListTrafficSteeringFunctionReq::set_allocated_filter(::bbf::sss::ListFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ListFilter>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ListTrafficSteeringFunctionReq.filter)
}

// -------------------------------------------------------------------

// ListTrafficSteeringFunctionResp

// .bbf.sss.Result result = 1;
inline void ListTrafficSteeringFunctionResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ListTrafficSteeringFunctionResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ListTrafficSteeringFunctionResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListTrafficSteeringFunctionResp.result)
  return _internal_result();
}
inline void ListTrafficSteeringFunctionResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ListTrafficSteeringFunctionResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ListTrafficSteeringFunctionResp.result)
}

// repeated .bbf.sss.TrafficSteeringFunction traffic_steering_function = 2;
inline int ListTrafficSteeringFunctionResp::_internal_traffic_steering_function_size() const {
  return traffic_steering_function_.size();
}
inline int ListTrafficSteeringFunctionResp::traffic_steering_function_size() const {
  return _internal_traffic_steering_function_size();
}
inline void ListTrafficSteeringFunctionResp::clear_traffic_steering_function() {
  traffic_steering_function_.Clear();
}
inline ::bbf::sss::TrafficSteeringFunction* ListTrafficSteeringFunctionResp::mutable_traffic_steering_function(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListTrafficSteeringFunctionResp.traffic_steering_function)
  return traffic_steering_function_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::TrafficSteeringFunction >*
ListTrafficSteeringFunctionResp::mutable_traffic_steering_function() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ListTrafficSteeringFunctionResp.traffic_steering_function)
  return &traffic_steering_function_;
}
inline const ::bbf::sss::TrafficSteeringFunction& ListTrafficSteeringFunctionResp::_internal_traffic_steering_function(int index) const {
  return traffic_steering_function_.Get(index);
}
inline const ::bbf::sss::TrafficSteeringFunction& ListTrafficSteeringFunctionResp::traffic_steering_function(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListTrafficSteeringFunctionResp.traffic_steering_function)
  return _internal_traffic_steering_function(index);
}
inline ::bbf::sss::TrafficSteeringFunction* ListTrafficSteeringFunctionResp::_internal_add_traffic_steering_function() {
  return traffic_steering_function_.Add();
}
inline ::bbf::sss::TrafficSteeringFunction* ListTrafficSteeringFunctionResp::add_traffic_steering_function() {
  ::bbf::sss::TrafficSteeringFunction* _add = _internal_add_traffic_steering_function();
  // @@protoc_insertion_point(field_add:bbf.sss.ListTrafficSteeringFunctionResp.traffic_steering_function)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::TrafficSteeringFunction >&
ListTrafficSteeringFunctionResp::traffic_steering_function() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ListTrafficSteeringFunctionResp.traffic_steering_function)
  return traffic_steering_function_;
}

// -------------------------------------------------------------------

// UpdateServiceGatewayUserPlaneReq

// .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 1;
inline bool UpdateServiceGatewayUserPlaneReq::_internal_has_service_gateway_user_plane() const {
  return this != internal_default_instance() && service_gateway_user_plane_ != nullptr;
}
inline bool UpdateServiceGatewayUserPlaneReq::has_service_gateway_user_plane() const {
  return _internal_has_service_gateway_user_plane();
}
inline void UpdateServiceGatewayUserPlaneReq::clear_service_gateway_user_plane() {
  if (GetArenaForAllocation() == nullptr && service_gateway_user_plane_ != nullptr) {
    delete service_gateway_user_plane_;
  }
  service_gateway_user_plane_ = nullptr;
}
inline const ::bbf::sss::ServiceGatewayUserPlane& UpdateServiceGatewayUserPlaneReq::_internal_service_gateway_user_plane() const {
  const ::bbf::sss::ServiceGatewayUserPlane* p = service_gateway_user_plane_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ServiceGatewayUserPlane&>(
      ::bbf::sss::_ServiceGatewayUserPlane_default_instance_);
}
inline const ::bbf::sss::ServiceGatewayUserPlane& UpdateServiceGatewayUserPlaneReq::service_gateway_user_plane() const {
  // @@protoc_insertion_point(field_get:bbf.sss.UpdateServiceGatewayUserPlaneReq.service_gateway_user_plane)
  return _internal_service_gateway_user_plane();
}
inline void UpdateServiceGatewayUserPlaneReq::unsafe_arena_set_allocated_service_gateway_user_plane(
    ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_gateway_user_plane_);
  }
  service_gateway_user_plane_ = service_gateway_user_plane;
  if (service_gateway_user_plane) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.UpdateServiceGatewayUserPlaneReq.service_gateway_user_plane)
}
inline ::bbf::sss::ServiceGatewayUserPlane* UpdateServiceGatewayUserPlaneReq::release_service_gateway_user_plane() {
  
  ::bbf::sss::ServiceGatewayUserPlane* temp = service_gateway_user_plane_;
  service_gateway_user_plane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane* UpdateServiceGatewayUserPlaneReq::unsafe_arena_release_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_release:bbf.sss.UpdateServiceGatewayUserPlaneReq.service_gateway_user_plane)
  
  ::bbf::sss::ServiceGatewayUserPlane* temp = service_gateway_user_plane_;
  service_gateway_user_plane_ = nullptr;
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane* UpdateServiceGatewayUserPlaneReq::_internal_mutable_service_gateway_user_plane() {
  
  if (service_gateway_user_plane_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlane>(GetArenaForAllocation());
    service_gateway_user_plane_ = p;
  }
  return service_gateway_user_plane_;
}
inline ::bbf::sss::ServiceGatewayUserPlane* UpdateServiceGatewayUserPlaneReq::mutable_service_gateway_user_plane() {
  ::bbf::sss::ServiceGatewayUserPlane* _msg = _internal_mutable_service_gateway_user_plane();
  // @@protoc_insertion_point(field_mutable:bbf.sss.UpdateServiceGatewayUserPlaneReq.service_gateway_user_plane)
  return _msg;
}
inline void UpdateServiceGatewayUserPlaneReq::set_allocated_service_gateway_user_plane(::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_gateway_user_plane_;
  }
  if (service_gateway_user_plane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ServiceGatewayUserPlane>::GetOwningArena(service_gateway_user_plane);
    if (message_arena != submessage_arena) {
      service_gateway_user_plane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_gateway_user_plane, submessage_arena);
    }
    
  } else {
    
  }
  service_gateway_user_plane_ = service_gateway_user_plane;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.UpdateServiceGatewayUserPlaneReq.service_gateway_user_plane)
}

// -------------------------------------------------------------------

// DeleteServiceGatewayUserPlaneReq

// string id = 1;
inline void DeleteServiceGatewayUserPlaneReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteServiceGatewayUserPlaneReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.DeleteServiceGatewayUserPlaneReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteServiceGatewayUserPlaneReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.DeleteServiceGatewayUserPlaneReq.id)
}
inline std::string* DeleteServiceGatewayUserPlaneReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.DeleteServiceGatewayUserPlaneReq.id)
  return _s;
}
inline const std::string& DeleteServiceGatewayUserPlaneReq::_internal_id() const {
  return id_.Get();
}
inline void DeleteServiceGatewayUserPlaneReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteServiceGatewayUserPlaneReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteServiceGatewayUserPlaneReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.DeleteServiceGatewayUserPlaneReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteServiceGatewayUserPlaneReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.DeleteServiceGatewayUserPlaneReq.id)
}

// -------------------------------------------------------------------

// GetServiceGatewayUserPlaneReq

// string id = 1;
inline void GetServiceGatewayUserPlaneReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetServiceGatewayUserPlaneReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.GetServiceGatewayUserPlaneReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetServiceGatewayUserPlaneReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.GetServiceGatewayUserPlaneReq.id)
}
inline std::string* GetServiceGatewayUserPlaneReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.GetServiceGatewayUserPlaneReq.id)
  return _s;
}
inline const std::string& GetServiceGatewayUserPlaneReq::_internal_id() const {
  return id_.Get();
}
inline void GetServiceGatewayUserPlaneReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetServiceGatewayUserPlaneReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetServiceGatewayUserPlaneReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.GetServiceGatewayUserPlaneReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetServiceGatewayUserPlaneReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.GetServiceGatewayUserPlaneReq.id)
}

// -------------------------------------------------------------------

// ServiceGatewayUserPlaneResp

// .bbf.sss.Result result = 1;
inline void ServiceGatewayUserPlaneResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ServiceGatewayUserPlaneResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ServiceGatewayUserPlaneResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlaneResp.result)
  return _internal_result();
}
inline void ServiceGatewayUserPlaneResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ServiceGatewayUserPlaneResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlaneResp.result)
}

// .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 2;
inline bool ServiceGatewayUserPlaneResp::_internal_has_service_gateway_user_plane() const {
  return this != internal_default_instance() && service_gateway_user_plane_ != nullptr;
}
inline bool ServiceGatewayUserPlaneResp::has_service_gateway_user_plane() const {
  return _internal_has_service_gateway_user_plane();
}
inline void ServiceGatewayUserPlaneResp::clear_service_gateway_user_plane() {
  if (GetArenaForAllocation() == nullptr && service_gateway_user_plane_ != nullptr) {
    delete service_gateway_user_plane_;
  }
  service_gateway_user_plane_ = nullptr;
}
inline const ::bbf::sss::ServiceGatewayUserPlane& ServiceGatewayUserPlaneResp::_internal_service_gateway_user_plane() const {
  const ::bbf::sss::ServiceGatewayUserPlane* p = service_gateway_user_plane_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ServiceGatewayUserPlane&>(
      ::bbf::sss::_ServiceGatewayUserPlane_default_instance_);
}
inline const ::bbf::sss::ServiceGatewayUserPlane& ServiceGatewayUserPlaneResp::service_gateway_user_plane() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlaneResp.service_gateway_user_plane)
  return _internal_service_gateway_user_plane();
}
inline void ServiceGatewayUserPlaneResp::unsafe_arena_set_allocated_service_gateway_user_plane(
    ::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_gateway_user_plane_);
  }
  service_gateway_user_plane_ = service_gateway_user_plane;
  if (service_gateway_user_plane) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ServiceGatewayUserPlaneResp.service_gateway_user_plane)
}
inline ::bbf::sss::ServiceGatewayUserPlane* ServiceGatewayUserPlaneResp::release_service_gateway_user_plane() {
  
  ::bbf::sss::ServiceGatewayUserPlane* temp = service_gateway_user_plane_;
  service_gateway_user_plane_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane* ServiceGatewayUserPlaneResp::unsafe_arena_release_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlaneResp.service_gateway_user_plane)
  
  ::bbf::sss::ServiceGatewayUserPlane* temp = service_gateway_user_plane_;
  service_gateway_user_plane_ = nullptr;
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane* ServiceGatewayUserPlaneResp::_internal_mutable_service_gateway_user_plane() {
  
  if (service_gateway_user_plane_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlane>(GetArenaForAllocation());
    service_gateway_user_plane_ = p;
  }
  return service_gateway_user_plane_;
}
inline ::bbf::sss::ServiceGatewayUserPlane* ServiceGatewayUserPlaneResp::mutable_service_gateway_user_plane() {
  ::bbf::sss::ServiceGatewayUserPlane* _msg = _internal_mutable_service_gateway_user_plane();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlaneResp.service_gateway_user_plane)
  return _msg;
}
inline void ServiceGatewayUserPlaneResp::set_allocated_service_gateway_user_plane(::bbf::sss::ServiceGatewayUserPlane* service_gateway_user_plane) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_gateway_user_plane_;
  }
  if (service_gateway_user_plane) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ServiceGatewayUserPlane>::GetOwningArena(service_gateway_user_plane);
    if (message_arena != submessage_arena) {
      service_gateway_user_plane = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_gateway_user_plane, submessage_arena);
    }
    
  } else {
    
  }
  service_gateway_user_plane_ = service_gateway_user_plane;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlaneResp.service_gateway_user_plane)
}

// -------------------------------------------------------------------

// ListServiceGatewayUserPlaneReq

// .bbf.sss.ListFilter filter = 2;
inline bool ListServiceGatewayUserPlaneReq::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListServiceGatewayUserPlaneReq::has_filter() const {
  return _internal_has_filter();
}
inline void ListServiceGatewayUserPlaneReq::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::bbf::sss::ListFilter& ListServiceGatewayUserPlaneReq::_internal_filter() const {
  const ::bbf::sss::ListFilter* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ListFilter&>(
      ::bbf::sss::_ListFilter_default_instance_);
}
inline const ::bbf::sss::ListFilter& ListServiceGatewayUserPlaneReq::filter() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListServiceGatewayUserPlaneReq.filter)
  return _internal_filter();
}
inline void ListServiceGatewayUserPlaneReq::unsafe_arena_set_allocated_filter(
    ::bbf::sss::ListFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ListServiceGatewayUserPlaneReq.filter)
}
inline ::bbf::sss::ListFilter* ListServiceGatewayUserPlaneReq::release_filter() {
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ListFilter* ListServiceGatewayUserPlaneReq::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:bbf.sss.ListServiceGatewayUserPlaneReq.filter)
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::bbf::sss::ListFilter* ListServiceGatewayUserPlaneReq::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ListFilter>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::bbf::sss::ListFilter* ListServiceGatewayUserPlaneReq::mutable_filter() {
  ::bbf::sss::ListFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListServiceGatewayUserPlaneReq.filter)
  return _msg;
}
inline void ListServiceGatewayUserPlaneReq::set_allocated_filter(::bbf::sss::ListFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ListFilter>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ListServiceGatewayUserPlaneReq.filter)
}

// -------------------------------------------------------------------

// ListServiceGatewayUserPlaneResp

// .bbf.sss.Result result = 1;
inline void ListServiceGatewayUserPlaneResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ListServiceGatewayUserPlaneResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ListServiceGatewayUserPlaneResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListServiceGatewayUserPlaneResp.result)
  return _internal_result();
}
inline void ListServiceGatewayUserPlaneResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ListServiceGatewayUserPlaneResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ListServiceGatewayUserPlaneResp.result)
}

// repeated .bbf.sss.ServiceGatewayUserPlane service_gateway_user_plane = 2;
inline int ListServiceGatewayUserPlaneResp::_internal_service_gateway_user_plane_size() const {
  return service_gateway_user_plane_.size();
}
inline int ListServiceGatewayUserPlaneResp::service_gateway_user_plane_size() const {
  return _internal_service_gateway_user_plane_size();
}
inline void ListServiceGatewayUserPlaneResp::clear_service_gateway_user_plane() {
  service_gateway_user_plane_.Clear();
}
inline ::bbf::sss::ServiceGatewayUserPlane* ListServiceGatewayUserPlaneResp::mutable_service_gateway_user_plane(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListServiceGatewayUserPlaneResp.service_gateway_user_plane)
  return service_gateway_user_plane_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGatewayUserPlane >*
ListServiceGatewayUserPlaneResp::mutable_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ListServiceGatewayUserPlaneResp.service_gateway_user_plane)
  return &service_gateway_user_plane_;
}
inline const ::bbf::sss::ServiceGatewayUserPlane& ListServiceGatewayUserPlaneResp::_internal_service_gateway_user_plane(int index) const {
  return service_gateway_user_plane_.Get(index);
}
inline const ::bbf::sss::ServiceGatewayUserPlane& ListServiceGatewayUserPlaneResp::service_gateway_user_plane(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListServiceGatewayUserPlaneResp.service_gateway_user_plane)
  return _internal_service_gateway_user_plane(index);
}
inline ::bbf::sss::ServiceGatewayUserPlane* ListServiceGatewayUserPlaneResp::_internal_add_service_gateway_user_plane() {
  return service_gateway_user_plane_.Add();
}
inline ::bbf::sss::ServiceGatewayUserPlane* ListServiceGatewayUserPlaneResp::add_service_gateway_user_plane() {
  ::bbf::sss::ServiceGatewayUserPlane* _add = _internal_add_service_gateway_user_plane();
  // @@protoc_insertion_point(field_add:bbf.sss.ListServiceGatewayUserPlaneResp.service_gateway_user_plane)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::ServiceGatewayUserPlane >&
ListServiceGatewayUserPlaneResp::service_gateway_user_plane() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ListServiceGatewayUserPlaneResp.service_gateway_user_plane)
  return service_gateway_user_plane_;
}

// -------------------------------------------------------------------

// UpdateNetworkConnectionReq

// .bbf.sss.NetworkConnection network_connection = 1;
inline bool UpdateNetworkConnectionReq::_internal_has_network_connection() const {
  return this != internal_default_instance() && network_connection_ != nullptr;
}
inline bool UpdateNetworkConnectionReq::has_network_connection() const {
  return _internal_has_network_connection();
}
inline void UpdateNetworkConnectionReq::clear_network_connection() {
  if (GetArenaForAllocation() == nullptr && network_connection_ != nullptr) {
    delete network_connection_;
  }
  network_connection_ = nullptr;
}
inline const ::bbf::sss::NetworkConnection& UpdateNetworkConnectionReq::_internal_network_connection() const {
  const ::bbf::sss::NetworkConnection* p = network_connection_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::NetworkConnection&>(
      ::bbf::sss::_NetworkConnection_default_instance_);
}
inline const ::bbf::sss::NetworkConnection& UpdateNetworkConnectionReq::network_connection() const {
  // @@protoc_insertion_point(field_get:bbf.sss.UpdateNetworkConnectionReq.network_connection)
  return _internal_network_connection();
}
inline void UpdateNetworkConnectionReq::unsafe_arena_set_allocated_network_connection(
    ::bbf::sss::NetworkConnection* network_connection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_connection_);
  }
  network_connection_ = network_connection;
  if (network_connection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.UpdateNetworkConnectionReq.network_connection)
}
inline ::bbf::sss::NetworkConnection* UpdateNetworkConnectionReq::release_network_connection() {
  
  ::bbf::sss::NetworkConnection* temp = network_connection_;
  network_connection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::NetworkConnection* UpdateNetworkConnectionReq::unsafe_arena_release_network_connection() {
  // @@protoc_insertion_point(field_release:bbf.sss.UpdateNetworkConnectionReq.network_connection)
  
  ::bbf::sss::NetworkConnection* temp = network_connection_;
  network_connection_ = nullptr;
  return temp;
}
inline ::bbf::sss::NetworkConnection* UpdateNetworkConnectionReq::_internal_mutable_network_connection() {
  
  if (network_connection_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::NetworkConnection>(GetArenaForAllocation());
    network_connection_ = p;
  }
  return network_connection_;
}
inline ::bbf::sss::NetworkConnection* UpdateNetworkConnectionReq::mutable_network_connection() {
  ::bbf::sss::NetworkConnection* _msg = _internal_mutable_network_connection();
  // @@protoc_insertion_point(field_mutable:bbf.sss.UpdateNetworkConnectionReq.network_connection)
  return _msg;
}
inline void UpdateNetworkConnectionReq::set_allocated_network_connection(::bbf::sss::NetworkConnection* network_connection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete network_connection_;
  }
  if (network_connection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::NetworkConnection>::GetOwningArena(network_connection);
    if (message_arena != submessage_arena) {
      network_connection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_connection, submessage_arena);
    }
    
  } else {
    
  }
  network_connection_ = network_connection;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.UpdateNetworkConnectionReq.network_connection)
}

// -------------------------------------------------------------------

// DeleteNetworkConnectionReq

// string id = 1;
inline void DeleteNetworkConnectionReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteNetworkConnectionReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.DeleteNetworkConnectionReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteNetworkConnectionReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.DeleteNetworkConnectionReq.id)
}
inline std::string* DeleteNetworkConnectionReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.DeleteNetworkConnectionReq.id)
  return _s;
}
inline const std::string& DeleteNetworkConnectionReq::_internal_id() const {
  return id_.Get();
}
inline void DeleteNetworkConnectionReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteNetworkConnectionReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteNetworkConnectionReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.DeleteNetworkConnectionReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteNetworkConnectionReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.DeleteNetworkConnectionReq.id)
}

// -------------------------------------------------------------------

// GetNetworkConnectionReq

// string id = 1;
inline void GetNetworkConnectionReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetNetworkConnectionReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.GetNetworkConnectionReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNetworkConnectionReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.GetNetworkConnectionReq.id)
}
inline std::string* GetNetworkConnectionReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.GetNetworkConnectionReq.id)
  return _s;
}
inline const std::string& GetNetworkConnectionReq::_internal_id() const {
  return id_.Get();
}
inline void GetNetworkConnectionReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNetworkConnectionReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNetworkConnectionReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.GetNetworkConnectionReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNetworkConnectionReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.GetNetworkConnectionReq.id)
}

// -------------------------------------------------------------------

// NetworkConnectionResp

// .bbf.sss.Result result = 1;
inline void NetworkConnectionResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result NetworkConnectionResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result NetworkConnectionResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnectionResp.result)
  return _internal_result();
}
inline void NetworkConnectionResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void NetworkConnectionResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.NetworkConnectionResp.result)
}

// .bbf.sss.NetworkConnection network_connection = 2;
inline bool NetworkConnectionResp::_internal_has_network_connection() const {
  return this != internal_default_instance() && network_connection_ != nullptr;
}
inline bool NetworkConnectionResp::has_network_connection() const {
  return _internal_has_network_connection();
}
inline void NetworkConnectionResp::clear_network_connection() {
  if (GetArenaForAllocation() == nullptr && network_connection_ != nullptr) {
    delete network_connection_;
  }
  network_connection_ = nullptr;
}
inline const ::bbf::sss::NetworkConnection& NetworkConnectionResp::_internal_network_connection() const {
  const ::bbf::sss::NetworkConnection* p = network_connection_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::NetworkConnection&>(
      ::bbf::sss::_NetworkConnection_default_instance_);
}
inline const ::bbf::sss::NetworkConnection& NetworkConnectionResp::network_connection() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnectionResp.network_connection)
  return _internal_network_connection();
}
inline void NetworkConnectionResp::unsafe_arena_set_allocated_network_connection(
    ::bbf::sss::NetworkConnection* network_connection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_connection_);
  }
  network_connection_ = network_connection;
  if (network_connection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.NetworkConnectionResp.network_connection)
}
inline ::bbf::sss::NetworkConnection* NetworkConnectionResp::release_network_connection() {
  
  ::bbf::sss::NetworkConnection* temp = network_connection_;
  network_connection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::NetworkConnection* NetworkConnectionResp::unsafe_arena_release_network_connection() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnectionResp.network_connection)
  
  ::bbf::sss::NetworkConnection* temp = network_connection_;
  network_connection_ = nullptr;
  return temp;
}
inline ::bbf::sss::NetworkConnection* NetworkConnectionResp::_internal_mutable_network_connection() {
  
  if (network_connection_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::NetworkConnection>(GetArenaForAllocation());
    network_connection_ = p;
  }
  return network_connection_;
}
inline ::bbf::sss::NetworkConnection* NetworkConnectionResp::mutable_network_connection() {
  ::bbf::sss::NetworkConnection* _msg = _internal_mutable_network_connection();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnectionResp.network_connection)
  return _msg;
}
inline void NetworkConnectionResp::set_allocated_network_connection(::bbf::sss::NetworkConnection* network_connection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete network_connection_;
  }
  if (network_connection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::NetworkConnection>::GetOwningArena(network_connection);
    if (message_arena != submessage_arena) {
      network_connection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_connection, submessage_arena);
    }
    
  } else {
    
  }
  network_connection_ = network_connection;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.NetworkConnectionResp.network_connection)
}

// -------------------------------------------------------------------

// ListNetworkConnectionReq

// .bbf.sss.ListFilter filter = 1;
inline bool ListNetworkConnectionReq::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListNetworkConnectionReq::has_filter() const {
  return _internal_has_filter();
}
inline void ListNetworkConnectionReq::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::bbf::sss::ListFilter& ListNetworkConnectionReq::_internal_filter() const {
  const ::bbf::sss::ListFilter* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ListFilter&>(
      ::bbf::sss::_ListFilter_default_instance_);
}
inline const ::bbf::sss::ListFilter& ListNetworkConnectionReq::filter() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListNetworkConnectionReq.filter)
  return _internal_filter();
}
inline void ListNetworkConnectionReq::unsafe_arena_set_allocated_filter(
    ::bbf::sss::ListFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ListNetworkConnectionReq.filter)
}
inline ::bbf::sss::ListFilter* ListNetworkConnectionReq::release_filter() {
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ListFilter* ListNetworkConnectionReq::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:bbf.sss.ListNetworkConnectionReq.filter)
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::bbf::sss::ListFilter* ListNetworkConnectionReq::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ListFilter>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::bbf::sss::ListFilter* ListNetworkConnectionReq::mutable_filter() {
  ::bbf::sss::ListFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListNetworkConnectionReq.filter)
  return _msg;
}
inline void ListNetworkConnectionReq::set_allocated_filter(::bbf::sss::ListFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ListFilter>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ListNetworkConnectionReq.filter)
}

// -------------------------------------------------------------------

// ListNetworkConnectionResp

// .bbf.sss.Result result = 1;
inline void ListNetworkConnectionResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result ListNetworkConnectionResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result ListNetworkConnectionResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListNetworkConnectionResp.result)
  return _internal_result();
}
inline void ListNetworkConnectionResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void ListNetworkConnectionResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ListNetworkConnectionResp.result)
}

// repeated .bbf.sss.NetworkConnection network_connection = 2;
inline int ListNetworkConnectionResp::_internal_network_connection_size() const {
  return network_connection_.size();
}
inline int ListNetworkConnectionResp::network_connection_size() const {
  return _internal_network_connection_size();
}
inline void ListNetworkConnectionResp::clear_network_connection() {
  network_connection_.Clear();
}
inline ::bbf::sss::NetworkConnection* ListNetworkConnectionResp::mutable_network_connection(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListNetworkConnectionResp.network_connection)
  return network_connection_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::NetworkConnection >*
ListNetworkConnectionResp::mutable_network_connection() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ListNetworkConnectionResp.network_connection)
  return &network_connection_;
}
inline const ::bbf::sss::NetworkConnection& ListNetworkConnectionResp::_internal_network_connection(int index) const {
  return network_connection_.Get(index);
}
inline const ::bbf::sss::NetworkConnection& ListNetworkConnectionResp::network_connection(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListNetworkConnectionResp.network_connection)
  return _internal_network_connection(index);
}
inline ::bbf::sss::NetworkConnection* ListNetworkConnectionResp::_internal_add_network_connection() {
  return network_connection_.Add();
}
inline ::bbf::sss::NetworkConnection* ListNetworkConnectionResp::add_network_connection() {
  ::bbf::sss::NetworkConnection* _add = _internal_add_network_connection();
  // @@protoc_insertion_point(field_add:bbf.sss.ListNetworkConnectionResp.network_connection)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::NetworkConnection >&
ListNetworkConnectionResp::network_connection() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ListNetworkConnectionResp.network_connection)
  return network_connection_;
}

// -------------------------------------------------------------------

// UpdateSessionContextReq

// .bbf.sss.SessionContext session_context = 1;
inline bool UpdateSessionContextReq::_internal_has_session_context() const {
  return this != internal_default_instance() && session_context_ != nullptr;
}
inline bool UpdateSessionContextReq::has_session_context() const {
  return _internal_has_session_context();
}
inline void UpdateSessionContextReq::clear_session_context() {
  if (GetArenaForAllocation() == nullptr && session_context_ != nullptr) {
    delete session_context_;
  }
  session_context_ = nullptr;
}
inline const ::bbf::sss::SessionContext& UpdateSessionContextReq::_internal_session_context() const {
  const ::bbf::sss::SessionContext* p = session_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::SessionContext&>(
      ::bbf::sss::_SessionContext_default_instance_);
}
inline const ::bbf::sss::SessionContext& UpdateSessionContextReq::session_context() const {
  // @@protoc_insertion_point(field_get:bbf.sss.UpdateSessionContextReq.session_context)
  return _internal_session_context();
}
inline void UpdateSessionContextReq::unsafe_arena_set_allocated_session_context(
    ::bbf::sss::SessionContext* session_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_context_);
  }
  session_context_ = session_context;
  if (session_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.UpdateSessionContextReq.session_context)
}
inline ::bbf::sss::SessionContext* UpdateSessionContextReq::release_session_context() {
  
  ::bbf::sss::SessionContext* temp = session_context_;
  session_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::SessionContext* UpdateSessionContextReq::unsafe_arena_release_session_context() {
  // @@protoc_insertion_point(field_release:bbf.sss.UpdateSessionContextReq.session_context)
  
  ::bbf::sss::SessionContext* temp = session_context_;
  session_context_ = nullptr;
  return temp;
}
inline ::bbf::sss::SessionContext* UpdateSessionContextReq::_internal_mutable_session_context() {
  
  if (session_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::SessionContext>(GetArenaForAllocation());
    session_context_ = p;
  }
  return session_context_;
}
inline ::bbf::sss::SessionContext* UpdateSessionContextReq::mutable_session_context() {
  ::bbf::sss::SessionContext* _msg = _internal_mutable_session_context();
  // @@protoc_insertion_point(field_mutable:bbf.sss.UpdateSessionContextReq.session_context)
  return _msg;
}
inline void UpdateSessionContextReq::set_allocated_session_context(::bbf::sss::SessionContext* session_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_context_;
  }
  if (session_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::SessionContext>::GetOwningArena(session_context);
    if (message_arena != submessage_arena) {
      session_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_context, submessage_arena);
    }
    
  } else {
    
  }
  session_context_ = session_context;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.UpdateSessionContextReq.session_context)
}

// -------------------------------------------------------------------

// DeleteSessionContextReq

// string id = 1;
inline void DeleteSessionContextReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& DeleteSessionContextReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.DeleteSessionContextReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteSessionContextReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.DeleteSessionContextReq.id)
}
inline std::string* DeleteSessionContextReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.DeleteSessionContextReq.id)
  return _s;
}
inline const std::string& DeleteSessionContextReq::_internal_id() const {
  return id_.Get();
}
inline void DeleteSessionContextReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteSessionContextReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteSessionContextReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.DeleteSessionContextReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteSessionContextReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.DeleteSessionContextReq.id)
}

// -------------------------------------------------------------------

// GetSessionContextReq

// string id = 1;
inline void GetSessionContextReq::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetSessionContextReq::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.GetSessionContextReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSessionContextReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.GetSessionContextReq.id)
}
inline std::string* GetSessionContextReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.GetSessionContextReq.id)
  return _s;
}
inline const std::string& GetSessionContextReq::_internal_id() const {
  return id_.Get();
}
inline void GetSessionContextReq::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSessionContextReq::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSessionContextReq::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.GetSessionContextReq.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSessionContextReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.GetSessionContextReq.id)
}

// -------------------------------------------------------------------

// SessionContextResp

// .bbf.sss.Result result = 1;
inline void SessionContextResp::clear_result() {
  result_ = 0;
}
inline ::bbf::sss::Result SessionContextResp::_internal_result() const {
  return static_cast< ::bbf::sss::Result >(result_);
}
inline ::bbf::sss::Result SessionContextResp::result() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContextResp.result)
  return _internal_result();
}
inline void SessionContextResp::_internal_set_result(::bbf::sss::Result value) {
  
  result_ = value;
}
inline void SessionContextResp::set_result(::bbf::sss::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContextResp.result)
}

// .bbf.sss.SessionContext session_context = 2;
inline bool SessionContextResp::_internal_has_session_context() const {
  return this != internal_default_instance() && session_context_ != nullptr;
}
inline bool SessionContextResp::has_session_context() const {
  return _internal_has_session_context();
}
inline void SessionContextResp::clear_session_context() {
  if (GetArenaForAllocation() == nullptr && session_context_ != nullptr) {
    delete session_context_;
  }
  session_context_ = nullptr;
}
inline const ::bbf::sss::SessionContext& SessionContextResp::_internal_session_context() const {
  const ::bbf::sss::SessionContext* p = session_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::SessionContext&>(
      ::bbf::sss::_SessionContext_default_instance_);
}
inline const ::bbf::sss::SessionContext& SessionContextResp::session_context() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContextResp.session_context)
  return _internal_session_context();
}
inline void SessionContextResp::unsafe_arena_set_allocated_session_context(
    ::bbf::sss::SessionContext* session_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_context_);
  }
  session_context_ = session_context;
  if (session_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.SessionContextResp.session_context)
}
inline ::bbf::sss::SessionContext* SessionContextResp::release_session_context() {
  
  ::bbf::sss::SessionContext* temp = session_context_;
  session_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::SessionContext* SessionContextResp::unsafe_arena_release_session_context() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContextResp.session_context)
  
  ::bbf::sss::SessionContext* temp = session_context_;
  session_context_ = nullptr;
  return temp;
}
inline ::bbf::sss::SessionContext* SessionContextResp::_internal_mutable_session_context() {
  
  if (session_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::SessionContext>(GetArenaForAllocation());
    session_context_ = p;
  }
  return session_context_;
}
inline ::bbf::sss::SessionContext* SessionContextResp::mutable_session_context() {
  ::bbf::sss::SessionContext* _msg = _internal_mutable_session_context();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContextResp.session_context)
  return _msg;
}
inline void SessionContextResp::set_allocated_session_context(::bbf::sss::SessionContext* session_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_context_;
  }
  if (session_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::SessionContext>::GetOwningArena(session_context);
    if (message_arena != submessage_arena) {
      session_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_context, submessage_arena);
    }
    
  } else {
    
  }
  session_context_ = session_context;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContextResp.session_context)
}

// -------------------------------------------------------------------

// ListSessionContextReq

// .bbf.sss.ListFilter filter = 1;
inline bool ListSessionContextReq::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool ListSessionContextReq::has_filter() const {
  return _internal_has_filter();
}
inline void ListSessionContextReq::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::bbf::sss::ListFilter& ListSessionContextReq::_internal_filter() const {
  const ::bbf::sss::ListFilter* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ListFilter&>(
      ::bbf::sss::_ListFilter_default_instance_);
}
inline const ::bbf::sss::ListFilter& ListSessionContextReq::filter() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListSessionContextReq.filter)
  return _internal_filter();
}
inline void ListSessionContextReq::unsafe_arena_set_allocated_filter(
    ::bbf::sss::ListFilter* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ListSessionContextReq.filter)
}
inline ::bbf::sss::ListFilter* ListSessionContextReq::release_filter() {
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ListFilter* ListSessionContextReq::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:bbf.sss.ListSessionContextReq.filter)
  
  ::bbf::sss::ListFilter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::bbf::sss::ListFilter* ListSessionContextReq::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ListFilter>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::bbf::sss::ListFilter* ListSessionContextReq::mutable_filter() {
  ::bbf::sss::ListFilter* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListSessionContextReq.filter)
  return _msg;
}
inline void ListSessionContextReq::set_allocated_filter(::bbf::sss::ListFilter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ListFilter>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ListSessionContextReq.filter)
}

// -------------------------------------------------------------------

// ListSessionContextResp

// repeated .bbf.sss.SessionContext session_context = 1;
inline int ListSessionContextResp::_internal_session_context_size() const {
  return session_context_.size();
}
inline int ListSessionContextResp::session_context_size() const {
  return _internal_session_context_size();
}
inline void ListSessionContextResp::clear_session_context() {
  session_context_.Clear();
}
inline ::bbf::sss::SessionContext* ListSessionContextResp::mutable_session_context(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ListSessionContextResp.session_context)
  return session_context_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::SessionContext >*
ListSessionContextResp::mutable_session_context() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ListSessionContextResp.session_context)
  return &session_context_;
}
inline const ::bbf::sss::SessionContext& ListSessionContextResp::_internal_session_context(int index) const {
  return session_context_.Get(index);
}
inline const ::bbf::sss::SessionContext& ListSessionContextResp::session_context(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ListSessionContextResp.session_context)
  return _internal_session_context(index);
}
inline ::bbf::sss::SessionContext* ListSessionContextResp::_internal_add_session_context() {
  return session_context_.Add();
}
inline ::bbf::sss::SessionContext* ListSessionContextResp::add_session_context() {
  ::bbf::sss::SessionContext* _add = _internal_add_session_context();
  // @@protoc_insertion_point(field_add:bbf.sss.ListSessionContextResp.session_context)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::bbf::sss::SessionContext >&
ListSessionContextResp::session_context() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ListSessionContextResp.session_context)
  return session_context_;
}

// -------------------------------------------------------------------

// ServiceGatewayUserPlane_Spec

// int32 max_session_count = 1;
inline void ServiceGatewayUserPlane_Spec::clear_max_session_count() {
  max_session_count_ = 0;
}
inline int32_t ServiceGatewayUserPlane_Spec::_internal_max_session_count() const {
  return max_session_count_;
}
inline int32_t ServiceGatewayUserPlane_Spec::max_session_count() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Spec.max_session_count)
  return _internal_max_session_count();
}
inline void ServiceGatewayUserPlane_Spec::_internal_set_max_session_count(int32_t value) {
  
  max_session_count_ = value;
}
inline void ServiceGatewayUserPlane_Spec::set_max_session_count(int32_t value) {
  _internal_set_max_session_count(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.max_session_count)
}

// repeated string supported_service_group = 2;
inline int ServiceGatewayUserPlane_Spec::_internal_supported_service_group_size() const {
  return supported_service_group_.size();
}
inline int ServiceGatewayUserPlane_Spec::supported_service_group_size() const {
  return _internal_supported_service_group_size();
}
inline void ServiceGatewayUserPlane_Spec::clear_supported_service_group() {
  supported_service_group_.Clear();
}
inline std::string* ServiceGatewayUserPlane_Spec::add_supported_service_group() {
  std::string* _s = _internal_add_supported_service_group();
  // @@protoc_insertion_point(field_add_mutable:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
  return _s;
}
inline const std::string& ServiceGatewayUserPlane_Spec::_internal_supported_service_group(int index) const {
  return supported_service_group_.Get(index);
}
inline const std::string& ServiceGatewayUserPlane_Spec::supported_service_group(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
  return _internal_supported_service_group(index);
}
inline std::string* ServiceGatewayUserPlane_Spec::mutable_supported_service_group(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
  return supported_service_group_.Mutable(index);
}
inline void ServiceGatewayUserPlane_Spec::set_supported_service_group(int index, const std::string& value) {
  supported_service_group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline void ServiceGatewayUserPlane_Spec::set_supported_service_group(int index, std::string&& value) {
  supported_service_group_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline void ServiceGatewayUserPlane_Spec::set_supported_service_group(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_service_group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline void ServiceGatewayUserPlane_Spec::set_supported_service_group(int index, const char* value, size_t size) {
  supported_service_group_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline std::string* ServiceGatewayUserPlane_Spec::_internal_add_supported_service_group() {
  return supported_service_group_.Add();
}
inline void ServiceGatewayUserPlane_Spec::add_supported_service_group(const std::string& value) {
  supported_service_group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline void ServiceGatewayUserPlane_Spec::add_supported_service_group(std::string&& value) {
  supported_service_group_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline void ServiceGatewayUserPlane_Spec::add_supported_service_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_service_group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline void ServiceGatewayUserPlane_Spec::add_supported_service_group(const char* value, size_t size) {
  supported_service_group_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ServiceGatewayUserPlane_Spec::supported_service_group() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
  return supported_service_group_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ServiceGatewayUserPlane_Spec::mutable_supported_service_group() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ServiceGatewayUserPlane.Spec.supported_service_group)
  return &supported_service_group_;
}

// bool maintenence = 3;
inline void ServiceGatewayUserPlane_Spec::clear_maintenence() {
  maintenence_ = false;
}
inline bool ServiceGatewayUserPlane_Spec::_internal_maintenence() const {
  return maintenence_;
}
inline bool ServiceGatewayUserPlane_Spec::maintenence() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Spec.maintenence)
  return _internal_maintenence();
}
inline void ServiceGatewayUserPlane_Spec::_internal_set_maintenence(bool value) {
  
  maintenence_ = value;
}
inline void ServiceGatewayUserPlane_Spec::set_maintenence(bool value) {
  _internal_set_maintenence(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.maintenence)
}

// string access_ip_address = 9901;
inline void ServiceGatewayUserPlane_Spec::clear_access_ip_address() {
  access_ip_address_.ClearToEmpty();
}
inline const std::string& ServiceGatewayUserPlane_Spec::access_ip_address() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Spec.access_ip_address)
  return _internal_access_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceGatewayUserPlane_Spec::set_access_ip_address(ArgT0&& arg0, ArgT... args) {
 
 access_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.access_ip_address)
}
inline std::string* ServiceGatewayUserPlane_Spec::mutable_access_ip_address() {
  std::string* _s = _internal_mutable_access_ip_address();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.Spec.access_ip_address)
  return _s;
}
inline const std::string& ServiceGatewayUserPlane_Spec::_internal_access_ip_address() const {
  return access_ip_address_.Get();
}
inline void ServiceGatewayUserPlane_Spec::_internal_set_access_ip_address(const std::string& value) {
  
  access_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::_internal_mutable_access_ip_address() {
  
  return access_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::release_access_ip_address() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.Spec.access_ip_address)
  return access_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceGatewayUserPlane_Spec::set_allocated_access_ip_address(std::string* access_ip_address) {
  if (access_ip_address != nullptr) {
    
  } else {
    
  }
  access_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.Spec.access_ip_address)
}

// string core_ip_address = 9902;
inline void ServiceGatewayUserPlane_Spec::clear_core_ip_address() {
  core_ip_address_.ClearToEmpty();
}
inline const std::string& ServiceGatewayUserPlane_Spec::core_ip_address() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Spec.core_ip_address)
  return _internal_core_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceGatewayUserPlane_Spec::set_core_ip_address(ArgT0&& arg0, ArgT... args) {
 
 core_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.core_ip_address)
}
inline std::string* ServiceGatewayUserPlane_Spec::mutable_core_ip_address() {
  std::string* _s = _internal_mutable_core_ip_address();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.Spec.core_ip_address)
  return _s;
}
inline const std::string& ServiceGatewayUserPlane_Spec::_internal_core_ip_address() const {
  return core_ip_address_.Get();
}
inline void ServiceGatewayUserPlane_Spec::_internal_set_core_ip_address(const std::string& value) {
  
  core_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::_internal_mutable_core_ip_address() {
  
  return core_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::release_core_ip_address() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.Spec.core_ip_address)
  return core_ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceGatewayUserPlane_Spec::set_allocated_core_ip_address(std::string* core_ip_address) {
  if (core_ip_address != nullptr) {
    
  } else {
    
  }
  core_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), core_ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (core_ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    core_ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.Spec.core_ip_address)
}

// string access_mac = 9903;
inline void ServiceGatewayUserPlane_Spec::clear_access_mac() {
  access_mac_.ClearToEmpty();
}
inline const std::string& ServiceGatewayUserPlane_Spec::access_mac() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Spec.access_mac)
  return _internal_access_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceGatewayUserPlane_Spec::set_access_mac(ArgT0&& arg0, ArgT... args) {
 
 access_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.access_mac)
}
inline std::string* ServiceGatewayUserPlane_Spec::mutable_access_mac() {
  std::string* _s = _internal_mutable_access_mac();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.Spec.access_mac)
  return _s;
}
inline const std::string& ServiceGatewayUserPlane_Spec::_internal_access_mac() const {
  return access_mac_.Get();
}
inline void ServiceGatewayUserPlane_Spec::_internal_set_access_mac(const std::string& value) {
  
  access_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::_internal_mutable_access_mac() {
  
  return access_mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::release_access_mac() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.Spec.access_mac)
  return access_mac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceGatewayUserPlane_Spec::set_allocated_access_mac(std::string* access_mac) {
  if (access_mac != nullptr) {
    
  } else {
    
  }
  access_mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_mac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_mac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.Spec.access_mac)
}

// string core_mac = 9904;
inline void ServiceGatewayUserPlane_Spec::clear_core_mac() {
  core_mac_.ClearToEmpty();
}
inline const std::string& ServiceGatewayUserPlane_Spec::core_mac() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Spec.core_mac)
  return _internal_core_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceGatewayUserPlane_Spec::set_core_mac(ArgT0&& arg0, ArgT... args) {
 
 core_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Spec.core_mac)
}
inline std::string* ServiceGatewayUserPlane_Spec::mutable_core_mac() {
  std::string* _s = _internal_mutable_core_mac();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.Spec.core_mac)
  return _s;
}
inline const std::string& ServiceGatewayUserPlane_Spec::_internal_core_mac() const {
  return core_mac_.Get();
}
inline void ServiceGatewayUserPlane_Spec::_internal_set_core_mac(const std::string& value) {
  
  core_mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::_internal_mutable_core_mac() {
  
  return core_mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane_Spec::release_core_mac() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.Spec.core_mac)
  return core_mac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceGatewayUserPlane_Spec::set_allocated_core_mac(std::string* core_mac) {
  if (core_mac != nullptr) {
    
  } else {
    
  }
  core_mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), core_mac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (core_mac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    core_mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.Spec.core_mac)
}

// -------------------------------------------------------------------

// ServiceGatewayUserPlane_Status

// int32 allocated_session_count = 1;
inline void ServiceGatewayUserPlane_Status::clear_allocated_session_count() {
  allocated_session_count_ = 0;
}
inline int32_t ServiceGatewayUserPlane_Status::_internal_allocated_session_count() const {
  return allocated_session_count_;
}
inline int32_t ServiceGatewayUserPlane_Status::allocated_session_count() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Status.allocated_session_count)
  return _internal_allocated_session_count();
}
inline void ServiceGatewayUserPlane_Status::_internal_set_allocated_session_count(int32_t value) {
  
  allocated_session_count_ = value;
}
inline void ServiceGatewayUserPlane_Status::set_allocated_session_count(int32_t value) {
  _internal_set_allocated_session_count(value);
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Status.allocated_session_count)
}

// repeated int32 network_connection = 2;
inline int ServiceGatewayUserPlane_Status::_internal_network_connection_size() const {
  return network_connection_.size();
}
inline int ServiceGatewayUserPlane_Status::network_connection_size() const {
  return _internal_network_connection_size();
}
inline void ServiceGatewayUserPlane_Status::clear_network_connection() {
  network_connection_.Clear();
}
inline int32_t ServiceGatewayUserPlane_Status::_internal_network_connection(int index) const {
  return network_connection_.Get(index);
}
inline int32_t ServiceGatewayUserPlane_Status::network_connection(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.Status.network_connection)
  return _internal_network_connection(index);
}
inline void ServiceGatewayUserPlane_Status::set_network_connection(int index, int32_t value) {
  network_connection_.Set(index, value);
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.Status.network_connection)
}
inline void ServiceGatewayUserPlane_Status::_internal_add_network_connection(int32_t value) {
  network_connection_.Add(value);
}
inline void ServiceGatewayUserPlane_Status::add_network_connection(int32_t value) {
  _internal_add_network_connection(value);
  // @@protoc_insertion_point(field_add:bbf.sss.ServiceGatewayUserPlane.Status.network_connection)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ServiceGatewayUserPlane_Status::_internal_network_connection() const {
  return network_connection_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ServiceGatewayUserPlane_Status::network_connection() const {
  // @@protoc_insertion_point(field_list:bbf.sss.ServiceGatewayUserPlane.Status.network_connection)
  return _internal_network_connection();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ServiceGatewayUserPlane_Status::_internal_mutable_network_connection() {
  return &network_connection_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ServiceGatewayUserPlane_Status::mutable_network_connection() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.ServiceGatewayUserPlane.Status.network_connection)
  return _internal_mutable_network_connection();
}

// -------------------------------------------------------------------

// ServiceGatewayUserPlane

// string id = 1;
inline void ServiceGatewayUserPlane::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ServiceGatewayUserPlane::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceGatewayUserPlane::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.id)
}
inline std::string* ServiceGatewayUserPlane::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.id)
  return _s;
}
inline const std::string& ServiceGatewayUserPlane::_internal_id() const {
  return id_.Get();
}
inline void ServiceGatewayUserPlane::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceGatewayUserPlane::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.id)
}

// string service_gateway_id = 2;
inline void ServiceGatewayUserPlane::clear_service_gateway_id() {
  service_gateway_id_.ClearToEmpty();
}
inline const std::string& ServiceGatewayUserPlane::service_gateway_id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.service_gateway_id)
  return _internal_service_gateway_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceGatewayUserPlane::set_service_gateway_id(ArgT0&& arg0, ArgT... args) {
 
 service_gateway_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGatewayUserPlane.service_gateway_id)
}
inline std::string* ServiceGatewayUserPlane::mutable_service_gateway_id() {
  std::string* _s = _internal_mutable_service_gateway_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.service_gateway_id)
  return _s;
}
inline const std::string& ServiceGatewayUserPlane::_internal_service_gateway_id() const {
  return service_gateway_id_.Get();
}
inline void ServiceGatewayUserPlane::_internal_set_service_gateway_id(const std::string& value) {
  
  service_gateway_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane::_internal_mutable_service_gateway_id() {
  
  return service_gateway_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceGatewayUserPlane::release_service_gateway_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.service_gateway_id)
  return service_gateway_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceGatewayUserPlane::set_allocated_service_gateway_id(std::string* service_gateway_id) {
  if (service_gateway_id != nullptr) {
    
  } else {
    
  }
  service_gateway_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_gateway_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_gateway_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_gateway_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.service_gateway_id)
}

// .bbf.sss.MetaData metadata = 3;
inline bool ServiceGatewayUserPlane::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool ServiceGatewayUserPlane::has_metadata() const {
  return _internal_has_metadata();
}
inline void ServiceGatewayUserPlane::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::bbf::sss::MetaData& ServiceGatewayUserPlane::_internal_metadata() const {
  const ::bbf::sss::MetaData* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::MetaData&>(
      ::bbf::sss::_MetaData_default_instance_);
}
inline const ::bbf::sss::MetaData& ServiceGatewayUserPlane::metadata() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.metadata)
  return _internal_metadata();
}
inline void ServiceGatewayUserPlane::unsafe_arena_set_allocated_metadata(
    ::bbf::sss::MetaData* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ServiceGatewayUserPlane.metadata)
}
inline ::bbf::sss::MetaData* ServiceGatewayUserPlane::release_metadata() {
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::MetaData* ServiceGatewayUserPlane::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.metadata)
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::bbf::sss::MetaData* ServiceGatewayUserPlane::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::MetaData>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::bbf::sss::MetaData* ServiceGatewayUserPlane::mutable_metadata() {
  ::bbf::sss::MetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.metadata)
  return _msg;
}
inline void ServiceGatewayUserPlane::set_allocated_metadata(::bbf::sss::MetaData* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::MetaData>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.metadata)
}

// .bbf.sss.ServiceGatewayUserPlane.Spec spec = 4;
inline bool ServiceGatewayUserPlane::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool ServiceGatewayUserPlane::has_spec() const {
  return _internal_has_spec();
}
inline void ServiceGatewayUserPlane::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::bbf::sss::ServiceGatewayUserPlane_Spec& ServiceGatewayUserPlane::_internal_spec() const {
  const ::bbf::sss::ServiceGatewayUserPlane_Spec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ServiceGatewayUserPlane_Spec&>(
      ::bbf::sss::_ServiceGatewayUserPlane_Spec_default_instance_);
}
inline const ::bbf::sss::ServiceGatewayUserPlane_Spec& ServiceGatewayUserPlane::spec() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.spec)
  return _internal_spec();
}
inline void ServiceGatewayUserPlane::unsafe_arena_set_allocated_spec(
    ::bbf::sss::ServiceGatewayUserPlane_Spec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ServiceGatewayUserPlane.spec)
}
inline ::bbf::sss::ServiceGatewayUserPlane_Spec* ServiceGatewayUserPlane::release_spec() {
  
  ::bbf::sss::ServiceGatewayUserPlane_Spec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane_Spec* ServiceGatewayUserPlane::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.spec)
  
  ::bbf::sss::ServiceGatewayUserPlane_Spec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane_Spec* ServiceGatewayUserPlane::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlane_Spec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::bbf::sss::ServiceGatewayUserPlane_Spec* ServiceGatewayUserPlane::mutable_spec() {
  ::bbf::sss::ServiceGatewayUserPlane_Spec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.spec)
  return _msg;
}
inline void ServiceGatewayUserPlane::set_allocated_spec(::bbf::sss::ServiceGatewayUserPlane_Spec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ServiceGatewayUserPlane_Spec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.spec)
}

// .bbf.sss.ServiceGatewayUserPlane.Status status = 5;
inline bool ServiceGatewayUserPlane::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ServiceGatewayUserPlane::has_status() const {
  return _internal_has_status();
}
inline void ServiceGatewayUserPlane::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::bbf::sss::ServiceGatewayUserPlane_Status& ServiceGatewayUserPlane::_internal_status() const {
  const ::bbf::sss::ServiceGatewayUserPlane_Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::ServiceGatewayUserPlane_Status&>(
      ::bbf::sss::_ServiceGatewayUserPlane_Status_default_instance_);
}
inline const ::bbf::sss::ServiceGatewayUserPlane_Status& ServiceGatewayUserPlane::status() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGatewayUserPlane.status)
  return _internal_status();
}
inline void ServiceGatewayUserPlane::unsafe_arena_set_allocated_status(
    ::bbf::sss::ServiceGatewayUserPlane_Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ServiceGatewayUserPlane.status)
}
inline ::bbf::sss::ServiceGatewayUserPlane_Status* ServiceGatewayUserPlane::release_status() {
  
  ::bbf::sss::ServiceGatewayUserPlane_Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane_Status* ServiceGatewayUserPlane::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGatewayUserPlane.status)
  
  ::bbf::sss::ServiceGatewayUserPlane_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::bbf::sss::ServiceGatewayUserPlane_Status* ServiceGatewayUserPlane::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::ServiceGatewayUserPlane_Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::bbf::sss::ServiceGatewayUserPlane_Status* ServiceGatewayUserPlane::mutable_status() {
  ::bbf::sss::ServiceGatewayUserPlane_Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGatewayUserPlane.status)
  return _msg;
}
inline void ServiceGatewayUserPlane::set_allocated_status(::bbf::sss::ServiceGatewayUserPlane_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::ServiceGatewayUserPlane_Status>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGatewayUserPlane.status)
}

// -------------------------------------------------------------------

// Shard_Spec

// int32 max_session_count = 1;
inline void Shard_Spec::clear_max_session_count() {
  max_session_count_ = 0;
}
inline int32_t Shard_Spec::_internal_max_session_count() const {
  return max_session_count_;
}
inline int32_t Shard_Spec::max_session_count() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.Spec.max_session_count)
  return _internal_max_session_count();
}
inline void Shard_Spec::_internal_set_max_session_count(int32_t value) {
  
  max_session_count_ = value;
}
inline void Shard_Spec::set_max_session_count(int32_t value) {
  _internal_set_max_session_count(value);
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Spec.max_session_count)
}

// string desired_service_gateway_user_plane = 2;
inline void Shard_Spec::clear_desired_service_gateway_user_plane() {
  desired_service_gateway_user_plane_.ClearToEmpty();
}
inline const std::string& Shard_Spec::desired_service_gateway_user_plane() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.Spec.desired_service_gateway_user_plane)
  return _internal_desired_service_gateway_user_plane();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shard_Spec::set_desired_service_gateway_user_plane(ArgT0&& arg0, ArgT... args) {
 
 desired_service_gateway_user_plane_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Spec.desired_service_gateway_user_plane)
}
inline std::string* Shard_Spec::mutable_desired_service_gateway_user_plane() {
  std::string* _s = _internal_mutable_desired_service_gateway_user_plane();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.Spec.desired_service_gateway_user_plane)
  return _s;
}
inline const std::string& Shard_Spec::_internal_desired_service_gateway_user_plane() const {
  return desired_service_gateway_user_plane_.Get();
}
inline void Shard_Spec::_internal_set_desired_service_gateway_user_plane(const std::string& value) {
  
  desired_service_gateway_user_plane_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Shard_Spec::_internal_mutable_desired_service_gateway_user_plane() {
  
  return desired_service_gateway_user_plane_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Shard_Spec::release_desired_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_release:bbf.sss.Shard.Spec.desired_service_gateway_user_plane)
  return desired_service_gateway_user_plane_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Shard_Spec::set_allocated_desired_service_gateway_user_plane(std::string* desired_service_gateway_user_plane) {
  if (desired_service_gateway_user_plane != nullptr) {
    
  } else {
    
  }
  desired_service_gateway_user_plane_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desired_service_gateway_user_plane,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desired_service_gateway_user_plane_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    desired_service_gateway_user_plane_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.Shard.Spec.desired_service_gateway_user_plane)
}

// repeated string desired_network_connection = 3;
inline int Shard_Spec::_internal_desired_network_connection_size() const {
  return desired_network_connection_.size();
}
inline int Shard_Spec::desired_network_connection_size() const {
  return _internal_desired_network_connection_size();
}
inline void Shard_Spec::clear_desired_network_connection() {
  desired_network_connection_.Clear();
}
inline std::string* Shard_Spec::add_desired_network_connection() {
  std::string* _s = _internal_add_desired_network_connection();
  // @@protoc_insertion_point(field_add_mutable:bbf.sss.Shard.Spec.desired_network_connection)
  return _s;
}
inline const std::string& Shard_Spec::_internal_desired_network_connection(int index) const {
  return desired_network_connection_.Get(index);
}
inline const std::string& Shard_Spec::desired_network_connection(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.Spec.desired_network_connection)
  return _internal_desired_network_connection(index);
}
inline std::string* Shard_Spec::mutable_desired_network_connection(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.Spec.desired_network_connection)
  return desired_network_connection_.Mutable(index);
}
inline void Shard_Spec::set_desired_network_connection(int index, const std::string& value) {
  desired_network_connection_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Spec.desired_network_connection)
}
inline void Shard_Spec::set_desired_network_connection(int index, std::string&& value) {
  desired_network_connection_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Spec.desired_network_connection)
}
inline void Shard_Spec::set_desired_network_connection(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  desired_network_connection_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bbf.sss.Shard.Spec.desired_network_connection)
}
inline void Shard_Spec::set_desired_network_connection(int index, const char* value, size_t size) {
  desired_network_connection_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bbf.sss.Shard.Spec.desired_network_connection)
}
inline std::string* Shard_Spec::_internal_add_desired_network_connection() {
  return desired_network_connection_.Add();
}
inline void Shard_Spec::add_desired_network_connection(const std::string& value) {
  desired_network_connection_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bbf.sss.Shard.Spec.desired_network_connection)
}
inline void Shard_Spec::add_desired_network_connection(std::string&& value) {
  desired_network_connection_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bbf.sss.Shard.Spec.desired_network_connection)
}
inline void Shard_Spec::add_desired_network_connection(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  desired_network_connection_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bbf.sss.Shard.Spec.desired_network_connection)
}
inline void Shard_Spec::add_desired_network_connection(const char* value, size_t size) {
  desired_network_connection_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bbf.sss.Shard.Spec.desired_network_connection)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Shard_Spec::desired_network_connection() const {
  // @@protoc_insertion_point(field_list:bbf.sss.Shard.Spec.desired_network_connection)
  return desired_network_connection_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Shard_Spec::mutable_desired_network_connection() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.Shard.Spec.desired_network_connection)
  return &desired_network_connection_;
}

// string required_qos = 4;
inline void Shard_Spec::clear_required_qos() {
  required_qos_.ClearToEmpty();
}
inline const std::string& Shard_Spec::required_qos() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.Spec.required_qos)
  return _internal_required_qos();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shard_Spec::set_required_qos(ArgT0&& arg0, ArgT... args) {
 
 required_qos_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Spec.required_qos)
}
inline std::string* Shard_Spec::mutable_required_qos() {
  std::string* _s = _internal_mutable_required_qos();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.Spec.required_qos)
  return _s;
}
inline const std::string& Shard_Spec::_internal_required_qos() const {
  return required_qos_.Get();
}
inline void Shard_Spec::_internal_set_required_qos(const std::string& value) {
  
  required_qos_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Shard_Spec::_internal_mutable_required_qos() {
  
  return required_qos_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Shard_Spec::release_required_qos() {
  // @@protoc_insertion_point(field_release:bbf.sss.Shard.Spec.required_qos)
  return required_qos_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Shard_Spec::set_allocated_required_qos(std::string* required_qos) {
  if (required_qos != nullptr) {
    
  } else {
    
  }
  required_qos_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), required_qos,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (required_qos_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    required_qos_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.Shard.Spec.required_qos)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Shard_Status

// string current_service_gateway_user_plane = 1;
inline void Shard_Status::clear_current_service_gateway_user_plane() {
  current_service_gateway_user_plane_.ClearToEmpty();
}
inline const std::string& Shard_Status::current_service_gateway_user_plane() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.Status.current_service_gateway_user_plane)
  return _internal_current_service_gateway_user_plane();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shard_Status::set_current_service_gateway_user_plane(ArgT0&& arg0, ArgT... args) {
 
 current_service_gateway_user_plane_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Status.current_service_gateway_user_plane)
}
inline std::string* Shard_Status::mutable_current_service_gateway_user_plane() {
  std::string* _s = _internal_mutable_current_service_gateway_user_plane();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.Status.current_service_gateway_user_plane)
  return _s;
}
inline const std::string& Shard_Status::_internal_current_service_gateway_user_plane() const {
  return current_service_gateway_user_plane_.Get();
}
inline void Shard_Status::_internal_set_current_service_gateway_user_plane(const std::string& value) {
  
  current_service_gateway_user_plane_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Shard_Status::_internal_mutable_current_service_gateway_user_plane() {
  
  return current_service_gateway_user_plane_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Shard_Status::release_current_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_release:bbf.sss.Shard.Status.current_service_gateway_user_plane)
  return current_service_gateway_user_plane_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Shard_Status::set_allocated_current_service_gateway_user_plane(std::string* current_service_gateway_user_plane) {
  if (current_service_gateway_user_plane != nullptr) {
    
  } else {
    
  }
  current_service_gateway_user_plane_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_service_gateway_user_plane,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_service_gateway_user_plane_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    current_service_gateway_user_plane_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.Shard.Status.current_service_gateway_user_plane)
}

// map<string, string> tsf_network_connection = 2;
inline int Shard_Status::_internal_tsf_network_connection_size() const {
  return tsf_network_connection_.size();
}
inline int Shard_Status::tsf_network_connection_size() const {
  return _internal_tsf_network_connection_size();
}
inline void Shard_Status::clear_tsf_network_connection() {
  tsf_network_connection_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Shard_Status::_internal_tsf_network_connection() const {
  return tsf_network_connection_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Shard_Status::tsf_network_connection() const {
  // @@protoc_insertion_point(field_map:bbf.sss.Shard.Status.tsf_network_connection)
  return _internal_tsf_network_connection();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Shard_Status::_internal_mutable_tsf_network_connection() {
  return tsf_network_connection_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Shard_Status::mutable_tsf_network_connection() {
  // @@protoc_insertion_point(field_mutable_map:bbf.sss.Shard.Status.tsf_network_connection)
  return _internal_mutable_tsf_network_connection();
}

// repeated string ip_prefixes = 3;
inline int Shard_Status::_internal_ip_prefixes_size() const {
  return ip_prefixes_.size();
}
inline int Shard_Status::ip_prefixes_size() const {
  return _internal_ip_prefixes_size();
}
inline void Shard_Status::clear_ip_prefixes() {
  ip_prefixes_.Clear();
}
inline std::string* Shard_Status::add_ip_prefixes() {
  std::string* _s = _internal_add_ip_prefixes();
  // @@protoc_insertion_point(field_add_mutable:bbf.sss.Shard.Status.ip_prefixes)
  return _s;
}
inline const std::string& Shard_Status::_internal_ip_prefixes(int index) const {
  return ip_prefixes_.Get(index);
}
inline const std::string& Shard_Status::ip_prefixes(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.Status.ip_prefixes)
  return _internal_ip_prefixes(index);
}
inline std::string* Shard_Status::mutable_ip_prefixes(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.Status.ip_prefixes)
  return ip_prefixes_.Mutable(index);
}
inline void Shard_Status::set_ip_prefixes(int index, const std::string& value) {
  ip_prefixes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Status.ip_prefixes)
}
inline void Shard_Status::set_ip_prefixes(int index, std::string&& value) {
  ip_prefixes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.Status.ip_prefixes)
}
inline void Shard_Status::set_ip_prefixes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_prefixes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bbf.sss.Shard.Status.ip_prefixes)
}
inline void Shard_Status::set_ip_prefixes(int index, const char* value, size_t size) {
  ip_prefixes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bbf.sss.Shard.Status.ip_prefixes)
}
inline std::string* Shard_Status::_internal_add_ip_prefixes() {
  return ip_prefixes_.Add();
}
inline void Shard_Status::add_ip_prefixes(const std::string& value) {
  ip_prefixes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bbf.sss.Shard.Status.ip_prefixes)
}
inline void Shard_Status::add_ip_prefixes(std::string&& value) {
  ip_prefixes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bbf.sss.Shard.Status.ip_prefixes)
}
inline void Shard_Status::add_ip_prefixes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_prefixes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bbf.sss.Shard.Status.ip_prefixes)
}
inline void Shard_Status::add_ip_prefixes(const char* value, size_t size) {
  ip_prefixes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bbf.sss.Shard.Status.ip_prefixes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Shard_Status::ip_prefixes() const {
  // @@protoc_insertion_point(field_list:bbf.sss.Shard.Status.ip_prefixes)
  return ip_prefixes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Shard_Status::mutable_ip_prefixes() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.Shard.Status.ip_prefixes)
  return &ip_prefixes_;
}

// -------------------------------------------------------------------

// Shard

// string id = 1;
inline void Shard::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Shard::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Shard::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.Shard.id)
}
inline std::string* Shard::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.id)
  return _s;
}
inline const std::string& Shard::_internal_id() const {
  return id_.Get();
}
inline void Shard::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Shard::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Shard::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.Shard.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Shard::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.Shard.id)
}

// .bbf.sss.MetaData metadata = 2;
inline bool Shard::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool Shard::has_metadata() const {
  return _internal_has_metadata();
}
inline void Shard::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::bbf::sss::MetaData& Shard::_internal_metadata() const {
  const ::bbf::sss::MetaData* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::MetaData&>(
      ::bbf::sss::_MetaData_default_instance_);
}
inline const ::bbf::sss::MetaData& Shard::metadata() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.metadata)
  return _internal_metadata();
}
inline void Shard::unsafe_arena_set_allocated_metadata(
    ::bbf::sss::MetaData* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Shard.metadata)
}
inline ::bbf::sss::MetaData* Shard::release_metadata() {
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::MetaData* Shard::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bbf.sss.Shard.metadata)
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::bbf::sss::MetaData* Shard::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::MetaData>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::bbf::sss::MetaData* Shard::mutable_metadata() {
  ::bbf::sss::MetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.metadata)
  return _msg;
}
inline void Shard::set_allocated_metadata(::bbf::sss::MetaData* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::MetaData>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.Shard.metadata)
}

// .bbf.sss.Shard.Spec spec = 3;
inline bool Shard::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Shard::has_spec() const {
  return _internal_has_spec();
}
inline void Shard::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::bbf::sss::Shard_Spec& Shard::_internal_spec() const {
  const ::bbf::sss::Shard_Spec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::Shard_Spec&>(
      ::bbf::sss::_Shard_Spec_default_instance_);
}
inline const ::bbf::sss::Shard_Spec& Shard::spec() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.spec)
  return _internal_spec();
}
inline void Shard::unsafe_arena_set_allocated_spec(
    ::bbf::sss::Shard_Spec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Shard.spec)
}
inline ::bbf::sss::Shard_Spec* Shard::release_spec() {
  
  ::bbf::sss::Shard_Spec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::Shard_Spec* Shard::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bbf.sss.Shard.spec)
  
  ::bbf::sss::Shard_Spec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::bbf::sss::Shard_Spec* Shard::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::Shard_Spec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::bbf::sss::Shard_Spec* Shard::mutable_spec() {
  ::bbf::sss::Shard_Spec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.spec)
  return _msg;
}
inline void Shard::set_allocated_spec(::bbf::sss::Shard_Spec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::Shard_Spec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.Shard.spec)
}

// .bbf.sss.Shard.Status status = 4;
inline bool Shard::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool Shard::has_status() const {
  return _internal_has_status();
}
inline void Shard::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::bbf::sss::Shard_Status& Shard::_internal_status() const {
  const ::bbf::sss::Shard_Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::Shard_Status&>(
      ::bbf::sss::_Shard_Status_default_instance_);
}
inline const ::bbf::sss::Shard_Status& Shard::status() const {
  // @@protoc_insertion_point(field_get:bbf.sss.Shard.status)
  return _internal_status();
}
inline void Shard::unsafe_arena_set_allocated_status(
    ::bbf::sss::Shard_Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.Shard.status)
}
inline ::bbf::sss::Shard_Status* Shard::release_status() {
  
  ::bbf::sss::Shard_Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::Shard_Status* Shard::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:bbf.sss.Shard.status)
  
  ::bbf::sss::Shard_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::bbf::sss::Shard_Status* Shard::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::Shard_Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::bbf::sss::Shard_Status* Shard::mutable_status() {
  ::bbf::sss::Shard_Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:bbf.sss.Shard.status)
  return _msg;
}
inline void Shard::set_allocated_status(::bbf::sss::Shard_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::Shard_Status>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.Shard.status)
}

// -------------------------------------------------------------------

// TrafficSteeringFunction_Spec

// string ip_address = 9901;
inline void TrafficSteeringFunction_Spec::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& TrafficSteeringFunction_Spec::ip_address() const {
  // @@protoc_insertion_point(field_get:bbf.sss.TrafficSteeringFunction.Spec.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrafficSteeringFunction_Spec::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.TrafficSteeringFunction.Spec.ip_address)
}
inline std::string* TrafficSteeringFunction_Spec::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:bbf.sss.TrafficSteeringFunction.Spec.ip_address)
  return _s;
}
inline const std::string& TrafficSteeringFunction_Spec::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void TrafficSteeringFunction_Spec::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrafficSteeringFunction_Spec::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrafficSteeringFunction_Spec::release_ip_address() {
  // @@protoc_insertion_point(field_release:bbf.sss.TrafficSteeringFunction.Spec.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrafficSteeringFunction_Spec::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.TrafficSteeringFunction.Spec.ip_address)
}

// string mac = 9903;
inline void TrafficSteeringFunction_Spec::clear_mac() {
  mac_.ClearToEmpty();
}
inline const std::string& TrafficSteeringFunction_Spec::mac() const {
  // @@protoc_insertion_point(field_get:bbf.sss.TrafficSteeringFunction.Spec.mac)
  return _internal_mac();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrafficSteeringFunction_Spec::set_mac(ArgT0&& arg0, ArgT... args) {
 
 mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.TrafficSteeringFunction.Spec.mac)
}
inline std::string* TrafficSteeringFunction_Spec::mutable_mac() {
  std::string* _s = _internal_mutable_mac();
  // @@protoc_insertion_point(field_mutable:bbf.sss.TrafficSteeringFunction.Spec.mac)
  return _s;
}
inline const std::string& TrafficSteeringFunction_Spec::_internal_mac() const {
  return mac_.Get();
}
inline void TrafficSteeringFunction_Spec::_internal_set_mac(const std::string& value) {
  
  mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrafficSteeringFunction_Spec::_internal_mutable_mac() {
  
  return mac_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrafficSteeringFunction_Spec::release_mac() {
  // @@protoc_insertion_point(field_release:bbf.sss.TrafficSteeringFunction.Spec.mac)
  return mac_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrafficSteeringFunction_Spec::set_allocated_mac(std::string* mac) {
  if (mac != nullptr) {
    
  } else {
    
  }
  mac_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.TrafficSteeringFunction.Spec.mac)
}

// -------------------------------------------------------------------

// TrafficSteeringFunction

// string id = 1;
inline void TrafficSteeringFunction::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& TrafficSteeringFunction::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.TrafficSteeringFunction.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TrafficSteeringFunction::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.TrafficSteeringFunction.id)
}
inline std::string* TrafficSteeringFunction::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.TrafficSteeringFunction.id)
  return _s;
}
inline const std::string& TrafficSteeringFunction::_internal_id() const {
  return id_.Get();
}
inline void TrafficSteeringFunction::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TrafficSteeringFunction::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TrafficSteeringFunction::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.TrafficSteeringFunction.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TrafficSteeringFunction::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.TrafficSteeringFunction.id)
}

// .bbf.sss.MetaData metadata = 2;
inline bool TrafficSteeringFunction::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool TrafficSteeringFunction::has_metadata() const {
  return _internal_has_metadata();
}
inline void TrafficSteeringFunction::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::bbf::sss::MetaData& TrafficSteeringFunction::_internal_metadata() const {
  const ::bbf::sss::MetaData* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::MetaData&>(
      ::bbf::sss::_MetaData_default_instance_);
}
inline const ::bbf::sss::MetaData& TrafficSteeringFunction::metadata() const {
  // @@protoc_insertion_point(field_get:bbf.sss.TrafficSteeringFunction.metadata)
  return _internal_metadata();
}
inline void TrafficSteeringFunction::unsafe_arena_set_allocated_metadata(
    ::bbf::sss::MetaData* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.TrafficSteeringFunction.metadata)
}
inline ::bbf::sss::MetaData* TrafficSteeringFunction::release_metadata() {
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::MetaData* TrafficSteeringFunction::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bbf.sss.TrafficSteeringFunction.metadata)
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::bbf::sss::MetaData* TrafficSteeringFunction::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::MetaData>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::bbf::sss::MetaData* TrafficSteeringFunction::mutable_metadata() {
  ::bbf::sss::MetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bbf.sss.TrafficSteeringFunction.metadata)
  return _msg;
}
inline void TrafficSteeringFunction::set_allocated_metadata(::bbf::sss::MetaData* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::MetaData>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.TrafficSteeringFunction.metadata)
}

// .bbf.sss.TrafficSteeringFunction.Spec spec = 3;
inline bool TrafficSteeringFunction::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool TrafficSteeringFunction::has_spec() const {
  return _internal_has_spec();
}
inline void TrafficSteeringFunction::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::bbf::sss::TrafficSteeringFunction_Spec& TrafficSteeringFunction::_internal_spec() const {
  const ::bbf::sss::TrafficSteeringFunction_Spec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::TrafficSteeringFunction_Spec&>(
      ::bbf::sss::_TrafficSteeringFunction_Spec_default_instance_);
}
inline const ::bbf::sss::TrafficSteeringFunction_Spec& TrafficSteeringFunction::spec() const {
  // @@protoc_insertion_point(field_get:bbf.sss.TrafficSteeringFunction.spec)
  return _internal_spec();
}
inline void TrafficSteeringFunction::unsafe_arena_set_allocated_spec(
    ::bbf::sss::TrafficSteeringFunction_Spec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.TrafficSteeringFunction.spec)
}
inline ::bbf::sss::TrafficSteeringFunction_Spec* TrafficSteeringFunction::release_spec() {
  
  ::bbf::sss::TrafficSteeringFunction_Spec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::TrafficSteeringFunction_Spec* TrafficSteeringFunction::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bbf.sss.TrafficSteeringFunction.spec)
  
  ::bbf::sss::TrafficSteeringFunction_Spec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::bbf::sss::TrafficSteeringFunction_Spec* TrafficSteeringFunction::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::TrafficSteeringFunction_Spec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::bbf::sss::TrafficSteeringFunction_Spec* TrafficSteeringFunction::mutable_spec() {
  ::bbf::sss::TrafficSteeringFunction_Spec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bbf.sss.TrafficSteeringFunction.spec)
  return _msg;
}
inline void TrafficSteeringFunction::set_allocated_spec(::bbf::sss::TrafficSteeringFunction_Spec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::TrafficSteeringFunction_Spec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.TrafficSteeringFunction.spec)
}

// -------------------------------------------------------------------

// ServiceGateway

// string id = 1;
inline void ServiceGateway::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& ServiceGateway::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGateway.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceGateway::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.ServiceGateway.id)
}
inline std::string* ServiceGateway::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGateway.id)
  return _s;
}
inline const std::string& ServiceGateway::_internal_id() const {
  return id_.Get();
}
inline void ServiceGateway::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceGateway::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceGateway::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGateway.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceGateway::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGateway.id)
}

// .bbf.sss.MetaData metadata = 2;
inline bool ServiceGateway::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool ServiceGateway::has_metadata() const {
  return _internal_has_metadata();
}
inline void ServiceGateway::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::bbf::sss::MetaData& ServiceGateway::_internal_metadata() const {
  const ::bbf::sss::MetaData* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::MetaData&>(
      ::bbf::sss::_MetaData_default_instance_);
}
inline const ::bbf::sss::MetaData& ServiceGateway::metadata() const {
  // @@protoc_insertion_point(field_get:bbf.sss.ServiceGateway.metadata)
  return _internal_metadata();
}
inline void ServiceGateway::unsafe_arena_set_allocated_metadata(
    ::bbf::sss::MetaData* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.ServiceGateway.metadata)
}
inline ::bbf::sss::MetaData* ServiceGateway::release_metadata() {
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::MetaData* ServiceGateway::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bbf.sss.ServiceGateway.metadata)
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::bbf::sss::MetaData* ServiceGateway::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::MetaData>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::bbf::sss::MetaData* ServiceGateway::mutable_metadata() {
  ::bbf::sss::MetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bbf.sss.ServiceGateway.metadata)
  return _msg;
}
inline void ServiceGateway::set_allocated_metadata(::bbf::sss::MetaData* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::MetaData>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.ServiceGateway.metadata)
}

// -------------------------------------------------------------------

// NetworkConnection_Spec

// string traffic_steering_function = 1;
inline void NetworkConnection_Spec::clear_traffic_steering_function() {
  traffic_steering_function_.ClearToEmpty();
}
inline const std::string& NetworkConnection_Spec::traffic_steering_function() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.Spec.traffic_steering_function)
  return _internal_traffic_steering_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConnection_Spec::set_traffic_steering_function(ArgT0&& arg0, ArgT... args) {
 
 traffic_steering_function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.NetworkConnection.Spec.traffic_steering_function)
}
inline std::string* NetworkConnection_Spec::mutable_traffic_steering_function() {
  std::string* _s = _internal_mutable_traffic_steering_function();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnection.Spec.traffic_steering_function)
  return _s;
}
inline const std::string& NetworkConnection_Spec::_internal_traffic_steering_function() const {
  return traffic_steering_function_.Get();
}
inline void NetworkConnection_Spec::_internal_set_traffic_steering_function(const std::string& value) {
  
  traffic_steering_function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkConnection_Spec::_internal_mutable_traffic_steering_function() {
  
  return traffic_steering_function_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkConnection_Spec::release_traffic_steering_function() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnection.Spec.traffic_steering_function)
  return traffic_steering_function_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkConnection_Spec::set_allocated_traffic_steering_function(std::string* traffic_steering_function) {
  if (traffic_steering_function != nullptr) {
    
  } else {
    
  }
  traffic_steering_function_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), traffic_steering_function,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (traffic_steering_function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    traffic_steering_function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.NetworkConnection.Spec.traffic_steering_function)
}

// string service_gateway_user_plane = 2;
inline void NetworkConnection_Spec::clear_service_gateway_user_plane() {
  service_gateway_user_plane_.ClearToEmpty();
}
inline const std::string& NetworkConnection_Spec::service_gateway_user_plane() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.Spec.service_gateway_user_plane)
  return _internal_service_gateway_user_plane();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConnection_Spec::set_service_gateway_user_plane(ArgT0&& arg0, ArgT... args) {
 
 service_gateway_user_plane_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.NetworkConnection.Spec.service_gateway_user_plane)
}
inline std::string* NetworkConnection_Spec::mutable_service_gateway_user_plane() {
  std::string* _s = _internal_mutable_service_gateway_user_plane();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnection.Spec.service_gateway_user_plane)
  return _s;
}
inline const std::string& NetworkConnection_Spec::_internal_service_gateway_user_plane() const {
  return service_gateway_user_plane_.Get();
}
inline void NetworkConnection_Spec::_internal_set_service_gateway_user_plane(const std::string& value) {
  
  service_gateway_user_plane_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkConnection_Spec::_internal_mutable_service_gateway_user_plane() {
  
  return service_gateway_user_plane_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkConnection_Spec::release_service_gateway_user_plane() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnection.Spec.service_gateway_user_plane)
  return service_gateway_user_plane_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkConnection_Spec::set_allocated_service_gateway_user_plane(std::string* service_gateway_user_plane) {
  if (service_gateway_user_plane != nullptr) {
    
  } else {
    
  }
  service_gateway_user_plane_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_gateway_user_plane,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_gateway_user_plane_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_gateway_user_plane_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.NetworkConnection.Spec.service_gateway_user_plane)
}

// .bbf.sss.VxlanConnection vxlan = 3;
inline bool NetworkConnection_Spec::_internal_has_vxlan() const {
  return transport_case() == kVxlan;
}
inline bool NetworkConnection_Spec::has_vxlan() const {
  return _internal_has_vxlan();
}
inline void NetworkConnection_Spec::set_has_vxlan() {
  _oneof_case_[0] = kVxlan;
}
inline void NetworkConnection_Spec::clear_vxlan() {
  if (_internal_has_vxlan()) {
    if (GetArenaForAllocation() == nullptr) {
      delete transport_.vxlan_;
    }
    clear_has_transport();
  }
}
inline ::bbf::sss::VxlanConnection* NetworkConnection_Spec::release_vxlan() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnection.Spec.vxlan)
  if (_internal_has_vxlan()) {
    clear_has_transport();
      ::bbf::sss::VxlanConnection* temp = transport_.vxlan_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    transport_.vxlan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::bbf::sss::VxlanConnection& NetworkConnection_Spec::_internal_vxlan() const {
  return _internal_has_vxlan()
      ? *transport_.vxlan_
      : reinterpret_cast< ::bbf::sss::VxlanConnection&>(::bbf::sss::_VxlanConnection_default_instance_);
}
inline const ::bbf::sss::VxlanConnection& NetworkConnection_Spec::vxlan() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.Spec.vxlan)
  return _internal_vxlan();
}
inline ::bbf::sss::VxlanConnection* NetworkConnection_Spec::unsafe_arena_release_vxlan() {
  // @@protoc_insertion_point(field_unsafe_arena_release:bbf.sss.NetworkConnection.Spec.vxlan)
  if (_internal_has_vxlan()) {
    clear_has_transport();
    ::bbf::sss::VxlanConnection* temp = transport_.vxlan_;
    transport_.vxlan_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NetworkConnection_Spec::unsafe_arena_set_allocated_vxlan(::bbf::sss::VxlanConnection* vxlan) {
  clear_transport();
  if (vxlan) {
    set_has_vxlan();
    transport_.vxlan_ = vxlan;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.NetworkConnection.Spec.vxlan)
}
inline ::bbf::sss::VxlanConnection* NetworkConnection_Spec::_internal_mutable_vxlan() {
  if (!_internal_has_vxlan()) {
    clear_transport();
    set_has_vxlan();
    transport_.vxlan_ = CreateMaybeMessage< ::bbf::sss::VxlanConnection >(GetArenaForAllocation());
  }
  return transport_.vxlan_;
}
inline ::bbf::sss::VxlanConnection* NetworkConnection_Spec::mutable_vxlan() {
  ::bbf::sss::VxlanConnection* _msg = _internal_mutable_vxlan();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnection.Spec.vxlan)
  return _msg;
}

inline bool NetworkConnection_Spec::has_transport() const {
  return transport_case() != TRANSPORT_NOT_SET;
}
inline void NetworkConnection_Spec::clear_has_transport() {
  _oneof_case_[0] = TRANSPORT_NOT_SET;
}
inline NetworkConnection_Spec::TransportCase NetworkConnection_Spec::transport_case() const {
  return NetworkConnection_Spec::TransportCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NetworkConnection_Status

// .bbf.sss.NetworkConnection.Status.NcEndpointStatus nc_traffic_steering_function_status = 1;
inline void NetworkConnection_Status::clear_nc_traffic_steering_function_status() {
  nc_traffic_steering_function_status_ = 0;
}
inline ::bbf::sss::NetworkConnection_Status_NcEndpointStatus NetworkConnection_Status::_internal_nc_traffic_steering_function_status() const {
  return static_cast< ::bbf::sss::NetworkConnection_Status_NcEndpointStatus >(nc_traffic_steering_function_status_);
}
inline ::bbf::sss::NetworkConnection_Status_NcEndpointStatus NetworkConnection_Status::nc_traffic_steering_function_status() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.Status.nc_traffic_steering_function_status)
  return _internal_nc_traffic_steering_function_status();
}
inline void NetworkConnection_Status::_internal_set_nc_traffic_steering_function_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value) {
  
  nc_traffic_steering_function_status_ = value;
}
inline void NetworkConnection_Status::set_nc_traffic_steering_function_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value) {
  _internal_set_nc_traffic_steering_function_status(value);
  // @@protoc_insertion_point(field_set:bbf.sss.NetworkConnection.Status.nc_traffic_steering_function_status)
}

// .bbf.sss.NetworkConnection.Status.NcEndpointStatus nc_service_gateway_user_plane_status = 2;
inline void NetworkConnection_Status::clear_nc_service_gateway_user_plane_status() {
  nc_service_gateway_user_plane_status_ = 0;
}
inline ::bbf::sss::NetworkConnection_Status_NcEndpointStatus NetworkConnection_Status::_internal_nc_service_gateway_user_plane_status() const {
  return static_cast< ::bbf::sss::NetworkConnection_Status_NcEndpointStatus >(nc_service_gateway_user_plane_status_);
}
inline ::bbf::sss::NetworkConnection_Status_NcEndpointStatus NetworkConnection_Status::nc_service_gateway_user_plane_status() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.Status.nc_service_gateway_user_plane_status)
  return _internal_nc_service_gateway_user_plane_status();
}
inline void NetworkConnection_Status::_internal_set_nc_service_gateway_user_plane_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value) {
  
  nc_service_gateway_user_plane_status_ = value;
}
inline void NetworkConnection_Status::set_nc_service_gateway_user_plane_status(::bbf::sss::NetworkConnection_Status_NcEndpointStatus value) {
  _internal_set_nc_service_gateway_user_plane_status(value);
  // @@protoc_insertion_point(field_set:bbf.sss.NetworkConnection.Status.nc_service_gateway_user_plane_status)
}

// -------------------------------------------------------------------

// NetworkConnection

// string id = 1;
inline void NetworkConnection::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& NetworkConnection::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NetworkConnection::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.NetworkConnection.id)
}
inline std::string* NetworkConnection::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnection.id)
  return _s;
}
inline const std::string& NetworkConnection::_internal_id() const {
  return id_.Get();
}
inline void NetworkConnection::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NetworkConnection::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NetworkConnection::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnection.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NetworkConnection::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.NetworkConnection.id)
}

// .bbf.sss.MetaData metadata = 2;
inline bool NetworkConnection::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool NetworkConnection::has_metadata() const {
  return _internal_has_metadata();
}
inline void NetworkConnection::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::bbf::sss::MetaData& NetworkConnection::_internal_metadata() const {
  const ::bbf::sss::MetaData* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::MetaData&>(
      ::bbf::sss::_MetaData_default_instance_);
}
inline const ::bbf::sss::MetaData& NetworkConnection::metadata() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.metadata)
  return _internal_metadata();
}
inline void NetworkConnection::unsafe_arena_set_allocated_metadata(
    ::bbf::sss::MetaData* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.NetworkConnection.metadata)
}
inline ::bbf::sss::MetaData* NetworkConnection::release_metadata() {
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::MetaData* NetworkConnection::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnection.metadata)
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::bbf::sss::MetaData* NetworkConnection::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::MetaData>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::bbf::sss::MetaData* NetworkConnection::mutable_metadata() {
  ::bbf::sss::MetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnection.metadata)
  return _msg;
}
inline void NetworkConnection::set_allocated_metadata(::bbf::sss::MetaData* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::MetaData>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.NetworkConnection.metadata)
}

// .bbf.sss.NetworkConnection.Spec spec = 3;
inline bool NetworkConnection::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool NetworkConnection::has_spec() const {
  return _internal_has_spec();
}
inline void NetworkConnection::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::bbf::sss::NetworkConnection_Spec& NetworkConnection::_internal_spec() const {
  const ::bbf::sss::NetworkConnection_Spec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::NetworkConnection_Spec&>(
      ::bbf::sss::_NetworkConnection_Spec_default_instance_);
}
inline const ::bbf::sss::NetworkConnection_Spec& NetworkConnection::spec() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.spec)
  return _internal_spec();
}
inline void NetworkConnection::unsafe_arena_set_allocated_spec(
    ::bbf::sss::NetworkConnection_Spec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.NetworkConnection.spec)
}
inline ::bbf::sss::NetworkConnection_Spec* NetworkConnection::release_spec() {
  
  ::bbf::sss::NetworkConnection_Spec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::NetworkConnection_Spec* NetworkConnection::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnection.spec)
  
  ::bbf::sss::NetworkConnection_Spec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::bbf::sss::NetworkConnection_Spec* NetworkConnection::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::NetworkConnection_Spec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::bbf::sss::NetworkConnection_Spec* NetworkConnection::mutable_spec() {
  ::bbf::sss::NetworkConnection_Spec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnection.spec)
  return _msg;
}
inline void NetworkConnection::set_allocated_spec(::bbf::sss::NetworkConnection_Spec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::NetworkConnection_Spec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.NetworkConnection.spec)
}

// .bbf.sss.NetworkConnection.Status status = 4;
inline bool NetworkConnection::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool NetworkConnection::has_status() const {
  return _internal_has_status();
}
inline void NetworkConnection::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::bbf::sss::NetworkConnection_Status& NetworkConnection::_internal_status() const {
  const ::bbf::sss::NetworkConnection_Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::NetworkConnection_Status&>(
      ::bbf::sss::_NetworkConnection_Status_default_instance_);
}
inline const ::bbf::sss::NetworkConnection_Status& NetworkConnection::status() const {
  // @@protoc_insertion_point(field_get:bbf.sss.NetworkConnection.status)
  return _internal_status();
}
inline void NetworkConnection::unsafe_arena_set_allocated_status(
    ::bbf::sss::NetworkConnection_Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.NetworkConnection.status)
}
inline ::bbf::sss::NetworkConnection_Status* NetworkConnection::release_status() {
  
  ::bbf::sss::NetworkConnection_Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::NetworkConnection_Status* NetworkConnection::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:bbf.sss.NetworkConnection.status)
  
  ::bbf::sss::NetworkConnection_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::bbf::sss::NetworkConnection_Status* NetworkConnection::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::NetworkConnection_Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::bbf::sss::NetworkConnection_Status* NetworkConnection::mutable_status() {
  ::bbf::sss::NetworkConnection_Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:bbf.sss.NetworkConnection.status)
  return _msg;
}
inline void NetworkConnection::set_allocated_status(::bbf::sss::NetworkConnection_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::NetworkConnection_Status>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.NetworkConnection.status)
}

// -------------------------------------------------------------------

// VxlanConnection_Vtep

// string ip_address = 1;
inline void VxlanConnection_Vtep::clear_ip_address() {
  ip_address_.ClearToEmpty();
}
inline const std::string& VxlanConnection_Vtep::ip_address() const {
  // @@protoc_insertion_point(field_get:bbf.sss.VxlanConnection.Vtep.ip_address)
  return _internal_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VxlanConnection_Vtep::set_ip_address(ArgT0&& arg0, ArgT... args) {
 
 ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.VxlanConnection.Vtep.ip_address)
}
inline std::string* VxlanConnection_Vtep::mutable_ip_address() {
  std::string* _s = _internal_mutable_ip_address();
  // @@protoc_insertion_point(field_mutable:bbf.sss.VxlanConnection.Vtep.ip_address)
  return _s;
}
inline const std::string& VxlanConnection_Vtep::_internal_ip_address() const {
  return ip_address_.Get();
}
inline void VxlanConnection_Vtep::_internal_set_ip_address(const std::string& value) {
  
  ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VxlanConnection_Vtep::_internal_mutable_ip_address() {
  
  return ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VxlanConnection_Vtep::release_ip_address() {
  // @@protoc_insertion_point(field_release:bbf.sss.VxlanConnection.Vtep.ip_address)
  return ip_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VxlanConnection_Vtep::set_allocated_ip_address(std::string* ip_address) {
  if (ip_address != nullptr) {
    
  } else {
    
  }
  ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.VxlanConnection.Vtep.ip_address)
}

// int32 udp_port = 2;
inline void VxlanConnection_Vtep::clear_udp_port() {
  udp_port_ = 0;
}
inline int32_t VxlanConnection_Vtep::_internal_udp_port() const {
  return udp_port_;
}
inline int32_t VxlanConnection_Vtep::udp_port() const {
  // @@protoc_insertion_point(field_get:bbf.sss.VxlanConnection.Vtep.udp_port)
  return _internal_udp_port();
}
inline void VxlanConnection_Vtep::_internal_set_udp_port(int32_t value) {
  
  udp_port_ = value;
}
inline void VxlanConnection_Vtep::set_udp_port(int32_t value) {
  _internal_set_udp_port(value);
  // @@protoc_insertion_point(field_set:bbf.sss.VxlanConnection.Vtep.udp_port)
}

// string mac_address = 9903;
inline void VxlanConnection_Vtep::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& VxlanConnection_Vtep::mac_address() const {
  // @@protoc_insertion_point(field_get:bbf.sss.VxlanConnection.Vtep.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VxlanConnection_Vtep::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.VxlanConnection.Vtep.mac_address)
}
inline std::string* VxlanConnection_Vtep::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:bbf.sss.VxlanConnection.Vtep.mac_address)
  return _s;
}
inline const std::string& VxlanConnection_Vtep::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void VxlanConnection_Vtep::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VxlanConnection_Vtep::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VxlanConnection_Vtep::release_mac_address() {
  // @@protoc_insertion_point(field_release:bbf.sss.VxlanConnection.Vtep.mac_address)
  return mac_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VxlanConnection_Vtep::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.VxlanConnection.Vtep.mac_address)
}

// -------------------------------------------------------------------

// VxlanConnection

// .bbf.sss.VxlanConnection.Vtep traffic_steering_function_vni = 1;
inline bool VxlanConnection::_internal_has_traffic_steering_function_vni() const {
  return this != internal_default_instance() && traffic_steering_function_vni_ != nullptr;
}
inline bool VxlanConnection::has_traffic_steering_function_vni() const {
  return _internal_has_traffic_steering_function_vni();
}
inline void VxlanConnection::clear_traffic_steering_function_vni() {
  if (GetArenaForAllocation() == nullptr && traffic_steering_function_vni_ != nullptr) {
    delete traffic_steering_function_vni_;
  }
  traffic_steering_function_vni_ = nullptr;
}
inline const ::bbf::sss::VxlanConnection_Vtep& VxlanConnection::_internal_traffic_steering_function_vni() const {
  const ::bbf::sss::VxlanConnection_Vtep* p = traffic_steering_function_vni_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::VxlanConnection_Vtep&>(
      ::bbf::sss::_VxlanConnection_Vtep_default_instance_);
}
inline const ::bbf::sss::VxlanConnection_Vtep& VxlanConnection::traffic_steering_function_vni() const {
  // @@protoc_insertion_point(field_get:bbf.sss.VxlanConnection.traffic_steering_function_vni)
  return _internal_traffic_steering_function_vni();
}
inline void VxlanConnection::unsafe_arena_set_allocated_traffic_steering_function_vni(
    ::bbf::sss::VxlanConnection_Vtep* traffic_steering_function_vni) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(traffic_steering_function_vni_);
  }
  traffic_steering_function_vni_ = traffic_steering_function_vni;
  if (traffic_steering_function_vni) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.VxlanConnection.traffic_steering_function_vni)
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::release_traffic_steering_function_vni() {
  
  ::bbf::sss::VxlanConnection_Vtep* temp = traffic_steering_function_vni_;
  traffic_steering_function_vni_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::unsafe_arena_release_traffic_steering_function_vni() {
  // @@protoc_insertion_point(field_release:bbf.sss.VxlanConnection.traffic_steering_function_vni)
  
  ::bbf::sss::VxlanConnection_Vtep* temp = traffic_steering_function_vni_;
  traffic_steering_function_vni_ = nullptr;
  return temp;
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::_internal_mutable_traffic_steering_function_vni() {
  
  if (traffic_steering_function_vni_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::VxlanConnection_Vtep>(GetArenaForAllocation());
    traffic_steering_function_vni_ = p;
  }
  return traffic_steering_function_vni_;
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::mutable_traffic_steering_function_vni() {
  ::bbf::sss::VxlanConnection_Vtep* _msg = _internal_mutable_traffic_steering_function_vni();
  // @@protoc_insertion_point(field_mutable:bbf.sss.VxlanConnection.traffic_steering_function_vni)
  return _msg;
}
inline void VxlanConnection::set_allocated_traffic_steering_function_vni(::bbf::sss::VxlanConnection_Vtep* traffic_steering_function_vni) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete traffic_steering_function_vni_;
  }
  if (traffic_steering_function_vni) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::VxlanConnection_Vtep>::GetOwningArena(traffic_steering_function_vni);
    if (message_arena != submessage_arena) {
      traffic_steering_function_vni = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, traffic_steering_function_vni, submessage_arena);
    }
    
  } else {
    
  }
  traffic_steering_function_vni_ = traffic_steering_function_vni;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.VxlanConnection.traffic_steering_function_vni)
}

// .bbf.sss.VxlanConnection.Vtep service_gateway_user_plane_vni = 2;
inline bool VxlanConnection::_internal_has_service_gateway_user_plane_vni() const {
  return this != internal_default_instance() && service_gateway_user_plane_vni_ != nullptr;
}
inline bool VxlanConnection::has_service_gateway_user_plane_vni() const {
  return _internal_has_service_gateway_user_plane_vni();
}
inline void VxlanConnection::clear_service_gateway_user_plane_vni() {
  if (GetArenaForAllocation() == nullptr && service_gateway_user_plane_vni_ != nullptr) {
    delete service_gateway_user_plane_vni_;
  }
  service_gateway_user_plane_vni_ = nullptr;
}
inline const ::bbf::sss::VxlanConnection_Vtep& VxlanConnection::_internal_service_gateway_user_plane_vni() const {
  const ::bbf::sss::VxlanConnection_Vtep* p = service_gateway_user_plane_vni_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::VxlanConnection_Vtep&>(
      ::bbf::sss::_VxlanConnection_Vtep_default_instance_);
}
inline const ::bbf::sss::VxlanConnection_Vtep& VxlanConnection::service_gateway_user_plane_vni() const {
  // @@protoc_insertion_point(field_get:bbf.sss.VxlanConnection.service_gateway_user_plane_vni)
  return _internal_service_gateway_user_plane_vni();
}
inline void VxlanConnection::unsafe_arena_set_allocated_service_gateway_user_plane_vni(
    ::bbf::sss::VxlanConnection_Vtep* service_gateway_user_plane_vni) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_gateway_user_plane_vni_);
  }
  service_gateway_user_plane_vni_ = service_gateway_user_plane_vni;
  if (service_gateway_user_plane_vni) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.VxlanConnection.service_gateway_user_plane_vni)
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::release_service_gateway_user_plane_vni() {
  
  ::bbf::sss::VxlanConnection_Vtep* temp = service_gateway_user_plane_vni_;
  service_gateway_user_plane_vni_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::unsafe_arena_release_service_gateway_user_plane_vni() {
  // @@protoc_insertion_point(field_release:bbf.sss.VxlanConnection.service_gateway_user_plane_vni)
  
  ::bbf::sss::VxlanConnection_Vtep* temp = service_gateway_user_plane_vni_;
  service_gateway_user_plane_vni_ = nullptr;
  return temp;
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::_internal_mutable_service_gateway_user_plane_vni() {
  
  if (service_gateway_user_plane_vni_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::VxlanConnection_Vtep>(GetArenaForAllocation());
    service_gateway_user_plane_vni_ = p;
  }
  return service_gateway_user_plane_vni_;
}
inline ::bbf::sss::VxlanConnection_Vtep* VxlanConnection::mutable_service_gateway_user_plane_vni() {
  ::bbf::sss::VxlanConnection_Vtep* _msg = _internal_mutable_service_gateway_user_plane_vni();
  // @@protoc_insertion_point(field_mutable:bbf.sss.VxlanConnection.service_gateway_user_plane_vni)
  return _msg;
}
inline void VxlanConnection::set_allocated_service_gateway_user_plane_vni(::bbf::sss::VxlanConnection_Vtep* service_gateway_user_plane_vni) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete service_gateway_user_plane_vni_;
  }
  if (service_gateway_user_plane_vni) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::VxlanConnection_Vtep>::GetOwningArena(service_gateway_user_plane_vni);
    if (message_arena != submessage_arena) {
      service_gateway_user_plane_vni = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_gateway_user_plane_vni, submessage_arena);
    }
    
  } else {
    
  }
  service_gateway_user_plane_vni_ = service_gateway_user_plane_vni;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.VxlanConnection.service_gateway_user_plane_vni)
}

// int32 vni = 3;
inline void VxlanConnection::clear_vni() {
  vni_ = 0;
}
inline int32_t VxlanConnection::_internal_vni() const {
  return vni_;
}
inline int32_t VxlanConnection::vni() const {
  // @@protoc_insertion_point(field_get:bbf.sss.VxlanConnection.vni)
  return _internal_vni();
}
inline void VxlanConnection::_internal_set_vni(int32_t value) {
  
  vni_ = value;
}
inline void VxlanConnection::set_vni(int32_t value) {
  _internal_set_vni(value);
  // @@protoc_insertion_point(field_set:bbf.sss.VxlanConnection.vni)
}

// -------------------------------------------------------------------

// SessionContext_Spec

// string traffic_steering_function = 1;
inline void SessionContext_Spec::clear_traffic_steering_function() {
  traffic_steering_function_.ClearToEmpty();
}
inline const std::string& SessionContext_Spec::traffic_steering_function() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.Spec.traffic_steering_function)
  return _internal_traffic_steering_function();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionContext_Spec::set_traffic_steering_function(ArgT0&& arg0, ArgT... args) {
 
 traffic_steering_function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.Spec.traffic_steering_function)
}
inline std::string* SessionContext_Spec::mutable_traffic_steering_function() {
  std::string* _s = _internal_mutable_traffic_steering_function();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.Spec.traffic_steering_function)
  return _s;
}
inline const std::string& SessionContext_Spec::_internal_traffic_steering_function() const {
  return traffic_steering_function_.Get();
}
inline void SessionContext_Spec::_internal_set_traffic_steering_function(const std::string& value) {
  
  traffic_steering_function_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionContext_Spec::_internal_mutable_traffic_steering_function() {
  
  return traffic_steering_function_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionContext_Spec::release_traffic_steering_function() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.Spec.traffic_steering_function)
  return traffic_steering_function_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionContext_Spec::set_allocated_traffic_steering_function(std::string* traffic_steering_function) {
  if (traffic_steering_function != nullptr) {
    
  } else {
    
  }
  traffic_steering_function_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), traffic_steering_function,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (traffic_steering_function_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    traffic_steering_function_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.Spec.traffic_steering_function)
}

// string desired_shard = 2;
inline void SessionContext_Spec::clear_desired_shard() {
  desired_shard_.ClearToEmpty();
}
inline const std::string& SessionContext_Spec::desired_shard() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.Spec.desired_shard)
  return _internal_desired_shard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionContext_Spec::set_desired_shard(ArgT0&& arg0, ArgT... args) {
 
 desired_shard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.Spec.desired_shard)
}
inline std::string* SessionContext_Spec::mutable_desired_shard() {
  std::string* _s = _internal_mutable_desired_shard();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.Spec.desired_shard)
  return _s;
}
inline const std::string& SessionContext_Spec::_internal_desired_shard() const {
  return desired_shard_.Get();
}
inline void SessionContext_Spec::_internal_set_desired_shard(const std::string& value) {
  
  desired_shard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionContext_Spec::_internal_mutable_desired_shard() {
  
  return desired_shard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionContext_Spec::release_desired_shard() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.Spec.desired_shard)
  return desired_shard_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionContext_Spec::set_allocated_desired_shard(std::string* desired_shard) {
  if (desired_shard != nullptr) {
    
  } else {
    
  }
  desired_shard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), desired_shard,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (desired_shard_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    desired_shard_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.Spec.desired_shard)
}

// repeated string required_service_group = 3;
inline int SessionContext_Spec::_internal_required_service_group_size() const {
  return required_service_group_.size();
}
inline int SessionContext_Spec::required_service_group_size() const {
  return _internal_required_service_group_size();
}
inline void SessionContext_Spec::clear_required_service_group() {
  required_service_group_.Clear();
}
inline std::string* SessionContext_Spec::add_required_service_group() {
  std::string* _s = _internal_add_required_service_group();
  // @@protoc_insertion_point(field_add_mutable:bbf.sss.SessionContext.Spec.required_service_group)
  return _s;
}
inline const std::string& SessionContext_Spec::_internal_required_service_group(int index) const {
  return required_service_group_.Get(index);
}
inline const std::string& SessionContext_Spec::required_service_group(int index) const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.Spec.required_service_group)
  return _internal_required_service_group(index);
}
inline std::string* SessionContext_Spec::mutable_required_service_group(int index) {
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.Spec.required_service_group)
  return required_service_group_.Mutable(index);
}
inline void SessionContext_Spec::set_required_service_group(int index, const std::string& value) {
  required_service_group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.Spec.required_service_group)
}
inline void SessionContext_Spec::set_required_service_group(int index, std::string&& value) {
  required_service_group_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.Spec.required_service_group)
}
inline void SessionContext_Spec::set_required_service_group(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_service_group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:bbf.sss.SessionContext.Spec.required_service_group)
}
inline void SessionContext_Spec::set_required_service_group(int index, const char* value, size_t size) {
  required_service_group_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:bbf.sss.SessionContext.Spec.required_service_group)
}
inline std::string* SessionContext_Spec::_internal_add_required_service_group() {
  return required_service_group_.Add();
}
inline void SessionContext_Spec::add_required_service_group(const std::string& value) {
  required_service_group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:bbf.sss.SessionContext.Spec.required_service_group)
}
inline void SessionContext_Spec::add_required_service_group(std::string&& value) {
  required_service_group_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:bbf.sss.SessionContext.Spec.required_service_group)
}
inline void SessionContext_Spec::add_required_service_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  required_service_group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:bbf.sss.SessionContext.Spec.required_service_group)
}
inline void SessionContext_Spec::add_required_service_group(const char* value, size_t size) {
  required_service_group_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:bbf.sss.SessionContext.Spec.required_service_group)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SessionContext_Spec::required_service_group() const {
  // @@protoc_insertion_point(field_list:bbf.sss.SessionContext.Spec.required_service_group)
  return required_service_group_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SessionContext_Spec::mutable_required_service_group() {
  // @@protoc_insertion_point(field_mutable_list:bbf.sss.SessionContext.Spec.required_service_group)
  return &required_service_group_;
}

// string required_qos = 4;
inline void SessionContext_Spec::clear_required_qos() {
  required_qos_.ClearToEmpty();
}
inline const std::string& SessionContext_Spec::required_qos() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.Spec.required_qos)
  return _internal_required_qos();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionContext_Spec::set_required_qos(ArgT0&& arg0, ArgT... args) {
 
 required_qos_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.Spec.required_qos)
}
inline std::string* SessionContext_Spec::mutable_required_qos() {
  std::string* _s = _internal_mutable_required_qos();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.Spec.required_qos)
  return _s;
}
inline const std::string& SessionContext_Spec::_internal_required_qos() const {
  return required_qos_.Get();
}
inline void SessionContext_Spec::_internal_set_required_qos(const std::string& value) {
  
  required_qos_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionContext_Spec::_internal_mutable_required_qos() {
  
  return required_qos_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionContext_Spec::release_required_qos() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.Spec.required_qos)
  return required_qos_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionContext_Spec::set_allocated_required_qos(std::string* required_qos) {
  if (required_qos != nullptr) {
    
  } else {
    
  }
  required_qos_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), required_qos,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (required_qos_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    required_qos_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.Spec.required_qos)
}

// .bbf.sss.SessionContext.Spec.ContextType context_type = 5;
inline void SessionContext_Spec::clear_context_type() {
  context_type_ = 0;
}
inline ::bbf::sss::SessionContext_Spec_ContextType SessionContext_Spec::_internal_context_type() const {
  return static_cast< ::bbf::sss::SessionContext_Spec_ContextType >(context_type_);
}
inline ::bbf::sss::SessionContext_Spec_ContextType SessionContext_Spec::context_type() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.Spec.context_type)
  return _internal_context_type();
}
inline void SessionContext_Spec::_internal_set_context_type(::bbf::sss::SessionContext_Spec_ContextType value) {
  
  context_type_ = value;
}
inline void SessionContext_Spec::set_context_type(::bbf::sss::SessionContext_Spec_ContextType value) {
  _internal_set_context_type(value);
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.Spec.context_type)
}

// .bbf.sss.SessionFilter session_filter = 6;
inline bool SessionContext_Spec::_internal_has_session_filter() const {
  return this != internal_default_instance() && session_filter_ != nullptr;
}
inline bool SessionContext_Spec::has_session_filter() const {
  return _internal_has_session_filter();
}
inline void SessionContext_Spec::clear_session_filter() {
  if (GetArenaForAllocation() == nullptr && session_filter_ != nullptr) {
    delete session_filter_;
  }
  session_filter_ = nullptr;
}
inline const ::bbf::sss::SessionFilter& SessionContext_Spec::_internal_session_filter() const {
  const ::bbf::sss::SessionFilter* p = session_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::SessionFilter&>(
      ::bbf::sss::_SessionFilter_default_instance_);
}
inline const ::bbf::sss::SessionFilter& SessionContext_Spec::session_filter() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.Spec.session_filter)
  return _internal_session_filter();
}
inline void SessionContext_Spec::unsafe_arena_set_allocated_session_filter(
    ::bbf::sss::SessionFilter* session_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_filter_);
  }
  session_filter_ = session_filter;
  if (session_filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.SessionContext.Spec.session_filter)
}
inline ::bbf::sss::SessionFilter* SessionContext_Spec::release_session_filter() {
  
  ::bbf::sss::SessionFilter* temp = session_filter_;
  session_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::SessionFilter* SessionContext_Spec::unsafe_arena_release_session_filter() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.Spec.session_filter)
  
  ::bbf::sss::SessionFilter* temp = session_filter_;
  session_filter_ = nullptr;
  return temp;
}
inline ::bbf::sss::SessionFilter* SessionContext_Spec::_internal_mutable_session_filter() {
  
  if (session_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::SessionFilter>(GetArenaForAllocation());
    session_filter_ = p;
  }
  return session_filter_;
}
inline ::bbf::sss::SessionFilter* SessionContext_Spec::mutable_session_filter() {
  ::bbf::sss::SessionFilter* _msg = _internal_mutable_session_filter();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.Spec.session_filter)
  return _msg;
}
inline void SessionContext_Spec::set_allocated_session_filter(::bbf::sss::SessionFilter* session_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_filter_;
  }
  if (session_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::SessionFilter>::GetOwningArena(session_filter);
    if (message_arena != submessage_arena) {
      session_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_filter, submessage_arena);
    }
    
  } else {
    
  }
  session_filter_ = session_filter;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.Spec.session_filter)
}

// -------------------------------------------------------------------

// SessionContext_Status

// string current_shard = 2;
inline void SessionContext_Status::clear_current_shard() {
  current_shard_.ClearToEmpty();
}
inline const std::string& SessionContext_Status::current_shard() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.Status.current_shard)
  return _internal_current_shard();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionContext_Status::set_current_shard(ArgT0&& arg0, ArgT... args) {
 
 current_shard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.Status.current_shard)
}
inline std::string* SessionContext_Status::mutable_current_shard() {
  std::string* _s = _internal_mutable_current_shard();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.Status.current_shard)
  return _s;
}
inline const std::string& SessionContext_Status::_internal_current_shard() const {
  return current_shard_.Get();
}
inline void SessionContext_Status::_internal_set_current_shard(const std::string& value) {
  
  current_shard_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionContext_Status::_internal_mutable_current_shard() {
  
  return current_shard_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionContext_Status::release_current_shard() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.Status.current_shard)
  return current_shard_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionContext_Status::set_allocated_current_shard(std::string* current_shard) {
  if (current_shard != nullptr) {
    
  } else {
    
  }
  current_shard_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_shard,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_shard_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    current_shard_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.Status.current_shard)
}

// -------------------------------------------------------------------

// SessionContext

// string id = 1;
inline void SessionContext::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SessionContext::id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionContext::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionContext.id)
}
inline std::string* SessionContext::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.id)
  return _s;
}
inline const std::string& SessionContext::_internal_id() const {
  return id_.Get();
}
inline void SessionContext::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionContext::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionContext::release_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionContext::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.id)
}

// .bbf.sss.MetaData metadata = 2;
inline bool SessionContext::_internal_has_metadata() const {
  return this != internal_default_instance() && metadata_ != nullptr;
}
inline bool SessionContext::has_metadata() const {
  return _internal_has_metadata();
}
inline void SessionContext::clear_metadata() {
  if (GetArenaForAllocation() == nullptr && metadata_ != nullptr) {
    delete metadata_;
  }
  metadata_ = nullptr;
}
inline const ::bbf::sss::MetaData& SessionContext::_internal_metadata() const {
  const ::bbf::sss::MetaData* p = metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::MetaData&>(
      ::bbf::sss::_MetaData_default_instance_);
}
inline const ::bbf::sss::MetaData& SessionContext::metadata() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.metadata)
  return _internal_metadata();
}
inline void SessionContext::unsafe_arena_set_allocated_metadata(
    ::bbf::sss::MetaData* metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metadata_);
  }
  metadata_ = metadata;
  if (metadata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.SessionContext.metadata)
}
inline ::bbf::sss::MetaData* SessionContext::release_metadata() {
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::MetaData* SessionContext::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.metadata)
  
  ::bbf::sss::MetaData* temp = metadata_;
  metadata_ = nullptr;
  return temp;
}
inline ::bbf::sss::MetaData* SessionContext::_internal_mutable_metadata() {
  
  if (metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::MetaData>(GetArenaForAllocation());
    metadata_ = p;
  }
  return metadata_;
}
inline ::bbf::sss::MetaData* SessionContext::mutable_metadata() {
  ::bbf::sss::MetaData* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.metadata)
  return _msg;
}
inline void SessionContext::set_allocated_metadata(::bbf::sss::MetaData* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metadata_;
  }
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::MetaData>::GetOwningArena(metadata);
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.metadata)
}

// .bbf.sss.SessionContext.Spec spec = 3;
inline bool SessionContext::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool SessionContext::has_spec() const {
  return _internal_has_spec();
}
inline void SessionContext::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::bbf::sss::SessionContext_Spec& SessionContext::_internal_spec() const {
  const ::bbf::sss::SessionContext_Spec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::SessionContext_Spec&>(
      ::bbf::sss::_SessionContext_Spec_default_instance_);
}
inline const ::bbf::sss::SessionContext_Spec& SessionContext::spec() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.spec)
  return _internal_spec();
}
inline void SessionContext::unsafe_arena_set_allocated_spec(
    ::bbf::sss::SessionContext_Spec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.SessionContext.spec)
}
inline ::bbf::sss::SessionContext_Spec* SessionContext::release_spec() {
  
  ::bbf::sss::SessionContext_Spec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::SessionContext_Spec* SessionContext::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.spec)
  
  ::bbf::sss::SessionContext_Spec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::bbf::sss::SessionContext_Spec* SessionContext::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::SessionContext_Spec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::bbf::sss::SessionContext_Spec* SessionContext::mutable_spec() {
  ::bbf::sss::SessionContext_Spec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.spec)
  return _msg;
}
inline void SessionContext::set_allocated_spec(::bbf::sss::SessionContext_Spec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::SessionContext_Spec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.spec)
}

// .bbf.sss.SessionContext.Status status = 4;
inline bool SessionContext::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool SessionContext::has_status() const {
  return _internal_has_status();
}
inline void SessionContext::clear_status() {
  if (GetArenaForAllocation() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::bbf::sss::SessionContext_Status& SessionContext::_internal_status() const {
  const ::bbf::sss::SessionContext_Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::bbf::sss::SessionContext_Status&>(
      ::bbf::sss::_SessionContext_Status_default_instance_);
}
inline const ::bbf::sss::SessionContext_Status& SessionContext::status() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionContext.status)
  return _internal_status();
}
inline void SessionContext::unsafe_arena_set_allocated_status(
    ::bbf::sss::SessionContext_Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:bbf.sss.SessionContext.status)
}
inline ::bbf::sss::SessionContext_Status* SessionContext::release_status() {
  
  ::bbf::sss::SessionContext_Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::bbf::sss::SessionContext_Status* SessionContext::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionContext.status)
  
  ::bbf::sss::SessionContext_Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::bbf::sss::SessionContext_Status* SessionContext::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::bbf::sss::SessionContext_Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::bbf::sss::SessionContext_Status* SessionContext::mutable_status() {
  ::bbf::sss::SessionContext_Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionContext.status)
  return _msg;
}
inline void SessionContext::set_allocated_status(::bbf::sss::SessionContext_Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::bbf::sss::SessionContext_Status>::GetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionContext.status)
}

// -------------------------------------------------------------------

// SessionFilter

// string mac_address = 1;
inline void SessionFilter::clear_mac_address() {
  mac_address_.ClearToEmpty();
}
inline const std::string& SessionFilter::mac_address() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionFilter.mac_address)
  return _internal_mac_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionFilter::set_mac_address(ArgT0&& arg0, ArgT... args) {
 
 mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionFilter.mac_address)
}
inline std::string* SessionFilter::mutable_mac_address() {
  std::string* _s = _internal_mutable_mac_address();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionFilter.mac_address)
  return _s;
}
inline const std::string& SessionFilter::_internal_mac_address() const {
  return mac_address_.Get();
}
inline void SessionFilter::_internal_set_mac_address(const std::string& value) {
  
  mac_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionFilter::_internal_mutable_mac_address() {
  
  return mac_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionFilter::release_mac_address() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionFilter.mac_address)
  return mac_address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionFilter::set_allocated_mac_address(std::string* mac_address) {
  if (mac_address != nullptr) {
    
  } else {
    
  }
  mac_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mac_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mac_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mac_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionFilter.mac_address)
}

// int32 svlan = 2;
inline void SessionFilter::clear_svlan() {
  svlan_ = 0;
}
inline int32_t SessionFilter::_internal_svlan() const {
  return svlan_;
}
inline int32_t SessionFilter::svlan() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionFilter.svlan)
  return _internal_svlan();
}
inline void SessionFilter::_internal_set_svlan(int32_t value) {
  
  svlan_ = value;
}
inline void SessionFilter::set_svlan(int32_t value) {
  _internal_set_svlan(value);
  // @@protoc_insertion_point(field_set:bbf.sss.SessionFilter.svlan)
}

// int32 cvlan = 3;
inline void SessionFilter::clear_cvlan() {
  cvlan_ = 0;
}
inline int32_t SessionFilter::_internal_cvlan() const {
  return cvlan_;
}
inline int32_t SessionFilter::cvlan() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionFilter.cvlan)
  return _internal_cvlan();
}
inline void SessionFilter::_internal_set_cvlan(int32_t value) {
  
  cvlan_ = value;
}
inline void SessionFilter::set_cvlan(int32_t value) {
  _internal_set_cvlan(value);
  // @@protoc_insertion_point(field_set:bbf.sss.SessionFilter.cvlan)
}

// string circuit_id = 4;
inline void SessionFilter::clear_circuit_id() {
  circuit_id_.ClearToEmpty();
}
inline const std::string& SessionFilter::circuit_id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionFilter.circuit_id)
  return _internal_circuit_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionFilter::set_circuit_id(ArgT0&& arg0, ArgT... args) {
 
 circuit_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionFilter.circuit_id)
}
inline std::string* SessionFilter::mutable_circuit_id() {
  std::string* _s = _internal_mutable_circuit_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionFilter.circuit_id)
  return _s;
}
inline const std::string& SessionFilter::_internal_circuit_id() const {
  return circuit_id_.Get();
}
inline void SessionFilter::_internal_set_circuit_id(const std::string& value) {
  
  circuit_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionFilter::_internal_mutable_circuit_id() {
  
  return circuit_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionFilter::release_circuit_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionFilter.circuit_id)
  return circuit_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionFilter::set_allocated_circuit_id(std::string* circuit_id) {
  if (circuit_id != nullptr) {
    
  } else {
    
  }
  circuit_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), circuit_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (circuit_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    circuit_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionFilter.circuit_id)
}

// string remote_id = 5;
inline void SessionFilter::clear_remote_id() {
  remote_id_.ClearToEmpty();
}
inline const std::string& SessionFilter::remote_id() const {
  // @@protoc_insertion_point(field_get:bbf.sss.SessionFilter.remote_id)
  return _internal_remote_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionFilter::set_remote_id(ArgT0&& arg0, ArgT... args) {
 
 remote_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bbf.sss.SessionFilter.remote_id)
}
inline std::string* SessionFilter::mutable_remote_id() {
  std::string* _s = _internal_mutable_remote_id();
  // @@protoc_insertion_point(field_mutable:bbf.sss.SessionFilter.remote_id)
  return _s;
}
inline const std::string& SessionFilter::_internal_remote_id() const {
  return remote_id_.Get();
}
inline void SessionFilter::_internal_set_remote_id(const std::string& value) {
  
  remote_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SessionFilter::_internal_mutable_remote_id() {
  
  return remote_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SessionFilter::release_remote_id() {
  // @@protoc_insertion_point(field_release:bbf.sss.SessionFilter.remote_id)
  return remote_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SessionFilter::set_allocated_remote_id(std::string* remote_id) {
  if (remote_id != nullptr) {
    
  } else {
    
  }
  remote_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remote_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bbf.sss.SessionFilter.remote_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sss
}  // namespace bbf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::bbf::sss::SubscribeReq_SubscriptionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bbf::sss::SubscribeReq_SubscriptionType>() {
  return ::bbf::sss::SubscribeReq_SubscriptionType_descriptor();
}
template <> struct is_proto_enum< ::bbf::sss::NetworkConnection_Status_NcEndpointStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bbf::sss::NetworkConnection_Status_NcEndpointStatus>() {
  return ::bbf::sss::NetworkConnection_Status_NcEndpointStatus_descriptor();
}
template <> struct is_proto_enum< ::bbf::sss::SessionContext_Spec_ContextType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bbf::sss::SessionContext_Spec_ContextType>() {
  return ::bbf::sss::SessionContext_Spec_ContextType_descriptor();
}
template <> struct is_proto_enum< ::bbf::sss::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bbf::sss::Result>() {
  return ::bbf::sss::Result_descriptor();
}
template <> struct is_proto_enum< ::bbf::sss::ItemStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bbf::sss::ItemStatus>() {
  return ::bbf::sss::ItemStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sssupsf_2eproto
